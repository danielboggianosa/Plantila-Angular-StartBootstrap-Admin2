function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"], {
  /***/
  "./$$_lazy_route_resource lazy recursive":
  /*!******************************************************!*\
    !*** ./$$_lazy_route_resource lazy namespace object ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function $$_lazy_route_resourceLazyRecursive(module, exports) {
    function webpackEmptyAsyncContext(req) {
      // Here Promise.resolve().then() is used instead of new Promise() to prevent
      // uncaught exception popping up in devtools
      return Promise.resolve().then(function () {
        var e = new Error("Cannot find module '" + req + "'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
      });
    }

    webpackEmptyAsyncContext.keys = function () {
      return [];
    };

    webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
    module.exports = webpackEmptyAsyncContext;
    webpackEmptyAsyncContext.id = "./$$_lazy_route_resource lazy recursive";
    /***/
  },

  /***/
  "./node_modules/@angular/compiler/fesm2015/compiler.js":
  /*!*************************************************************!*\
    !*** ./node_modules/@angular/compiler/fesm2015/compiler.js ***!
    \*************************************************************/

  /*! exports provided: AST, ASTWithSource, AbsoluteSourceSpan, AotCompiler, AotSummaryResolver, ArrayType, AssertNotNull, AstMemoryEfficientTransformer, AstPath, AstTransformer, AttrAst, Attribute, Binary, BinaryOperator, BinaryOperatorExpr, BindingPipe, BoundDirectivePropertyAst, BoundElementProperty, BoundElementPropertyAst, BoundEventAst, BoundTextAst, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CONTENT_ATTR, CUSTOM_ELEMENTS_SCHEMA, CastExpr, Chain, ClassField, ClassMethod, ClassStmt, CommaExpr, Comment, CommentStmt, CompileDirectiveMetadata, CompileMetadataResolver, CompileNgModuleMetadata, CompilePipeMetadata, CompileReflector, CompileShallowModuleMetadata, CompileStylesheetMetadata, CompileSummaryKind, CompileTemplateMetadata, CompiledStylesheet, CompilerConfig, Conditional, ConditionalExpr, ConstantPool, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DYNAMIC_TYPE, DeclareFunctionStmt, DeclareVarStmt, DirectiveAst, DirectiveNormalizer, DirectiveResolver, DomElementSchemaRegistry, EMPTY_PARSE_LOCATION, EMPTY_SOURCE_SPAN, EOF, ERROR_COMPONENT_TYPE, Element, ElementAst, ElementSchemaRegistry, EmbeddedTemplateAst, EmitterVisitorContext, EmptyExpr, Expansion, ExpansionCase, Expression, ExpressionStatement, ExpressionType, ExternalExpr, ExternalReference, Extractor, FunctionCall, FunctionExpr, GeneratedFile, HOST_ATTR, HtmlParser, HtmlTagDefinition, I18NHtmlParser, Identifiers, IfStmt, ImplicitReceiver, InstantiateExpr, Interpolation, InterpolationConfig, InvokeFunctionExpr, InvokeMethodExpr, IvyParser, JSDocCommentStmt, JitCompiler, JitEvaluator, JitSummaryResolver, KeyedRead, KeyedWrite, Lexer, LiteralArray, LiteralArrayExpr, LiteralExpr, LiteralMap, LiteralMapExpr, LiteralPrimitive, MapType, MessageBundle, MethodCall, NAMED_ENTITIES, NGSP_UNICODE, NONE_TYPE, NO_ERRORS_SCHEMA, NgContentAst, NgModuleCompiler, NgModuleResolver, NodeWithI18n, NonNullAssert, NotExpr, NullAstVisitor, NullTemplateVisitor, ParseError, ParseErrorLevel, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseSpan, ParseTreeResult, ParsedEvent, ParsedProperty, ParsedPropertyType, ParsedVariable, Parser, ParserError, PipeResolver, PrefixNot, PropertyRead, PropertyWrite, ProviderAst, ProviderAstType, ProviderMeta, Quote, R3BoundTarget, R3FactoryTarget, R3Identifiers, R3ResolvedDependencyType, R3TargetBinder, ReadKeyExpr, ReadPropExpr, ReadVarExpr, RecursiveAstVisitor, RecursiveTemplateAstVisitor, RecursiveVisitor, ReferenceAst, ResolvedStaticSymbol, ResourceLoader, ReturnStatement, STRING_TYPE, SafeMethodCall, SafePropertyRead, SelectorContext, SelectorListContext, SelectorMatcher, Serializer, SplitInterpolation, Statement, StaticReflector, StaticSymbol, StaticSymbolCache, StaticSymbolResolver, StmtModifier, StyleCompiler, StylesCompileDependency, SummaryResolver, TagContentType, TemplateBinding, TemplateBindingParseResult, TemplateParseError, TemplateParseResult, TemplateParser, Text, TextAst, ThrowStmt, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstContent, TmplAstElement, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable, Token, TokenType, TransitiveCompileNgModuleMetadata, TreeError, TryCatchStmt, Type, TypeScriptEmitter, TypeofExpr, UrlResolver, VERSION, VariableAst, Version, ViewCompiler, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, Xliff, Xliff2, Xmb, XmlParser, Xtb, _ParseAST, analyzeAndValidateNgModules, analyzeFile, analyzeFileForInjectables, analyzeNgModules, collectExternalReferences, compileComponentFromMetadata, compileDirectiveFromMetadata, compileFactoryFunction, compileInjectable, compileInjector, compileNgModule, compilePipeFromMetadata, componentFactoryName, computeMsgId, core, createAotCompiler, createAotUrlResolver, createElementCssSelector, createLoweredSymbol, createOfflineCompileUrlResolver, createUrlResolverWithoutPackagePrefix, debugOutputAstAsTypeScript, findNode, flatten, formattedError, getHtmlTagDefinition, getNsPrefix, getParseErrors, getUrlScheme, hostViewClassName, identifierModuleUrl, identifierName, isEmptyExpression, isFormattedError, isIdentifier, isLoweredSymbol, isNgContainer, isNgContent, isNgTemplate, isQuote, isSyntaxError, literalMap, makeBindingParser, mergeAnalyzedFiles, mergeNsAndName, ngModuleJitUrl, parseHostBindings, parseTemplate, preserveWhitespacesDefault, publishFacade, r3JitTypeSourceSpan, removeSummaryDuplicates, rendererTypeName, sanitizeIdentifier, sharedStylesheetJitUrl, splitClasses, splitNsName, syntaxError, templateJitUrl, templateSourceUrl, templateVisitAll, toTypeScript, tokenName, tokenReference, typeSourceSpan, unescapeIdentifier, unwrapResolvedMetadata, verifyHostBindings, viewClassName, visitAll, visitAstChildren */

  /***/
  function node_modulesAngularCompilerFesm2015CompilerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    var _BoundPropertyMapping;

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AST", function () {
      return AST;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ASTWithSource", function () {
      return ASTWithSource;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AbsoluteSourceSpan", function () {
      return AbsoluteSourceSpan;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AotCompiler", function () {
      return AotCompiler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AotSummaryResolver", function () {
      return AotSummaryResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ArrayType", function () {
      return ArrayType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AssertNotNull", function () {
      return AssertNotNull;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AstMemoryEfficientTransformer", function () {
      return AstMemoryEfficientTransformer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AstPath", function () {
      return AstPath;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AstTransformer", function () {
      return AstTransformer$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AttrAst", function () {
      return AttrAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Attribute", function () {
      return Attribute;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Binary", function () {
      return Binary;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BinaryOperator", function () {
      return BinaryOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BinaryOperatorExpr", function () {
      return BinaryOperatorExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BindingPipe", function () {
      return BindingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BoundDirectivePropertyAst", function () {
      return BoundDirectivePropertyAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BoundElementProperty", function () {
      return BoundElementProperty;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BoundElementPropertyAst", function () {
      return BoundElementPropertyAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BoundEventAst", function () {
      return BoundEventAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BoundTextAst", function () {
      return BoundTextAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BuiltinMethod", function () {
      return BuiltinMethod;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BuiltinType", function () {
      return BuiltinType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BuiltinTypeName", function () {
      return BuiltinTypeName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BuiltinVar", function () {
      return BuiltinVar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CONTENT_ATTR", function () {
      return CONTENT_ATTR;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CUSTOM_ELEMENTS_SCHEMA", function () {
      return CUSTOM_ELEMENTS_SCHEMA;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CastExpr", function () {
      return CastExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Chain", function () {
      return Chain;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ClassField", function () {
      return ClassField;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ClassMethod", function () {
      return ClassMethod;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ClassStmt", function () {
      return ClassStmt;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CommaExpr", function () {
      return CommaExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Comment", function () {
      return Comment;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CommentStmt", function () {
      return CommentStmt;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompileDirectiveMetadata", function () {
      return CompileDirectiveMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompileMetadataResolver", function () {
      return CompileMetadataResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompileNgModuleMetadata", function () {
      return CompileNgModuleMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompilePipeMetadata", function () {
      return CompilePipeMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompileReflector", function () {
      return CompileReflector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompileShallowModuleMetadata", function () {
      return CompileShallowModuleMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompileStylesheetMetadata", function () {
      return CompileStylesheetMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompileSummaryKind", function () {
      return CompileSummaryKind;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompileTemplateMetadata", function () {
      return CompileTemplateMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompiledStylesheet", function () {
      return CompiledStylesheet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompilerConfig", function () {
      return CompilerConfig;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Conditional", function () {
      return Conditional;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ConditionalExpr", function () {
      return ConditionalExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ConstantPool", function () {
      return ConstantPool;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CssSelector", function () {
      return CssSelector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DEFAULT_INTERPOLATION_CONFIG", function () {
      return DEFAULT_INTERPOLATION_CONFIG;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DYNAMIC_TYPE", function () {
      return DYNAMIC_TYPE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DeclareFunctionStmt", function () {
      return DeclareFunctionStmt;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DeclareVarStmt", function () {
      return DeclareVarStmt;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DirectiveAst", function () {
      return DirectiveAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DirectiveNormalizer", function () {
      return DirectiveNormalizer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DirectiveResolver", function () {
      return DirectiveResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DomElementSchemaRegistry", function () {
      return DomElementSchemaRegistry;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EMPTY_PARSE_LOCATION", function () {
      return EMPTY_PARSE_LOCATION;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EMPTY_SOURCE_SPAN", function () {
      return EMPTY_SOURCE_SPAN;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EOF", function () {
      return EOF;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ERROR_COMPONENT_TYPE", function () {
      return ERROR_COMPONENT_TYPE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Element", function () {
      return Element$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ElementAst", function () {
      return ElementAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ElementSchemaRegistry", function () {
      return ElementSchemaRegistry;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EmbeddedTemplateAst", function () {
      return EmbeddedTemplateAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EmitterVisitorContext", function () {
      return EmitterVisitorContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EmptyExpr", function () {
      return EmptyExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Expansion", function () {
      return Expansion;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ExpansionCase", function () {
      return ExpansionCase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Expression", function () {
      return Expression;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ExpressionStatement", function () {
      return ExpressionStatement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ExpressionType", function () {
      return ExpressionType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ExternalExpr", function () {
      return ExternalExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ExternalReference", function () {
      return ExternalReference;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Extractor", function () {
      return Extractor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FunctionCall", function () {
      return FunctionCall;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FunctionExpr", function () {
      return FunctionExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GeneratedFile", function () {
      return GeneratedFile;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "HOST_ATTR", function () {
      return HOST_ATTR;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "HtmlParser", function () {
      return HtmlParser;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "HtmlTagDefinition", function () {
      return HtmlTagDefinition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "I18NHtmlParser", function () {
      return I18NHtmlParser;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Identifiers", function () {
      return Identifiers;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IfStmt", function () {
      return IfStmt;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ImplicitReceiver", function () {
      return ImplicitReceiver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InstantiateExpr", function () {
      return InstantiateExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Interpolation", function () {
      return Interpolation;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InterpolationConfig", function () {
      return InterpolationConfig;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InvokeFunctionExpr", function () {
      return InvokeFunctionExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InvokeMethodExpr", function () {
      return InvokeMethodExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IvyParser", function () {
      return IvyParser;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "JSDocCommentStmt", function () {
      return JSDocCommentStmt;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "JitCompiler", function () {
      return JitCompiler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "JitEvaluator", function () {
      return JitEvaluator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "JitSummaryResolver", function () {
      return JitSummaryResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "KeyedRead", function () {
      return KeyedRead;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "KeyedWrite", function () {
      return KeyedWrite;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Lexer", function () {
      return Lexer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LiteralArray", function () {
      return LiteralArray;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LiteralArrayExpr", function () {
      return LiteralArrayExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LiteralExpr", function () {
      return LiteralExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LiteralMap", function () {
      return LiteralMap;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LiteralMapExpr", function () {
      return LiteralMapExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LiteralPrimitive", function () {
      return LiteralPrimitive;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MapType", function () {
      return MapType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MessageBundle", function () {
      return MessageBundle;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MethodCall", function () {
      return MethodCall;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NAMED_ENTITIES", function () {
      return NAMED_ENTITIES;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NGSP_UNICODE", function () {
      return NGSP_UNICODE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NONE_TYPE", function () {
      return NONE_TYPE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NO_ERRORS_SCHEMA", function () {
      return NO_ERRORS_SCHEMA;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgContentAst", function () {
      return NgContentAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgModuleCompiler", function () {
      return NgModuleCompiler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgModuleResolver", function () {
      return NgModuleResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NodeWithI18n", function () {
      return NodeWithI18n;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NonNullAssert", function () {
      return NonNullAssert;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NotExpr", function () {
      return NotExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NullAstVisitor", function () {
      return NullAstVisitor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NullTemplateVisitor", function () {
      return NullTemplateVisitor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParseError", function () {
      return ParseError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParseErrorLevel", function () {
      return ParseErrorLevel;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParseLocation", function () {
      return ParseLocation;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParseSourceFile", function () {
      return ParseSourceFile;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParseSourceSpan", function () {
      return ParseSourceSpan;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParseSpan", function () {
      return ParseSpan;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParseTreeResult", function () {
      return ParseTreeResult;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParsedEvent", function () {
      return ParsedEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParsedProperty", function () {
      return ParsedProperty;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParsedPropertyType", function () {
      return ParsedPropertyType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParsedVariable", function () {
      return ParsedVariable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Parser", function () {
      return Parser$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ParserError", function () {
      return ParserError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PipeResolver", function () {
      return PipeResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PrefixNot", function () {
      return PrefixNot;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PropertyRead", function () {
      return PropertyRead;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PropertyWrite", function () {
      return PropertyWrite;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ProviderAst", function () {
      return ProviderAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ProviderAstType", function () {
      return ProviderAstType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ProviderMeta", function () {
      return ProviderMeta;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Quote", function () {
      return Quote;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "R3BoundTarget", function () {
      return R3BoundTarget;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "R3FactoryTarget", function () {
      return R3FactoryTarget;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "R3Identifiers", function () {
      return Identifiers$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "R3ResolvedDependencyType", function () {
      return R3ResolvedDependencyType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "R3TargetBinder", function () {
      return R3TargetBinder;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReadKeyExpr", function () {
      return ReadKeyExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReadPropExpr", function () {
      return ReadPropExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReadVarExpr", function () {
      return ReadVarExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RecursiveAstVisitor", function () {
      return RecursiveAstVisitor$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RecursiveTemplateAstVisitor", function () {
      return RecursiveTemplateAstVisitor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RecursiveVisitor", function () {
      return RecursiveVisitor$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReferenceAst", function () {
      return ReferenceAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ResolvedStaticSymbol", function () {
      return ResolvedStaticSymbol;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ResourceLoader", function () {
      return ResourceLoader;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReturnStatement", function () {
      return ReturnStatement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "STRING_TYPE", function () {
      return STRING_TYPE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SafeMethodCall", function () {
      return SafeMethodCall;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SafePropertyRead", function () {
      return SafePropertyRead;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SelectorContext", function () {
      return SelectorContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SelectorListContext", function () {
      return SelectorListContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SelectorMatcher", function () {
      return SelectorMatcher;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Serializer", function () {
      return Serializer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SplitInterpolation", function () {
      return SplitInterpolation;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Statement", function () {
      return Statement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "StaticReflector", function () {
      return StaticReflector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "StaticSymbol", function () {
      return StaticSymbol;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "StaticSymbolCache", function () {
      return StaticSymbolCache;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "StaticSymbolResolver", function () {
      return StaticSymbolResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "StmtModifier", function () {
      return StmtModifier;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "StyleCompiler", function () {
      return StyleCompiler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "StylesCompileDependency", function () {
      return StylesCompileDependency;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SummaryResolver", function () {
      return SummaryResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TagContentType", function () {
      return TagContentType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TemplateBinding", function () {
      return TemplateBinding;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TemplateBindingParseResult", function () {
      return TemplateBindingParseResult;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TemplateParseError", function () {
      return TemplateParseError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TemplateParseResult", function () {
      return TemplateParseResult;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TemplateParser", function () {
      return TemplateParser;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Text", function () {
      return Text$3;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TextAst", function () {
      return TextAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ThrowStmt", function () {
      return ThrowStmt;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstBoundAttribute", function () {
      return BoundAttribute;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstBoundEvent", function () {
      return BoundEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstBoundText", function () {
      return BoundText;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstContent", function () {
      return Content;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstElement", function () {
      return Element;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstRecursiveVisitor", function () {
      return RecursiveVisitor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstReference", function () {
      return Reference;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstTemplate", function () {
      return Template;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstText", function () {
      return Text;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstTextAttribute", function () {
      return TextAttribute;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TmplAstVariable", function () {
      return Variable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Token", function () {
      return Token$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TokenType", function () {
      return TokenType$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TransitiveCompileNgModuleMetadata", function () {
      return TransitiveCompileNgModuleMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TreeError", function () {
      return TreeError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TryCatchStmt", function () {
      return TryCatchStmt;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Type", function () {
      return Type$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TypeScriptEmitter", function () {
      return TypeScriptEmitter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TypeofExpr", function () {
      return TypeofExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UrlResolver", function () {
      return UrlResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VERSION", function () {
      return VERSION$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VariableAst", function () {
      return VariableAst;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Version", function () {
      return Version;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ViewCompiler", function () {
      return ViewCompiler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WrappedNodeExpr", function () {
      return WrappedNodeExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WriteKeyExpr", function () {
      return WriteKeyExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WritePropExpr", function () {
      return WritePropExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WriteVarExpr", function () {
      return WriteVarExpr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Xliff", function () {
      return Xliff;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Xliff2", function () {
      return Xliff2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Xmb", function () {
      return Xmb;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "XmlParser", function () {
      return XmlParser;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Xtb", function () {
      return Xtb;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "_ParseAST", function () {
      return _ParseAST;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "analyzeAndValidateNgModules", function () {
      return analyzeAndValidateNgModules;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "analyzeFile", function () {
      return analyzeFile;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "analyzeFileForInjectables", function () {
      return analyzeFileForInjectables;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "analyzeNgModules", function () {
      return analyzeNgModules;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "collectExternalReferences", function () {
      return collectExternalReferences;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compileComponentFromMetadata", function () {
      return compileComponentFromMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compileDirectiveFromMetadata", function () {
      return compileDirectiveFromMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compileFactoryFunction", function () {
      return compileFactoryFunction;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compileInjectable", function () {
      return _compileInjectable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compileInjector", function () {
      return _compileInjector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compileNgModule", function () {
      return _compileNgModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compilePipeFromMetadata", function () {
      return compilePipeFromMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "componentFactoryName", function () {
      return componentFactoryName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeMsgId", function () {
      return computeMsgId;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "core", function () {
      return core;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createAotCompiler", function () {
      return createAotCompiler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createAotUrlResolver", function () {
      return createAotUrlResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createElementCssSelector", function () {
      return createElementCssSelector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createLoweredSymbol", function () {
      return createLoweredSymbol;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createOfflineCompileUrlResolver", function () {
      return createOfflineCompileUrlResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createUrlResolverWithoutPackagePrefix", function () {
      return createUrlResolverWithoutPackagePrefix;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "debugOutputAstAsTypeScript", function () {
      return debugOutputAstAsTypeScript;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "findNode", function () {
      return findNode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flatten", function () {
      return flatten;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "formattedError", function () {
      return formattedError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getHtmlTagDefinition", function () {
      return getHtmlTagDefinition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getNsPrefix", function () {
      return getNsPrefix;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getParseErrors", function () {
      return getParseErrors;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getUrlScheme", function () {
      return getUrlScheme;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "hostViewClassName", function () {
      return hostViewClassName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "identifierModuleUrl", function () {
      return identifierModuleUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "identifierName", function () {
      return identifierName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isEmptyExpression", function () {
      return isEmptyExpression;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isFormattedError", function () {
      return isFormattedError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isIdentifier", function () {
      return isIdentifier;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isLoweredSymbol", function () {
      return isLoweredSymbol;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isNgContainer", function () {
      return isNgContainer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isNgContent", function () {
      return isNgContent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isNgTemplate", function () {
      return isNgTemplate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isQuote", function () {
      return isQuote;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isSyntaxError", function () {
      return isSyntaxError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "literalMap", function () {
      return literalMap;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "makeBindingParser", function () {
      return makeBindingParser;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeAnalyzedFiles", function () {
      return mergeAnalyzedFiles;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeNsAndName", function () {
      return mergeNsAndName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ngModuleJitUrl", function () {
      return ngModuleJitUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "parseHostBindings", function () {
      return parseHostBindings;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "parseTemplate", function () {
      return parseTemplate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "preserveWhitespacesDefault", function () {
      return preserveWhitespacesDefault;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "publishFacade", function () {
      return publishFacade;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "r3JitTypeSourceSpan", function () {
      return r3JitTypeSourceSpan;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "removeSummaryDuplicates", function () {
      return removeSummaryDuplicates;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rendererTypeName", function () {
      return rendererTypeName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sanitizeIdentifier", function () {
      return sanitizeIdentifier;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sharedStylesheetJitUrl", function () {
      return sharedStylesheetJitUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "splitClasses", function () {
      return splitClasses;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "splitNsName", function () {
      return splitNsName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "syntaxError", function () {
      return syntaxError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "templateJitUrl", function () {
      return templateJitUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "templateSourceUrl", function () {
      return templateSourceUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "templateVisitAll", function () {
      return templateVisitAll;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "toTypeScript", function () {
      return toTypeScript;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "tokenName", function () {
      return tokenName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "tokenReference", function () {
      return tokenReference;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "typeSourceSpan", function () {
      return typeSourceSpan;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "unescapeIdentifier", function () {
      return unescapeIdentifier;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "unwrapResolvedMetadata", function () {
      return unwrapResolvedMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "verifyHostBindings", function () {
      return verifyHostBindings;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "viewClassName", function () {
      return viewClassName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "visitAll", function () {
      return visitAll$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "visitAstChildren", function () {
      return visitAstChildren;
    });
    /**
     * @license Angular v9.0.4
     * (c) 2010-2020 Google LLC. https://angular.io/
     * License: MIT
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var TagContentType;

    (function (TagContentType) {
      TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
      TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
      TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
    })(TagContentType || (TagContentType = {}));

    function splitNsName(elementName) {
      if (elementName[0] != ':') {
        return [null, elementName];
      }

      var colonIndex = elementName.indexOf(':', 1);

      if (colonIndex == -1) {
        throw new Error("Unsupported format \"".concat(elementName, "\" expecting \":namespace:name\""));
      }

      return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
    } // `<ng-container>` tags work the same regardless the namespace


    function isNgContainer(tagName) {
      return splitNsName(tagName)[1] === 'ng-container';
    } // `<ng-content>` tags work the same regardless the namespace


    function isNgContent(tagName) {
      return splitNsName(tagName)[1] === 'ng-content';
    } // `<ng-template>` tags work the same regardless the namespace


    function isNgTemplate(tagName) {
      return splitNsName(tagName)[1] === 'ng-template';
    }

    function getNsPrefix(fullName) {
      return fullName === null ? null : splitNsName(fullName)[0];
    }

    function mergeNsAndName(prefix, localName) {
      return prefix ? ":".concat(prefix, ":").concat(localName) : localName;
    } // see http://www.w3.org/TR/html51/syntax.html#named-character-references
    // see https://html.spec.whatwg.org/multipage/entities.json
    // This list is not exhaustive to keep the compiler footprint low.
    // The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not
    // exist.


    var NAMED_ENTITIES = {
      'Aacute': "\xC1",
      'aacute': "\xE1",
      'Acirc': "\xC2",
      'acirc': "\xE2",
      'acute': "\xB4",
      'AElig': "\xC6",
      'aelig': "\xE6",
      'Agrave': "\xC0",
      'agrave': "\xE0",
      'alefsym': "\u2135",
      'Alpha': "\u0391",
      'alpha': "\u03B1",
      'amp': '&',
      'and': "\u2227",
      'ang': "\u2220",
      'apos': "'",
      'Aring': "\xC5",
      'aring': "\xE5",
      'asymp': "\u2248",
      'Atilde': "\xC3",
      'atilde': "\xE3",
      'Auml': "\xC4",
      'auml': "\xE4",
      'bdquo': "\u201E",
      'Beta': "\u0392",
      'beta': "\u03B2",
      'brvbar': "\xA6",
      'bull': "\u2022",
      'cap': "\u2229",
      'Ccedil': "\xC7",
      'ccedil': "\xE7",
      'cedil': "\xB8",
      'cent': "\xA2",
      'Chi': "\u03A7",
      'chi': "\u03C7",
      'circ': "\u02C6",
      'clubs': "\u2663",
      'cong': "\u2245",
      'copy': "\xA9",
      'crarr': "\u21B5",
      'cup': "\u222A",
      'curren': "\xA4",
      'dagger': "\u2020",
      'Dagger': "\u2021",
      'darr': "\u2193",
      'dArr': "\u21D3",
      'deg': "\xB0",
      'Delta': "\u0394",
      'delta': "\u03B4",
      'diams': "\u2666",
      'divide': "\xF7",
      'Eacute': "\xC9",
      'eacute': "\xE9",
      'Ecirc': "\xCA",
      'ecirc': "\xEA",
      'Egrave': "\xC8",
      'egrave': "\xE8",
      'empty': "\u2205",
      'emsp': "\u2003",
      'ensp': "\u2002",
      'Epsilon': "\u0395",
      'epsilon': "\u03B5",
      'equiv': "\u2261",
      'Eta': "\u0397",
      'eta': "\u03B7",
      'ETH': "\xD0",
      'eth': "\xF0",
      'Euml': "\xCB",
      'euml': "\xEB",
      'euro': "\u20AC",
      'exist': "\u2203",
      'fnof': "\u0192",
      'forall': "\u2200",
      'frac12': "\xBD",
      'frac14': "\xBC",
      'frac34': "\xBE",
      'frasl': "\u2044",
      'Gamma': "\u0393",
      'gamma': "\u03B3",
      'ge': "\u2265",
      'gt': '>',
      'harr': "\u2194",
      'hArr': "\u21D4",
      'hearts': "\u2665",
      'hellip': "\u2026",
      'Iacute': "\xCD",
      'iacute': "\xED",
      'Icirc': "\xCE",
      'icirc': "\xEE",
      'iexcl': "\xA1",
      'Igrave': "\xCC",
      'igrave': "\xEC",
      'image': "\u2111",
      'infin': "\u221E",
      'int': "\u222B",
      'Iota': "\u0399",
      'iota': "\u03B9",
      'iquest': "\xBF",
      'isin': "\u2208",
      'Iuml': "\xCF",
      'iuml': "\xEF",
      'Kappa': "\u039A",
      'kappa': "\u03BA",
      'Lambda': "\u039B",
      'lambda': "\u03BB",
      'lang': "\u27E8",
      'laquo': "\xAB",
      'larr': "\u2190",
      'lArr': "\u21D0",
      'lceil': "\u2308",
      'ldquo': "\u201C",
      'le': "\u2264",
      'lfloor': "\u230A",
      'lowast': "\u2217",
      'loz': "\u25CA",
      'lrm': "\u200E",
      'lsaquo': "\u2039",
      'lsquo': "\u2018",
      'lt': '<',
      'macr': "\xAF",
      'mdash': "\u2014",
      'micro': "\xB5",
      'middot': "\xB7",
      'minus': "\u2212",
      'Mu': "\u039C",
      'mu': "\u03BC",
      'nabla': "\u2207",
      'nbsp': "\xA0",
      'ndash': "\u2013",
      'ne': "\u2260",
      'ni': "\u220B",
      'not': "\xAC",
      'notin': "\u2209",
      'nsub': "\u2284",
      'Ntilde': "\xD1",
      'ntilde': "\xF1",
      'Nu': "\u039D",
      'nu': "\u03BD",
      'Oacute': "\xD3",
      'oacute': "\xF3",
      'Ocirc': "\xD4",
      'ocirc': "\xF4",
      'OElig': "\u0152",
      'oelig': "\u0153",
      'Ograve': "\xD2",
      'ograve': "\xF2",
      'oline': "\u203E",
      'Omega': "\u03A9",
      'omega': "\u03C9",
      'Omicron': "\u039F",
      'omicron': "\u03BF",
      'oplus': "\u2295",
      'or': "\u2228",
      'ordf': "\xAA",
      'ordm': "\xBA",
      'Oslash': "\xD8",
      'oslash': "\xF8",
      'Otilde': "\xD5",
      'otilde': "\xF5",
      'otimes': "\u2297",
      'Ouml': "\xD6",
      'ouml': "\xF6",
      'para': "\xB6",
      'permil': "\u2030",
      'perp': "\u22A5",
      'Phi': "\u03A6",
      'phi': "\u03C6",
      'Pi': "\u03A0",
      'pi': "\u03C0",
      'piv': "\u03D6",
      'plusmn': "\xB1",
      'pound': "\xA3",
      'prime': "\u2032",
      'Prime': "\u2033",
      'prod': "\u220F",
      'prop': "\u221D",
      'Psi': "\u03A8",
      'psi': "\u03C8",
      'quot': "\"",
      'radic': "\u221A",
      'rang': "\u27E9",
      'raquo': "\xBB",
      'rarr': "\u2192",
      'rArr': "\u21D2",
      'rceil': "\u2309",
      'rdquo': "\u201D",
      'real': "\u211C",
      'reg': "\xAE",
      'rfloor': "\u230B",
      'Rho': "\u03A1",
      'rho': "\u03C1",
      'rlm': "\u200F",
      'rsaquo': "\u203A",
      'rsquo': "\u2019",
      'sbquo': "\u201A",
      'Scaron': "\u0160",
      'scaron': "\u0161",
      'sdot': "\u22C5",
      'sect': "\xA7",
      'shy': "\xAD",
      'Sigma': "\u03A3",
      'sigma': "\u03C3",
      'sigmaf': "\u03C2",
      'sim': "\u223C",
      'spades': "\u2660",
      'sub': "\u2282",
      'sube': "\u2286",
      'sum': "\u2211",
      'sup': "\u2283",
      'sup1': "\xB9",
      'sup2': "\xB2",
      'sup3': "\xB3",
      'supe': "\u2287",
      'szlig': "\xDF",
      'Tau': "\u03A4",
      'tau': "\u03C4",
      'there4': "\u2234",
      'Theta': "\u0398",
      'theta': "\u03B8",
      'thetasym': "\u03D1",
      'thinsp': "\u2009",
      'THORN': "\xDE",
      'thorn': "\xFE",
      'tilde': "\u02DC",
      'times': "\xD7",
      'trade': "\u2122",
      'Uacute': "\xDA",
      'uacute': "\xFA",
      'uarr': "\u2191",
      'uArr': "\u21D1",
      'Ucirc': "\xDB",
      'ucirc': "\xFB",
      'Ugrave': "\xD9",
      'ugrave': "\xF9",
      'uml': "\xA8",
      'upsih': "\u03D2",
      'Upsilon': "\u03A5",
      'upsilon': "\u03C5",
      'Uuml': "\xDC",
      'uuml': "\xFC",
      'weierp': "\u2118",
      'Xi': "\u039E",
      'xi': "\u03BE",
      'Yacute': "\xDD",
      'yacute': "\xFD",
      'yen': "\xA5",
      'yuml': "\xFF",
      'Yuml': "\u0178",
      'Zeta': "\u0396",
      'zeta': "\u03B6",
      'zwj': "\u200D",
      'zwnj': "\u200C"
    }; // The &ngsp; pseudo-entity is denoting a space. see:
    // https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart

    var NGSP_UNICODE = "\uE500";
    NAMED_ENTITIES['ngsp'] = NGSP_UNICODE;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    var HtmlTagDefinition =
    /*#__PURE__*/
    function () {
      function HtmlTagDefinition() {
        var _this = this;

        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            closedByChildren = _ref2.closedByChildren,
            implicitNamespacePrefix = _ref2.implicitNamespacePrefix,
            _ref2$contentType = _ref2.contentType,
            contentType = _ref2$contentType === void 0 ? TagContentType.PARSABLE_DATA : _ref2$contentType,
            _ref2$closedByParent = _ref2.closedByParent,
            closedByParent = _ref2$closedByParent === void 0 ? false : _ref2$closedByParent,
            _ref2$isVoid = _ref2.isVoid,
            isVoid = _ref2$isVoid === void 0 ? false : _ref2$isVoid,
            _ref2$ignoreFirstLf = _ref2.ignoreFirstLf,
            ignoreFirstLf = _ref2$ignoreFirstLf === void 0 ? false : _ref2$ignoreFirstLf;

        _classCallCheck(this, HtmlTagDefinition);

        this.closedByChildren = {};
        this.closedByParent = false;
        this.canSelfClose = false;

        if (closedByChildren && closedByChildren.length > 0) {
          closedByChildren.forEach(function (tagName) {
            return _this.closedByChildren[tagName] = true;
          });
        }

        this.isVoid = isVoid;
        this.closedByParent = closedByParent || isVoid;
        this.implicitNamespacePrefix = implicitNamespacePrefix || null;
        this.contentType = contentType;
        this.ignoreFirstLf = ignoreFirstLf;
      }

      _createClass(HtmlTagDefinition, [{
        key: "isClosedByChild",
        value: function isClosedByChild(name) {
          return this.isVoid || name.toLowerCase() in this.closedByChildren;
        }
      }]);

      return HtmlTagDefinition;
    }();

    var _DEFAULT_TAG_DEFINITION; // see http://www.w3.org/TR/html51/syntax.html#optional-tags
    // This implementation does not fully conform to the HTML5 spec.


    var TAG_DEFINITIONS;

    function getHtmlTagDefinition(tagName) {
      if (!TAG_DEFINITIONS) {
        _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
        TAG_DEFINITIONS = {
          'base': new HtmlTagDefinition({
            isVoid: true
          }),
          'meta': new HtmlTagDefinition({
            isVoid: true
          }),
          'area': new HtmlTagDefinition({
            isVoid: true
          }),
          'embed': new HtmlTagDefinition({
            isVoid: true
          }),
          'link': new HtmlTagDefinition({
            isVoid: true
          }),
          'img': new HtmlTagDefinition({
            isVoid: true
          }),
          'input': new HtmlTagDefinition({
            isVoid: true
          }),
          'param': new HtmlTagDefinition({
            isVoid: true
          }),
          'hr': new HtmlTagDefinition({
            isVoid: true
          }),
          'br': new HtmlTagDefinition({
            isVoid: true
          }),
          'source': new HtmlTagDefinition({
            isVoid: true
          }),
          'track': new HtmlTagDefinition({
            isVoid: true
          }),
          'wbr': new HtmlTagDefinition({
            isVoid: true
          }),
          'p': new HtmlTagDefinition({
            closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],
            closedByParent: true
          }),
          'thead': new HtmlTagDefinition({
            closedByChildren: ['tbody', 'tfoot']
          }),
          'tbody': new HtmlTagDefinition({
            closedByChildren: ['tbody', 'tfoot'],
            closedByParent: true
          }),
          'tfoot': new HtmlTagDefinition({
            closedByChildren: ['tbody'],
            closedByParent: true
          }),
          'tr': new HtmlTagDefinition({
            closedByChildren: ['tr'],
            closedByParent: true
          }),
          'td': new HtmlTagDefinition({
            closedByChildren: ['td', 'th'],
            closedByParent: true
          }),
          'th': new HtmlTagDefinition({
            closedByChildren: ['td', 'th'],
            closedByParent: true
          }),
          'col': new HtmlTagDefinition({
            isVoid: true
          }),
          'svg': new HtmlTagDefinition({
            implicitNamespacePrefix: 'svg'
          }),
          'math': new HtmlTagDefinition({
            implicitNamespacePrefix: 'math'
          }),
          'li': new HtmlTagDefinition({
            closedByChildren: ['li'],
            closedByParent: true
          }),
          'dt': new HtmlTagDefinition({
            closedByChildren: ['dt', 'dd']
          }),
          'dd': new HtmlTagDefinition({
            closedByChildren: ['dt', 'dd'],
            closedByParent: true
          }),
          'rb': new HtmlTagDefinition({
            closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
            closedByParent: true
          }),
          'rt': new HtmlTagDefinition({
            closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
            closedByParent: true
          }),
          'rtc': new HtmlTagDefinition({
            closedByChildren: ['rb', 'rtc', 'rp'],
            closedByParent: true
          }),
          'rp': new HtmlTagDefinition({
            closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
            closedByParent: true
          }),
          'optgroup': new HtmlTagDefinition({
            closedByChildren: ['optgroup'],
            closedByParent: true
          }),
          'option': new HtmlTagDefinition({
            closedByChildren: ['option', 'optgroup'],
            closedByParent: true
          }),
          'pre': new HtmlTagDefinition({
            ignoreFirstLf: true
          }),
          'listing': new HtmlTagDefinition({
            ignoreFirstLf: true
          }),
          'style': new HtmlTagDefinition({
            contentType: TagContentType.RAW_TEXT
          }),
          'script': new HtmlTagDefinition({
            contentType: TagContentType.RAW_TEXT
          }),
          'title': new HtmlTagDefinition({
            contentType: TagContentType.ESCAPABLE_RAW_TEXT
          }),
          'textarea': new HtmlTagDefinition({
            contentType: TagContentType.ESCAPABLE_RAW_TEXT,
            ignoreFirstLf: true
          })
        };
      }

      return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' + // 1: ":not("
    '(([\\.\\#]?)[-\\w]+)|' + // 2: "tag"; 3: "."/"#";
    // "-" should appear first in the regexp below as FF31 parses "[.-\w]" as a range
    // 4: attribute; 5: attribute_string; 6: attribute_value
    '(?:\\[([-.\\w*]+)(?:=([\"\']?)([^\\]\"\']*)\\5)?\\])|' + // "[name]", "[name=value]",
    // "[name="value"]",
    // "[name='value']"
    '(\\))|' + // 7: ")"
    '(\\s*,\\s*)', // 8: ","
    'g');
    /**
     * A css selector contains an element name,
     * css classes and attribute/value pairs with the purpose
     * of selecting subsets out of them.
     */


    var CssSelector =
    /*#__PURE__*/
    function () {
      function CssSelector() {
        _classCallCheck(this, CssSelector);

        this.element = null;
        this.classNames = [];
        /**
         * The selectors are encoded in pairs where:
         * - even locations are attribute names
         * - odd locations are attribute values.
         *
         * Example:
         * Selector: `[key1=value1][key2]` would parse to:
         * ```
         * ['key1', 'value1', 'key2', '']
         * ```
         */

        this.attrs = [];
        this.notSelectors = [];
      }

      _createClass(CssSelector, [{
        key: "isElementSelector",
        value: function isElementSelector() {
          return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;
        }
      }, {
        key: "hasElementSelector",
        value: function hasElementSelector() {
          return !!this.element;
        }
      }, {
        key: "setElement",
        value: function setElement() {
          var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.element = element;
        }
        /** Gets a template string for an element that matches the selector. */

      }, {
        key: "getMatchingElementTemplate",
        value: function getMatchingElementTemplate() {
          var tagName = this.element || 'div';
          var classAttr = this.classNames.length > 0 ? " class=\"".concat(this.classNames.join(' '), "\"") : '';
          var attrs = '';

          for (var i = 0; i < this.attrs.length; i += 2) {
            var attrName = this.attrs[i];
            var attrValue = this.attrs[i + 1] !== '' ? "=\"".concat(this.attrs[i + 1], "\"") : '';
            attrs += " ".concat(attrName).concat(attrValue);
          }

          return getHtmlTagDefinition(tagName).isVoid ? "<".concat(tagName).concat(classAttr).concat(attrs, "/>") : "<".concat(tagName).concat(classAttr).concat(attrs, "></").concat(tagName, ">");
        }
      }, {
        key: "getAttrs",
        value: function getAttrs() {
          var result = [];

          if (this.classNames.length > 0) {
            result.push('class', this.classNames.join(' '));
          }

          return result.concat(this.attrs);
        }
      }, {
        key: "addAttribute",
        value: function addAttribute(name) {
          var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          this.attrs.push(name, value && value.toLowerCase() || '');
        }
      }, {
        key: "addClassName",
        value: function addClassName(name) {
          this.classNames.push(name.toLowerCase());
        }
      }, {
        key: "toString",
        value: function toString() {
          var res = this.element || '';

          if (this.classNames) {
            this.classNames.forEach(function (klass) {
              return res += ".".concat(klass);
            });
          }

          if (this.attrs) {
            for (var i = 0; i < this.attrs.length; i += 2) {
              var name = this.attrs[i];
              var value = this.attrs[i + 1];
              res += "[".concat(name).concat(value ? '=' + value : '', "]");
            }
          }

          this.notSelectors.forEach(function (notSelector) {
            return res += ":not(".concat(notSelector, ")");
          });
          return res;
        }
      }], [{
        key: "parse",
        value: function parse(selector) {
          var results = [];

          var _addResult = function _addResult(res, cssSel) {
            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {
              cssSel.element = '*';
            }

            res.push(cssSel);
          };

          var cssSelector = new CssSelector();
          var match;
          var current = cssSelector;
          var inNot = false;
          _SELECTOR_REGEXP.lastIndex = 0;

          while (match = _SELECTOR_REGEXP.exec(selector)) {
            if (match[1
            /* NOT */
            ]) {
              if (inNot) {
                throw new Error('Nesting :not in a selector is not allowed');
              }

              inNot = true;
              current = new CssSelector();
              cssSelector.notSelectors.push(current);
            }

            var tag = match[2
            /* TAG */
            ];

            if (tag) {
              var prefix = match[3
              /* PREFIX */
              ];

              if (prefix === '#') {
                // #hash
                current.addAttribute('id', tag.substr(1));
              } else if (prefix === '.') {
                // Class
                current.addClassName(tag.substr(1));
              } else {
                // Element
                current.setElement(tag);
              }
            }

            var attribute = match[4
            /* ATTRIBUTE */
            ];

            if (attribute) {
              current.addAttribute(attribute, match[6
              /* ATTRIBUTE_VALUE */
              ]);
            }

            if (match[7
            /* NOT_END */
            ]) {
              inNot = false;
              current = cssSelector;
            }

            if (match[8
            /* SEPARATOR */
            ]) {
              if (inNot) {
                throw new Error('Multiple selectors in :not are not supported');
              }

              _addResult(results, cssSelector);

              cssSelector = current = new CssSelector();
            }
          }

          _addResult(results, cssSelector);

          return results;
        }
      }]);

      return CssSelector;
    }();
    /**
     * Reads a list of CssSelectors and allows to calculate which ones
     * are contained in a given CssSelector.
     */


    var SelectorMatcher =
    /*#__PURE__*/
    function () {
      function SelectorMatcher() {
        _classCallCheck(this, SelectorMatcher);

        this._elementMap = new Map();
        this._elementPartialMap = new Map();
        this._classMap = new Map();
        this._classPartialMap = new Map();
        this._attrValueMap = new Map();
        this._attrValuePartialMap = new Map();
        this._listContexts = [];
      }

      _createClass(SelectorMatcher, [{
        key: "addSelectables",
        value: function addSelectables(cssSelectors, callbackCtxt) {
          var listContext = null;

          if (cssSelectors.length > 1) {
            listContext = new SelectorListContext(cssSelectors);

            this._listContexts.push(listContext);
          }

          for (var i = 0; i < cssSelectors.length; i++) {
            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
          }
        }
        /**
         * Add an object that can be found later on by calling `match`.
         * @param cssSelector A css selector
         * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
         */

      }, {
        key: "_addSelectable",
        value: function _addSelectable(cssSelector, callbackCtxt, listContext) {
          var matcher = this;
          var element = cssSelector.element;
          var classNames = cssSelector.classNames;
          var attrs = cssSelector.attrs;
          var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);

          if (element) {
            var isTerminal = attrs.length === 0 && classNames.length === 0;

            if (isTerminal) {
              this._addTerminal(matcher._elementMap, element, selectable);
            } else {
              matcher = this._addPartial(matcher._elementPartialMap, element);
            }
          }

          if (classNames) {
            for (var i = 0; i < classNames.length; i++) {
              var _isTerminal = attrs.length === 0 && i === classNames.length - 1;

              var className = classNames[i];

              if (_isTerminal) {
                this._addTerminal(matcher._classMap, className, selectable);
              } else {
                matcher = this._addPartial(matcher._classPartialMap, className);
              }
            }
          }

          if (attrs) {
            for (var _i = 0; _i < attrs.length; _i += 2) {
              var _isTerminal2 = _i === attrs.length - 2;

              var name = attrs[_i];
              var value = attrs[_i + 1];

              if (_isTerminal2) {
                var terminalMap = matcher._attrValueMap;
                var terminalValuesMap = terminalMap.get(name);

                if (!terminalValuesMap) {
                  terminalValuesMap = new Map();
                  terminalMap.set(name, terminalValuesMap);
                }

                this._addTerminal(terminalValuesMap, value, selectable);
              } else {
                var partialMap = matcher._attrValuePartialMap;
                var partialValuesMap = partialMap.get(name);

                if (!partialValuesMap) {
                  partialValuesMap = new Map();
                  partialMap.set(name, partialValuesMap);
                }

                matcher = this._addPartial(partialValuesMap, value);
              }
            }
          }
        }
      }, {
        key: "_addTerminal",
        value: function _addTerminal(map, name, selectable) {
          var terminalList = map.get(name);

          if (!terminalList) {
            terminalList = [];
            map.set(name, terminalList);
          }

          terminalList.push(selectable);
        }
      }, {
        key: "_addPartial",
        value: function _addPartial(map, name) {
          var matcher = map.get(name);

          if (!matcher) {
            matcher = new SelectorMatcher();
            map.set(name, matcher);
          }

          return matcher;
        }
        /**
         * Find the objects that have been added via `addSelectable`
         * whose css selector is contained in the given css selector.
         * @param cssSelector A css selector
         * @param matchedCallback This callback will be called with the object handed into `addSelectable`
         * @return boolean true if a match was found
        */

      }, {
        key: "match",
        value: function match(cssSelector, matchedCallback) {
          var result = false;
          var element = cssSelector.element;
          var classNames = cssSelector.classNames;
          var attrs = cssSelector.attrs;

          for (var i = 0; i < this._listContexts.length; i++) {
            this._listContexts[i].alreadyMatched = false;
          }

          result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
          result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;

          if (classNames) {
            for (var _i2 = 0; _i2 < classNames.length; _i2++) {
              var className = classNames[_i2];
              result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
              result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
            }
          }

          if (attrs) {
            for (var _i3 = 0; _i3 < attrs.length; _i3 += 2) {
              var name = attrs[_i3];
              var value = attrs[_i3 + 1];

              var terminalValuesMap = this._attrValueMap.get(name);

              if (value) {
                result = this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
              }

              result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;

              var partialValuesMap = this._attrValuePartialMap.get(name);

              if (value) {
                result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
              }

              result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
            }
          }

          return result;
        }
        /** @internal */

      }, {
        key: "_matchTerminal",
        value: function _matchTerminal(map, name, cssSelector, matchedCallback) {
          if (!map || typeof name !== 'string') {
            return false;
          }

          var selectables = map.get(name) || [];
          var starSelectables = map.get('*');

          if (starSelectables) {
            selectables = selectables.concat(starSelectables);
          }

          if (selectables.length === 0) {
            return false;
          }

          var selectable;
          var result = false;

          for (var i = 0; i < selectables.length; i++) {
            selectable = selectables[i];
            result = selectable.finalize(cssSelector, matchedCallback) || result;
          }

          return result;
        }
        /** @internal */

      }, {
        key: "_matchPartial",
        value: function _matchPartial(map, name, cssSelector, matchedCallback) {
          if (!map || typeof name !== 'string') {
            return false;
          }

          var nestedSelector = map.get(name);

          if (!nestedSelector) {
            return false;
          } // TODO(perf): get rid of recursion and measure again
          // TODO(perf): don't pass the whole selector into the recursion,
          // but only the not processed parts


          return nestedSelector.match(cssSelector, matchedCallback);
        }
      }], [{
        key: "createNotMatcher",
        value: function createNotMatcher(notSelectors) {
          var notMatcher = new SelectorMatcher();
          notMatcher.addSelectables(notSelectors, null);
          return notMatcher;
        }
      }]);

      return SelectorMatcher;
    }();

    var SelectorListContext = function SelectorListContext(selectors) {
      _classCallCheck(this, SelectorListContext);

      this.selectors = selectors;
      this.alreadyMatched = false;
    }; // Store context to pass back selector and context when a selector is matched


    var SelectorContext =
    /*#__PURE__*/
    function () {
      function SelectorContext(selector, cbContext, listContext) {
        _classCallCheck(this, SelectorContext);

        this.selector = selector;
        this.cbContext = cbContext;
        this.listContext = listContext;
        this.notSelectors = selector.notSelectors;
      }

      _createClass(SelectorContext, [{
        key: "finalize",
        value: function finalize(cssSelector, callback) {
          var result = true;

          if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
            var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
            result = !notMatcher.match(cssSelector, null);
          }

          if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
            if (this.listContext) {
              this.listContext.alreadyMatched = true;
            }

            callback(this.selector, this.cbContext);
          }

          return result;
        }
      }]);

      return SelectorContext;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var createInject = makeMetadataFactory('Inject', function (token) {
      return {
        token: token
      };
    });
    var createInjectionToken = makeMetadataFactory('InjectionToken', function (desc) {
      return {
        _desc: desc,
        ɵprov: undefined
      };
    });
    var createAttribute = makeMetadataFactory('Attribute', function (attributeName) {
      return {
        attributeName: attributeName
      };
    });
    var createContentChildren = makeMetadataFactory('ContentChildren', function (selector) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return Object.assign({
        selector: selector,
        first: false,
        isViewQuery: false,
        descendants: false
      }, data);
    });
    var createContentChild = makeMetadataFactory('ContentChild', function (selector) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return Object.assign({
        selector: selector,
        first: true,
        isViewQuery: false,
        descendants: true
      }, data);
    });
    var createViewChildren = makeMetadataFactory('ViewChildren', function (selector) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return Object.assign({
        selector: selector,
        first: false,
        isViewQuery: true,
        descendants: true
      }, data);
    });
    var createViewChild = makeMetadataFactory('ViewChild', function (selector, data) {
      return Object.assign({
        selector: selector,
        first: true,
        isViewQuery: true,
        descendants: true
      }, data);
    });
    var createDirective = makeMetadataFactory('Directive', function () {
      var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return dir;
    });
    var ViewEncapsulation;

    (function (ViewEncapsulation) {
      ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
      ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
      ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
      ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation || (ViewEncapsulation = {}));

    var ChangeDetectionStrategy;

    (function (ChangeDetectionStrategy) {
      ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
      ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
    })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));

    var createComponent = makeMetadataFactory('Component', function () {
      var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return Object.assign({
        changeDetection: ChangeDetectionStrategy.Default
      }, c);
    });
    var createPipe = makeMetadataFactory('Pipe', function (p) {
      return Object.assign({
        pure: true
      }, p);
    });
    var createInput = makeMetadataFactory('Input', function (bindingPropertyName) {
      return {
        bindingPropertyName: bindingPropertyName
      };
    });
    var createOutput = makeMetadataFactory('Output', function (bindingPropertyName) {
      return {
        bindingPropertyName: bindingPropertyName
      };
    });
    var createHostBinding = makeMetadataFactory('HostBinding', function (hostPropertyName) {
      return {
        hostPropertyName: hostPropertyName
      };
    });
    var createHostListener = makeMetadataFactory('HostListener', function (eventName, args) {
      return {
        eventName: eventName,
        args: args
      };
    });
    var createNgModule = makeMetadataFactory('NgModule', function (ngModule) {
      return ngModule;
    });
    var createInjectable = makeMetadataFactory('Injectable', function () {
      var injectable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return injectable;
    });
    var CUSTOM_ELEMENTS_SCHEMA = {
      name: 'custom-elements'
    };
    var NO_ERRORS_SCHEMA = {
      name: 'no-errors-schema'
    };
    var createOptional = makeMetadataFactory('Optional');
    var createSelf = makeMetadataFactory('Self');
    var createSkipSelf = makeMetadataFactory('SkipSelf');
    var createHost = makeMetadataFactory('Host');
    var Type = Function;
    var SecurityContext;

    (function (SecurityContext) {
      SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
      SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
      SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
      SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
      SecurityContext[SecurityContext["URL"] = 4] = "URL";
      SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(SecurityContext || (SecurityContext = {}));

    var MissingTranslationStrategy;

    (function (MissingTranslationStrategy) {
      MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
      MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
      MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
    })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));

    function makeMetadataFactory(name, props) {
      // This must be declared as a function, not a fat arrow, so that ES2015 devmode produces code
      // that works with the static_reflector.ts in the ViewEngine compiler.
      // In particular, `_registerDecoratorOrConstructor` assumes that the value returned here can be
      // new'ed.
      function factory() {
        var values = props ? props.apply(void 0, arguments) : {};
        return Object.assign({
          ngMetadataName: name
        }, values);
      }

      factory.isTypeOf = function (obj) {
        return obj && obj.ngMetadataName === name;
      };

      factory.ngMetadataName = name;
      return factory;
    }

    function parserSelectorToSimpleSelector(selector) {
      var classes = selector.classNames && selector.classNames.length ? [8
      /* CLASS */
      ].concat(_toConsumableArray(selector.classNames)) : [];
      var elementName = selector.element && selector.element !== '*' ? selector.element : '';
      return [elementName].concat(_toConsumableArray(selector.attrs), _toConsumableArray(classes));
    }

    function parserSelectorToNegativeSelector(selector) {
      var classes = selector.classNames && selector.classNames.length ? [8
      /* CLASS */
      ].concat(_toConsumableArray(selector.classNames)) : [];

      if (selector.element) {
        return [1
        /* NOT */
        | 4
        /* ELEMENT */
        , selector.element].concat(_toConsumableArray(selector.attrs), _toConsumableArray(classes));
      } else if (selector.attrs.length) {
        return [1
        /* NOT */
        | 2
        /* ATTRIBUTE */
        ].concat(_toConsumableArray(selector.attrs), _toConsumableArray(classes));
      } else {
        return selector.classNames && selector.classNames.length ? [1
        /* NOT */
        | 8
        /* CLASS */
        ].concat(_toConsumableArray(selector.classNames)) : [];
      }
    }

    function parserSelectorToR3Selector(selector) {
      var positive = parserSelectorToSimpleSelector(selector);
      var negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map(function (notSelector) {
        return parserSelectorToNegativeSelector(notSelector);
      }) : [];
      return positive.concat.apply(positive, _toConsumableArray(negative));
    }

    function parseSelectorToR3Selector(selector) {
      return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];
    }

    var core =
    /*#__PURE__*/
    Object.freeze({
      __proto__: null,
      createInject: createInject,
      createInjectionToken: createInjectionToken,
      createAttribute: createAttribute,
      createContentChildren: createContentChildren,
      createContentChild: createContentChild,
      createViewChildren: createViewChildren,
      createViewChild: createViewChild,
      createDirective: createDirective,

      get ViewEncapsulation() {
        return ViewEncapsulation;
      },

      get ChangeDetectionStrategy() {
        return ChangeDetectionStrategy;
      },

      createComponent: createComponent,
      createPipe: createPipe,
      createInput: createInput,
      createOutput: createOutput,
      createHostBinding: createHostBinding,
      createHostListener: createHostListener,
      createNgModule: createNgModule,
      createInjectable: createInjectable,
      CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,
      NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,
      createOptional: createOptional,
      createSelf: createSelf,
      createSkipSelf: createSkipSelf,
      createHost: createHost,
      Type: Type,

      get SecurityContext() {
        return SecurityContext;
      },

      get MissingTranslationStrategy() {
        return MissingTranslationStrategy;
      },

      parseSelectorToR3Selector: parseSelectorToR3Selector
    });
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    //// Types

    var TypeModifier;

    (function (TypeModifier) {
      TypeModifier[TypeModifier["Const"] = 0] = "Const";
    })(TypeModifier || (TypeModifier = {}));

    var Type$1 =
    /*#__PURE__*/
    function () {
      function Type$1() {
        var modifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _classCallCheck(this, Type$1);

        this.modifiers = modifiers;

        if (!modifiers) {
          this.modifiers = [];
        }
      }

      _createClass(Type$1, [{
        key: "hasModifier",
        value: function hasModifier(modifier) {
          return this.modifiers.indexOf(modifier) !== -1;
        }
      }]);

      return Type$1;
    }();

    var BuiltinTypeName;

    (function (BuiltinTypeName) {
      BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
      BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
      BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
      BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
      BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
      BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
      BuiltinTypeName[BuiltinTypeName["Inferred"] = 6] = "Inferred";
      BuiltinTypeName[BuiltinTypeName["None"] = 7] = "None";
    })(BuiltinTypeName || (BuiltinTypeName = {}));

    var BuiltinType =
    /*#__PURE__*/
    function (_Type$) {
      _inherits(BuiltinType, _Type$);

      function BuiltinType(name) {
        var _this2;

        var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, BuiltinType);

        _this2 = _possibleConstructorReturn(this, _getPrototypeOf(BuiltinType).call(this, modifiers));
        _this2.name = name;
        return _this2;
      }

      _createClass(BuiltinType, [{
        key: "visitType",
        value: function visitType(visitor, context) {
          return visitor.visitBuiltinType(this, context);
        }
      }]);

      return BuiltinType;
    }(Type$1);

    var ExpressionType =
    /*#__PURE__*/
    function (_Type$2) {
      _inherits(ExpressionType, _Type$2);

      function ExpressionType(value) {
        var _this3;

        var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        _classCallCheck(this, ExpressionType);

        _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ExpressionType).call(this, modifiers));
        _this3.value = value;
        _this3.typeParams = typeParams;
        return _this3;
      }

      _createClass(ExpressionType, [{
        key: "visitType",
        value: function visitType(visitor, context) {
          return visitor.visitExpressionType(this, context);
        }
      }]);

      return ExpressionType;
    }(Type$1);

    var ArrayType =
    /*#__PURE__*/
    function (_Type$3) {
      _inherits(ArrayType, _Type$3);

      function ArrayType(of) {
        var _this4;

        var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, ArrayType);

        _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ArrayType).call(this, modifiers));
        _this4.of = of;
        return _this4;
      }

      _createClass(ArrayType, [{
        key: "visitType",
        value: function visitType(visitor, context) {
          return visitor.visitArrayType(this, context);
        }
      }]);

      return ArrayType;
    }(Type$1);

    var MapType =
    /*#__PURE__*/
    function (_Type$4) {
      _inherits(MapType, _Type$4);

      function MapType(valueType) {
        var _this5;

        var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, MapType);

        _this5 = _possibleConstructorReturn(this, _getPrototypeOf(MapType).call(this, modifiers));
        _this5.valueType = valueType || null;
        return _this5;
      }

      _createClass(MapType, [{
        key: "visitType",
        value: function visitType(visitor, context) {
          return visitor.visitMapType(this, context);
        }
      }]);

      return MapType;
    }(Type$1);

    var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
    var INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
    var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
    var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
    var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
    var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
    var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
    var NONE_TYPE = new BuiltinType(BuiltinTypeName.None); ///// Expressions

    var BinaryOperator;

    (function (BinaryOperator) {
      BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
      BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
      BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
      BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
      BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
      BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
      BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
      BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
      BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
      BinaryOperator[BinaryOperator["And"] = 9] = "And";
      BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
      BinaryOperator[BinaryOperator["BitwiseAnd"] = 11] = "BitwiseAnd";
      BinaryOperator[BinaryOperator["Lower"] = 12] = "Lower";
      BinaryOperator[BinaryOperator["LowerEquals"] = 13] = "LowerEquals";
      BinaryOperator[BinaryOperator["Bigger"] = 14] = "Bigger";
      BinaryOperator[BinaryOperator["BiggerEquals"] = 15] = "BiggerEquals";
    })(BinaryOperator || (BinaryOperator = {}));

    function nullSafeIsEquivalent(base, other) {
      if (base == null || other == null) {
        return base == other;
      }

      return base.isEquivalent(other);
    }

    function areAllEquivalent(base, other) {
      var len = base.length;

      if (len !== other.length) {
        return false;
      }

      for (var i = 0; i < len; i++) {
        if (!base[i].isEquivalent(other[i])) {
          return false;
        }
      }

      return true;
    }

    var Expression =
    /*#__PURE__*/
    function () {
      function Expression(type, sourceSpan) {
        _classCallCheck(this, Expression);

        this.type = type || null;
        this.sourceSpan = sourceSpan || null;
      }

      _createClass(Expression, [{
        key: "prop",
        value: function prop(name, sourceSpan) {
          return new ReadPropExpr(this, name, null, sourceSpan);
        }
      }, {
        key: "key",
        value: function key(index, type, sourceSpan) {
          return new ReadKeyExpr(this, index, type, sourceSpan);
        }
      }, {
        key: "callMethod",
        value: function callMethod(name, params, sourceSpan) {
          return new InvokeMethodExpr(this, name, params, null, sourceSpan);
        }
      }, {
        key: "callFn",
        value: function callFn(params, sourceSpan) {
          return new InvokeFunctionExpr(this, params, null, sourceSpan);
        }
      }, {
        key: "instantiate",
        value: function instantiate(params, type, sourceSpan) {
          return new InstantiateExpr(this, params, type, sourceSpan);
        }
      }, {
        key: "conditional",
        value: function conditional(trueCase) {
          var falseCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;
          return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
        }
      }, {
        key: "equals",
        value: function equals(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
        }
      }, {
        key: "notEquals",
        value: function notEquals(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
        }
      }, {
        key: "identical",
        value: function identical(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
        }
      }, {
        key: "notIdentical",
        value: function notIdentical(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
        }
      }, {
        key: "minus",
        value: function minus(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
        }
      }, {
        key: "plus",
        value: function plus(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
        }
      }, {
        key: "divide",
        value: function divide(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
        }
      }, {
        key: "multiply",
        value: function multiply(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
        }
      }, {
        key: "modulo",
        value: function modulo(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
        }
      }, {
        key: "and",
        value: function and(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
        }
      }, {
        key: "bitwiseAnd",
        value: function bitwiseAnd(rhs, sourceSpan) {
          var parens = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);
        }
      }, {
        key: "or",
        value: function or(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
        }
      }, {
        key: "lower",
        value: function lower(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
        }
      }, {
        key: "lowerEquals",
        value: function lowerEquals(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
        }
      }, {
        key: "bigger",
        value: function bigger(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
        }
      }, {
        key: "biggerEquals",
        value: function biggerEquals(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
        }
      }, {
        key: "isBlank",
        value: function isBlank(sourceSpan) {
          // Note: We use equals by purpose here to compare to null and undefined in JS.
          // We use the typed null to allow strictNullChecks to narrow types.
          return this.equals(TYPED_NULL_EXPR, sourceSpan);
        }
      }, {
        key: "cast",
        value: function cast(type, sourceSpan) {
          return new CastExpr(this, type, sourceSpan);
        }
      }, {
        key: "toStmt",
        value: function toStmt() {
          return new ExpressionStatement(this, null);
        }
      }]);

      return Expression;
    }();

    var BuiltinVar;

    (function (BuiltinVar) {
      BuiltinVar[BuiltinVar["This"] = 0] = "This";
      BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
      BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
      BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
    })(BuiltinVar || (BuiltinVar = {}));

    var ReadVarExpr =
    /*#__PURE__*/
    function (_Expression) {
      _inherits(ReadVarExpr, _Expression);

      function ReadVarExpr(name, type, sourceSpan) {
        var _this6;

        _classCallCheck(this, ReadVarExpr);

        _this6 = _possibleConstructorReturn(this, _getPrototypeOf(ReadVarExpr).call(this, type, sourceSpan));

        if (typeof name === 'string') {
          _this6.name = name;
          _this6.builtin = null;
        } else {
          _this6.name = null;
          _this6.builtin = name;
        }

        return _this6;
      }

      _createClass(ReadVarExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitReadVarExpr(this, context);
        }
      }, {
        key: "set",
        value: function set(value) {
          if (!this.name) {
            throw new Error("Built in variable ".concat(this.builtin, " can not be assigned to."));
          }

          return new WriteVarExpr(this.name, value, null, this.sourceSpan);
        }
      }]);

      return ReadVarExpr;
    }(Expression);

    var TypeofExpr =
    /*#__PURE__*/
    function (_Expression2) {
      _inherits(TypeofExpr, _Expression2);

      function TypeofExpr(expr, type, sourceSpan) {
        var _this7;

        _classCallCheck(this, TypeofExpr);

        _this7 = _possibleConstructorReturn(this, _getPrototypeOf(TypeofExpr).call(this, type, sourceSpan));
        _this7.expr = expr;
        return _this7;
      }

      _createClass(TypeofExpr, [{
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitTypeofExpr(this, context);
        }
      }, {
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return this.expr.isConstant();
        }
      }]);

      return TypeofExpr;
    }(Expression);

    var WrappedNodeExpr =
    /*#__PURE__*/
    function (_Expression3) {
      _inherits(WrappedNodeExpr, _Expression3);

      function WrappedNodeExpr(node, type, sourceSpan) {
        var _this8;

        _classCallCheck(this, WrappedNodeExpr);

        _this8 = _possibleConstructorReturn(this, _getPrototypeOf(WrappedNodeExpr).call(this, type, sourceSpan));
        _this8.node = node;
        return _this8;
      }

      _createClass(WrappedNodeExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof WrappedNodeExpr && this.node === e.node;
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitWrappedNodeExpr(this, context);
        }
      }]);

      return WrappedNodeExpr;
    }(Expression);

    var WriteVarExpr =
    /*#__PURE__*/
    function (_Expression4) {
      _inherits(WriteVarExpr, _Expression4);

      function WriteVarExpr(name, value, type, sourceSpan) {
        var _this9;

        _classCallCheck(this, WriteVarExpr);

        _this9 = _possibleConstructorReturn(this, _getPrototypeOf(WriteVarExpr).call(this, type || value.type, sourceSpan));
        _this9.name = name;
        _this9.value = value;
        return _this9;
      }

      _createClass(WriteVarExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitWriteVarExpr(this, context);
        }
      }, {
        key: "toDeclStmt",
        value: function toDeclStmt(type, modifiers) {
          return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
        }
      }, {
        key: "toConstDecl",
        value: function toConstDecl() {
          return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);
        }
      }]);

      return WriteVarExpr;
    }(Expression);

    var WriteKeyExpr =
    /*#__PURE__*/
    function (_Expression5) {
      _inherits(WriteKeyExpr, _Expression5);

      function WriteKeyExpr(receiver, index, value, type, sourceSpan) {
        var _this10;

        _classCallCheck(this, WriteKeyExpr);

        _this10 = _possibleConstructorReturn(this, _getPrototypeOf(WriteKeyExpr).call(this, type || value.type, sourceSpan));
        _this10.receiver = receiver;
        _this10.index = index;
        _this10.value = value;
        return _this10;
      }

      _createClass(WriteKeyExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitWriteKeyExpr(this, context);
        }
      }]);

      return WriteKeyExpr;
    }(Expression);

    var WritePropExpr =
    /*#__PURE__*/
    function (_Expression6) {
      _inherits(WritePropExpr, _Expression6);

      function WritePropExpr(receiver, name, value, type, sourceSpan) {
        var _this11;

        _classCallCheck(this, WritePropExpr);

        _this11 = _possibleConstructorReturn(this, _getPrototypeOf(WritePropExpr).call(this, type || value.type, sourceSpan));
        _this11.receiver = receiver;
        _this11.name = name;
        _this11.value = value;
        return _this11;
      }

      _createClass(WritePropExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitWritePropExpr(this, context);
        }
      }]);

      return WritePropExpr;
    }(Expression);

    var BuiltinMethod;

    (function (BuiltinMethod) {
      BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
      BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
      BuiltinMethod[BuiltinMethod["Bind"] = 2] = "Bind";
    })(BuiltinMethod || (BuiltinMethod = {}));

    var InvokeMethodExpr =
    /*#__PURE__*/
    function (_Expression7) {
      _inherits(InvokeMethodExpr, _Expression7);

      function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {
        var _this12;

        _classCallCheck(this, InvokeMethodExpr);

        _this12 = _possibleConstructorReturn(this, _getPrototypeOf(InvokeMethodExpr).call(this, type, sourceSpan));
        _this12.receiver = receiver;
        _this12.args = args;

        if (typeof method === 'string') {
          _this12.name = method;
          _this12.builtin = null;
        } else {
          _this12.name = null;
          _this12.builtin = method;
        }

        return _this12;
      }

      _createClass(InvokeMethodExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitInvokeMethodExpr(this, context);
        }
      }]);

      return InvokeMethodExpr;
    }(Expression);

    var InvokeFunctionExpr =
    /*#__PURE__*/
    function (_Expression8) {
      _inherits(InvokeFunctionExpr, _Expression8);

      function InvokeFunctionExpr(fn, args, type, sourceSpan) {
        var _this13;

        var pure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        _classCallCheck(this, InvokeFunctionExpr);

        _this13 = _possibleConstructorReturn(this, _getPrototypeOf(InvokeFunctionExpr).call(this, type, sourceSpan));
        _this13.fn = fn;
        _this13.args = args;
        _this13.pure = pure;
        return _this13;
      }

      _createClass(InvokeFunctionExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitInvokeFunctionExpr(this, context);
        }
      }]);

      return InvokeFunctionExpr;
    }(Expression);

    var InstantiateExpr =
    /*#__PURE__*/
    function (_Expression9) {
      _inherits(InstantiateExpr, _Expression9);

      function InstantiateExpr(classExpr, args, type, sourceSpan) {
        var _this14;

        _classCallCheck(this, InstantiateExpr);

        _this14 = _possibleConstructorReturn(this, _getPrototypeOf(InstantiateExpr).call(this, type, sourceSpan));
        _this14.classExpr = classExpr;
        _this14.args = args;
        return _this14;
      }

      _createClass(InstantiateExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitInstantiateExpr(this, context);
        }
      }]);

      return InstantiateExpr;
    }(Expression);

    var LiteralExpr =
    /*#__PURE__*/
    function (_Expression10) {
      _inherits(LiteralExpr, _Expression10);

      function LiteralExpr(value, type, sourceSpan) {
        var _this15;

        _classCallCheck(this, LiteralExpr);

        _this15 = _possibleConstructorReturn(this, _getPrototypeOf(LiteralExpr).call(this, type, sourceSpan));
        _this15.value = value;
        return _this15;
      }

      _createClass(LiteralExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof LiteralExpr && this.value === e.value;
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return true;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitLiteralExpr(this, context);
        }
      }]);

      return LiteralExpr;
    }(Expression);

    var LocalizedString =
    /*#__PURE__*/
    function (_Expression11) {
      _inherits(LocalizedString, _Expression11);

      function LocalizedString(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {
        var _this16;

        _classCallCheck(this, LocalizedString);

        _this16 = _possibleConstructorReturn(this, _getPrototypeOf(LocalizedString).call(this, STRING_TYPE, sourceSpan));
        _this16.metaBlock = metaBlock;
        _this16.messageParts = messageParts;
        _this16.placeHolderNames = placeHolderNames;
        _this16.expressions = expressions;
        return _this16;
      }

      _createClass(LocalizedString, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          // return e instanceof LocalizedString && this.message === e.message;
          return false;
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitLocalizedString(this, context);
        }
        /**
         * Serialize the given `meta` and `messagePart` into "cooked" and "raw" strings that can be used
         * in a `$localize` tagged string. The format of the metadata is the same as that parsed by
         * `parseI18nMeta()`.
         *
         * @param meta The metadata to serialize
         * @param messagePart The first part of the tagged string
         */

      }, {
        key: "serializeI18nHead",
        value: function serializeI18nHead() {
          var MEANING_SEPARATOR = '|';
          var ID_SEPARATOR = '@@';
          var LEGACY_ID_INDICATOR = '␟';
          var metaBlock = this.metaBlock.description || '';

          if (this.metaBlock.meaning) {
            metaBlock = "".concat(this.metaBlock.meaning).concat(MEANING_SEPARATOR).concat(metaBlock);
          }

          if (this.metaBlock.customId) {
            metaBlock = "".concat(metaBlock).concat(ID_SEPARATOR).concat(this.metaBlock.customId);
          }

          if (this.metaBlock.legacyIds) {
            this.metaBlock.legacyIds.forEach(function (legacyId) {
              metaBlock = "".concat(metaBlock).concat(LEGACY_ID_INDICATOR).concat(legacyId);
            });
          }

          return createCookedRawString(metaBlock, this.messageParts[0]);
        }
        /**
         * Serialize the given `placeholderName` and `messagePart` into "cooked" and "raw" strings that
         * can be used in a `$localize` tagged string.
         *
         * @param placeholderName The placeholder name to serialize
         * @param messagePart The following message string after this placeholder
         */

      }, {
        key: "serializeI18nTemplatePart",
        value: function serializeI18nTemplatePart(partIndex) {
          var placeholderName = this.placeHolderNames[partIndex - 1];
          var messagePart = this.messageParts[partIndex];
          return createCookedRawString(placeholderName, messagePart);
        }
      }]);

      return LocalizedString;
    }(Expression);

    var escapeSlashes = function escapeSlashes(str) {
      return str.replace(/\\/g, '\\\\');
    };

    var escapeStartingColon = function escapeStartingColon(str) {
      return str.replace(/^:/, '\\:');
    };

    var escapeColons = function escapeColons(str) {
      return str.replace(/:/g, '\\:');
    };

    var escapeForMessagePart = function escapeForMessagePart(str) {
      return str.replace(/`/g, '\\`').replace(/\${/g, '$\\{');
    };
    /**
     * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.
     *
     * The `raw` text must have various character sequences escaped:
     * * "\" would otherwise indicate that the next character is a control character.
     * * "`" and "${" are template string control sequences that would otherwise prematurely indicate
     *   the end of a message part.
     * * ":" inside a metablock would prematurely indicate the end of the metablock.
     * * ":" at the start of a messagePart with no metablock would erroneously indicate the start of a
     *   metablock.
     *
     * @param metaBlock Any metadata that should be prepended to the string
     * @param messagePart The message part of the string
     */


    function createCookedRawString(metaBlock, messagePart) {
      if (metaBlock === '') {
        return {
          cooked: messagePart,
          raw: escapeForMessagePart(escapeStartingColon(escapeSlashes(messagePart)))
        };
      } else {
        return {
          cooked: ":".concat(metaBlock, ":").concat(messagePart),
          raw: escapeForMessagePart(":".concat(escapeColons(escapeSlashes(metaBlock)), ":").concat(escapeSlashes(messagePart)))
        };
      }
    }

    var ExternalExpr =
    /*#__PURE__*/
    function (_Expression12) {
      _inherits(ExternalExpr, _Expression12);

      function ExternalExpr(value, type) {
        var _this17;

        var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var sourceSpan = arguments.length > 3 ? arguments[3] : undefined;

        _classCallCheck(this, ExternalExpr);

        _this17 = _possibleConstructorReturn(this, _getPrototypeOf(ExternalExpr).call(this, type, sourceSpan));
        _this17.value = value;
        _this17.typeParams = typeParams;
        return _this17;
      }

      _createClass(ExternalExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitExternalExpr(this, context);
        }
      }]);

      return ExternalExpr;
    }(Expression);

    var ExternalReference = function ExternalReference(moduleName, name, runtime) {
      _classCallCheck(this, ExternalReference);

      this.moduleName = moduleName;
      this.name = name;
      this.runtime = runtime;
    };

    var ConditionalExpr =
    /*#__PURE__*/
    function (_Expression13) {
      _inherits(ConditionalExpr, _Expression13);

      function ConditionalExpr(condition, trueCase) {
        var _this18;

        var falseCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var type = arguments.length > 3 ? arguments[3] : undefined;
        var sourceSpan = arguments.length > 4 ? arguments[4] : undefined;

        _classCallCheck(this, ConditionalExpr);

        _this18 = _possibleConstructorReturn(this, _getPrototypeOf(ConditionalExpr).call(this, type || trueCase.type, sourceSpan));
        _this18.condition = condition;
        _this18.falseCase = falseCase;
        _this18.trueCase = trueCase;
        return _this18;
      }

      _createClass(ConditionalExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitConditionalExpr(this, context);
        }
      }]);

      return ConditionalExpr;
    }(Expression);

    var NotExpr =
    /*#__PURE__*/
    function (_Expression14) {
      _inherits(NotExpr, _Expression14);

      function NotExpr(condition, sourceSpan) {
        var _this19;

        _classCallCheck(this, NotExpr);

        _this19 = _possibleConstructorReturn(this, _getPrototypeOf(NotExpr).call(this, BOOL_TYPE, sourceSpan));
        _this19.condition = condition;
        return _this19;
      }

      _createClass(NotExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof NotExpr && this.condition.isEquivalent(e.condition);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitNotExpr(this, context);
        }
      }]);

      return NotExpr;
    }(Expression);

    var AssertNotNull =
    /*#__PURE__*/
    function (_Expression15) {
      _inherits(AssertNotNull, _Expression15);

      function AssertNotNull(condition, sourceSpan) {
        var _this20;

        _classCallCheck(this, AssertNotNull);

        _this20 = _possibleConstructorReturn(this, _getPrototypeOf(AssertNotNull).call(this, condition.type, sourceSpan));
        _this20.condition = condition;
        return _this20;
      }

      _createClass(AssertNotNull, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitAssertNotNullExpr(this, context);
        }
      }]);

      return AssertNotNull;
    }(Expression);

    var CastExpr =
    /*#__PURE__*/
    function (_Expression16) {
      _inherits(CastExpr, _Expression16);

      function CastExpr(value, type, sourceSpan) {
        var _this21;

        _classCallCheck(this, CastExpr);

        _this21 = _possibleConstructorReturn(this, _getPrototypeOf(CastExpr).call(this, type, sourceSpan));
        _this21.value = value;
        return _this21;
      }

      _createClass(CastExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof CastExpr && this.value.isEquivalent(e.value);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitCastExpr(this, context);
        }
      }]);

      return CastExpr;
    }(Expression);

    var FnParam =
    /*#__PURE__*/
    function () {
      function FnParam(name) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, FnParam);

        this.name = name;
        this.type = type;
      }

      _createClass(FnParam, [{
        key: "isEquivalent",
        value: function isEquivalent(param) {
          return this.name === param.name;
        }
      }]);

      return FnParam;
    }();

    var FunctionExpr =
    /*#__PURE__*/
    function (_Expression17) {
      _inherits(FunctionExpr, _Expression17);

      function FunctionExpr(params, statements, type, sourceSpan, name) {
        var _this22;

        _classCallCheck(this, FunctionExpr);

        _this22 = _possibleConstructorReturn(this, _getPrototypeOf(FunctionExpr).call(this, type, sourceSpan));
        _this22.params = params;
        _this22.statements = statements;
        _this22.name = name;
        return _this22;
      }

      _createClass(FunctionExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitFunctionExpr(this, context);
        }
      }, {
        key: "toDeclStmt",
        value: function toDeclStmt(name) {
          var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
        }
      }]);

      return FunctionExpr;
    }(Expression);

    var BinaryOperatorExpr =
    /*#__PURE__*/
    function (_Expression18) {
      _inherits(BinaryOperatorExpr, _Expression18);

      function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan) {
        var _this23;

        var parens = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

        _classCallCheck(this, BinaryOperatorExpr);

        _this23 = _possibleConstructorReturn(this, _getPrototypeOf(BinaryOperatorExpr).call(this, type || lhs.type, sourceSpan));
        _this23.operator = operator;
        _this23.rhs = rhs;
        _this23.parens = parens;
        _this23.lhs = lhs;
        return _this23;
      }

      _createClass(BinaryOperatorExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitBinaryOperatorExpr(this, context);
        }
      }]);

      return BinaryOperatorExpr;
    }(Expression);

    var ReadPropExpr =
    /*#__PURE__*/
    function (_Expression19) {
      _inherits(ReadPropExpr, _Expression19);

      function ReadPropExpr(receiver, name, type, sourceSpan) {
        var _this24;

        _classCallCheck(this, ReadPropExpr);

        _this24 = _possibleConstructorReturn(this, _getPrototypeOf(ReadPropExpr).call(this, type, sourceSpan));
        _this24.receiver = receiver;
        _this24.name = name;
        return _this24;
      }

      _createClass(ReadPropExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitReadPropExpr(this, context);
        }
      }, {
        key: "set",
        value: function set(value) {
          return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
        }
      }]);

      return ReadPropExpr;
    }(Expression);

    var ReadKeyExpr =
    /*#__PURE__*/
    function (_Expression20) {
      _inherits(ReadKeyExpr, _Expression20);

      function ReadKeyExpr(receiver, index, type, sourceSpan) {
        var _this25;

        _classCallCheck(this, ReadKeyExpr);

        _this25 = _possibleConstructorReturn(this, _getPrototypeOf(ReadKeyExpr).call(this, type, sourceSpan));
        _this25.receiver = receiver;
        _this25.index = index;
        return _this25;
      }

      _createClass(ReadKeyExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitReadKeyExpr(this, context);
        }
      }, {
        key: "set",
        value: function set(value) {
          return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
        }
      }]);

      return ReadKeyExpr;
    }(Expression);

    var LiteralArrayExpr =
    /*#__PURE__*/
    function (_Expression21) {
      _inherits(LiteralArrayExpr, _Expression21);

      function LiteralArrayExpr(entries, type, sourceSpan) {
        var _this26;

        _classCallCheck(this, LiteralArrayExpr);

        _this26 = _possibleConstructorReturn(this, _getPrototypeOf(LiteralArrayExpr).call(this, type, sourceSpan));
        _this26.entries = entries;
        return _this26;
      }

      _createClass(LiteralArrayExpr, [{
        key: "isConstant",
        value: function isConstant() {
          return this.entries.every(function (e) {
            return e.isConstant();
          });
        }
      }, {
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitLiteralArrayExpr(this, context);
        }
      }]);

      return LiteralArrayExpr;
    }(Expression);

    var LiteralMapEntry =
    /*#__PURE__*/
    function () {
      function LiteralMapEntry(key, value, quoted) {
        _classCallCheck(this, LiteralMapEntry);

        this.key = key;
        this.value = value;
        this.quoted = quoted;
      }

      _createClass(LiteralMapEntry, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return this.key === e.key && this.value.isEquivalent(e.value);
        }
      }]);

      return LiteralMapEntry;
    }();

    var LiteralMapExpr =
    /*#__PURE__*/
    function (_Expression22) {
      _inherits(LiteralMapExpr, _Expression22);

      function LiteralMapExpr(entries, type, sourceSpan) {
        var _this27;

        _classCallCheck(this, LiteralMapExpr);

        _this27 = _possibleConstructorReturn(this, _getPrototypeOf(LiteralMapExpr).call(this, type, sourceSpan));
        _this27.entries = entries;
        _this27.valueType = null;

        if (type) {
          _this27.valueType = type.valueType;
        }

        return _this27;
      }

      _createClass(LiteralMapExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return this.entries.every(function (e) {
            return e.value.isConstant();
          });
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitLiteralMapExpr(this, context);
        }
      }]);

      return LiteralMapExpr;
    }(Expression);

    var CommaExpr =
    /*#__PURE__*/
    function (_Expression23) {
      _inherits(CommaExpr, _Expression23);

      function CommaExpr(parts, sourceSpan) {
        var _this28;

        _classCallCheck(this, CommaExpr);

        _this28 = _possibleConstructorReturn(this, _getPrototypeOf(CommaExpr).call(this, parts[parts.length - 1].type, sourceSpan));
        _this28.parts = parts;
        return _this28;
      }

      _createClass(CommaExpr, [{
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return false;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          return visitor.visitCommaExpr(this, context);
        }
      }]);

      return CommaExpr;
    }(Expression);

    var THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);
    var SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);
    var CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);
    var CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);
    var NULL_EXPR = new LiteralExpr(null, null, null);
    var TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null); //// Statements

    var StmtModifier;

    (function (StmtModifier) {
      StmtModifier[StmtModifier["Final"] = 0] = "Final";
      StmtModifier[StmtModifier["Private"] = 1] = "Private";
      StmtModifier[StmtModifier["Exported"] = 2] = "Exported";
      StmtModifier[StmtModifier["Static"] = 3] = "Static";
    })(StmtModifier || (StmtModifier = {}));

    var Statement =
    /*#__PURE__*/
    function () {
      function Statement(modifiers, sourceSpan) {
        _classCallCheck(this, Statement);

        this.modifiers = modifiers || [];
        this.sourceSpan = sourceSpan || null;
      }

      _createClass(Statement, [{
        key: "hasModifier",
        value: function hasModifier(modifier) {
          return this.modifiers.indexOf(modifier) !== -1;
        }
      }]);

      return Statement;
    }();

    var DeclareVarStmt =
    /*#__PURE__*/
    function (_Statement) {
      _inherits(DeclareVarStmt, _Statement);

      function DeclareVarStmt(name, value, type) {
        var _this29;

        var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var sourceSpan = arguments.length > 4 ? arguments[4] : undefined;

        _classCallCheck(this, DeclareVarStmt);

        _this29 = _possibleConstructorReturn(this, _getPrototypeOf(DeclareVarStmt).call(this, modifiers, sourceSpan));
        _this29.name = name;
        _this29.value = value;
        _this29.type = type || value && value.type || null;
        return _this29;
      }

      _createClass(DeclareVarStmt, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitDeclareVarStmt(this, context);
        }
      }]);

      return DeclareVarStmt;
    }(Statement);

    var DeclareFunctionStmt =
    /*#__PURE__*/
    function (_Statement2) {
      _inherits(DeclareFunctionStmt, _Statement2);

      function DeclareFunctionStmt(name, params, statements, type) {
        var _this30;

        var modifiers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var sourceSpan = arguments.length > 5 ? arguments[5] : undefined;

        _classCallCheck(this, DeclareFunctionStmt);

        _this30 = _possibleConstructorReturn(this, _getPrototypeOf(DeclareFunctionStmt).call(this, modifiers, sourceSpan));
        _this30.name = name;
        _this30.params = params;
        _this30.statements = statements;
        _this30.type = type || null;
        return _this30;
      }

      _createClass(DeclareFunctionStmt, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitDeclareFunctionStmt(this, context);
        }
      }]);

      return DeclareFunctionStmt;
    }(Statement);

    var ExpressionStatement =
    /*#__PURE__*/
    function (_Statement3) {
      _inherits(ExpressionStatement, _Statement3);

      function ExpressionStatement(expr, sourceSpan) {
        var _this31;

        _classCallCheck(this, ExpressionStatement);

        _this31 = _possibleConstructorReturn(this, _getPrototypeOf(ExpressionStatement).call(this, null, sourceSpan));
        _this31.expr = expr;
        return _this31;
      }

      _createClass(ExpressionStatement, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitExpressionStmt(this, context);
        }
      }]);

      return ExpressionStatement;
    }(Statement);

    var ReturnStatement =
    /*#__PURE__*/
    function (_Statement4) {
      _inherits(ReturnStatement, _Statement4);

      function ReturnStatement(value, sourceSpan) {
        var _this32;

        _classCallCheck(this, ReturnStatement);

        _this32 = _possibleConstructorReturn(this, _getPrototypeOf(ReturnStatement).call(this, null, sourceSpan));
        _this32.value = value;
        return _this32;
      }

      _createClass(ReturnStatement, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitReturnStmt(this, context);
        }
      }]);

      return ReturnStatement;
    }(Statement);

    var AbstractClassPart =
    /*#__PURE__*/
    function () {
      function AbstractClassPart(type, modifiers) {
        _classCallCheck(this, AbstractClassPart);

        this.modifiers = modifiers;

        if (!modifiers) {
          this.modifiers = [];
        }

        this.type = type || null;
      }

      _createClass(AbstractClassPart, [{
        key: "hasModifier",
        value: function hasModifier(modifier) {
          return this.modifiers.indexOf(modifier) !== -1;
        }
      }]);

      return AbstractClassPart;
    }();

    var ClassField =
    /*#__PURE__*/
    function (_AbstractClassPart) {
      _inherits(ClassField, _AbstractClassPart);

      function ClassField(name, type) {
        var _this33;

        var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var initializer = arguments.length > 3 ? arguments[3] : undefined;

        _classCallCheck(this, ClassField);

        _this33 = _possibleConstructorReturn(this, _getPrototypeOf(ClassField).call(this, type, modifiers));
        _this33.name = name;
        _this33.initializer = initializer;
        return _this33;
      }

      _createClass(ClassField, [{
        key: "isEquivalent",
        value: function isEquivalent(f) {
          return this.name === f.name;
        }
      }]);

      return ClassField;
    }(AbstractClassPart);

    var ClassMethod =
    /*#__PURE__*/
    function (_AbstractClassPart2) {
      _inherits(ClassMethod, _AbstractClassPart2);

      function ClassMethod(name, params, body, type) {
        var _this34;

        var modifiers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

        _classCallCheck(this, ClassMethod);

        _this34 = _possibleConstructorReturn(this, _getPrototypeOf(ClassMethod).call(this, type, modifiers));
        _this34.name = name;
        _this34.params = params;
        _this34.body = body;
        return _this34;
      }

      _createClass(ClassMethod, [{
        key: "isEquivalent",
        value: function isEquivalent(m) {
          return this.name === m.name && areAllEquivalent(this.body, m.body);
        }
      }]);

      return ClassMethod;
    }(AbstractClassPart);

    var ClassGetter =
    /*#__PURE__*/
    function (_AbstractClassPart3) {
      _inherits(ClassGetter, _AbstractClassPart3);

      function ClassGetter(name, body, type) {
        var _this35;

        var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        _classCallCheck(this, ClassGetter);

        _this35 = _possibleConstructorReturn(this, _getPrototypeOf(ClassGetter).call(this, type, modifiers));
        _this35.name = name;
        _this35.body = body;
        return _this35;
      }

      _createClass(ClassGetter, [{
        key: "isEquivalent",
        value: function isEquivalent(m) {
          return this.name === m.name && areAllEquivalent(this.body, m.body);
        }
      }]);

      return ClassGetter;
    }(AbstractClassPart);

    var ClassStmt =
    /*#__PURE__*/
    function (_Statement5) {
      _inherits(ClassStmt, _Statement5);

      function ClassStmt(name, parent, fields, getters, constructorMethod, methods) {
        var _this36;

        var modifiers = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
        var sourceSpan = arguments.length > 7 ? arguments[7] : undefined;

        _classCallCheck(this, ClassStmt);

        _this36 = _possibleConstructorReturn(this, _getPrototypeOf(ClassStmt).call(this, modifiers, sourceSpan));
        _this36.name = name;
        _this36.parent = parent;
        _this36.fields = fields;
        _this36.getters = getters;
        _this36.constructorMethod = constructorMethod;
        _this36.methods = methods;
        return _this36;
      }

      _createClass(ClassStmt, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof ClassStmt && this.name === stmt.name && nullSafeIsEquivalent(this.parent, stmt.parent) && areAllEquivalent(this.fields, stmt.fields) && areAllEquivalent(this.getters, stmt.getters) && this.constructorMethod.isEquivalent(stmt.constructorMethod) && areAllEquivalent(this.methods, stmt.methods);
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitDeclareClassStmt(this, context);
        }
      }]);

      return ClassStmt;
    }(Statement);

    var IfStmt =
    /*#__PURE__*/
    function (_Statement6) {
      _inherits(IfStmt, _Statement6);

      function IfStmt(condition, trueCase) {
        var _this37;

        var falseCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var sourceSpan = arguments.length > 3 ? arguments[3] : undefined;

        _classCallCheck(this, IfStmt);

        _this37 = _possibleConstructorReturn(this, _getPrototypeOf(IfStmt).call(this, null, sourceSpan));
        _this37.condition = condition;
        _this37.trueCase = trueCase;
        _this37.falseCase = falseCase;
        return _this37;
      }

      _createClass(IfStmt, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitIfStmt(this, context);
        }
      }]);

      return IfStmt;
    }(Statement);

    var CommentStmt =
    /*#__PURE__*/
    function (_Statement7) {
      _inherits(CommentStmt, _Statement7);

      function CommentStmt(comment) {
        var _this38;

        var multiline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;

        _classCallCheck(this, CommentStmt);

        _this38 = _possibleConstructorReturn(this, _getPrototypeOf(CommentStmt).call(this, null, sourceSpan));
        _this38.comment = comment;
        _this38.multiline = multiline;
        return _this38;
      }

      _createClass(CommentStmt, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof CommentStmt;
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitCommentStmt(this, context);
        }
      }]);

      return CommentStmt;
    }(Statement);

    var JSDocCommentStmt =
    /*#__PURE__*/
    function (_Statement8) {
      _inherits(JSDocCommentStmt, _Statement8);

      function JSDocCommentStmt() {
        var _this39;

        var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var sourceSpan = arguments.length > 1 ? arguments[1] : undefined;

        _classCallCheck(this, JSDocCommentStmt);

        _this39 = _possibleConstructorReturn(this, _getPrototypeOf(JSDocCommentStmt).call(this, null, sourceSpan));
        _this39.tags = tags;
        return _this39;
      }

      _createClass(JSDocCommentStmt, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof JSDocCommentStmt && this.toString() === stmt.toString();
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitJSDocCommentStmt(this, context);
        }
      }, {
        key: "toString",
        value: function toString() {
          return serializeTags(this.tags);
        }
      }]);

      return JSDocCommentStmt;
    }(Statement);

    var TryCatchStmt =
    /*#__PURE__*/
    function (_Statement9) {
      _inherits(TryCatchStmt, _Statement9);

      function TryCatchStmt(bodyStmts, catchStmts, sourceSpan) {
        var _this40;

        _classCallCheck(this, TryCatchStmt);

        _this40 = _possibleConstructorReturn(this, _getPrototypeOf(TryCatchStmt).call(this, null, sourceSpan));
        _this40.bodyStmts = bodyStmts;
        _this40.catchStmts = catchStmts;
        return _this40;
      }

      _createClass(TryCatchStmt, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) && areAllEquivalent(this.catchStmts, stmt.catchStmts);
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitTryCatchStmt(this, context);
        }
      }]);

      return TryCatchStmt;
    }(Statement);

    var ThrowStmt =
    /*#__PURE__*/
    function (_Statement10) {
      _inherits(ThrowStmt, _Statement10);

      function ThrowStmt(error, sourceSpan) {
        var _this41;

        _classCallCheck(this, ThrowStmt);

        _this41 = _possibleConstructorReturn(this, _getPrototypeOf(ThrowStmt).call(this, null, sourceSpan));
        _this41.error = error;
        return _this41;
      }

      _createClass(ThrowStmt, [{
        key: "isEquivalent",
        value: function isEquivalent(stmt) {
          return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);
        }
      }, {
        key: "visitStatement",
        value: function visitStatement(visitor, context) {
          return visitor.visitThrowStmt(this, context);
        }
      }]);

      return ThrowStmt;
    }(Statement);

    var AstTransformer =
    /*#__PURE__*/
    function () {
      function AstTransformer() {
        _classCallCheck(this, AstTransformer);
      }

      _createClass(AstTransformer, [{
        key: "transformExpr",
        value: function transformExpr(expr, context) {
          return expr;
        }
      }, {
        key: "transformStmt",
        value: function transformStmt(stmt, context) {
          return stmt;
        }
      }, {
        key: "visitReadVarExpr",
        value: function visitReadVarExpr(ast, context) {
          return this.transformExpr(ast, context);
        }
      }, {
        key: "visitWrappedNodeExpr",
        value: function visitWrappedNodeExpr(ast, context) {
          return this.transformExpr(ast, context);
        }
      }, {
        key: "visitTypeofExpr",
        value: function visitTypeofExpr(expr, context) {
          return this.transformExpr(new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan), context);
        }
      }, {
        key: "visitWriteVarExpr",
        value: function visitWriteVarExpr(expr, context) {
          return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);
        }
      }, {
        key: "visitWriteKeyExpr",
        value: function visitWriteKeyExpr(expr, context) {
          return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);
        }
      }, {
        key: "visitWritePropExpr",
        value: function visitWritePropExpr(expr, context) {
          return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);
        }
      }, {
        key: "visitInvokeMethodExpr",
        value: function visitInvokeMethodExpr(ast, context) {
          var method = ast.builtin || ast.name;
          return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitInvokeFunctionExpr",
        value: function visitInvokeFunctionExpr(ast, context) {
          return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitInstantiateExpr",
        value: function visitInstantiateExpr(ast, context) {
          return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitLiteralExpr",
        value: function visitLiteralExpr(ast, context) {
          return this.transformExpr(ast, context);
        }
      }, {
        key: "visitLocalizedString",
        value: function visitLocalizedString(ast, context) {
          return this.transformExpr(new LocalizedString(ast.metaBlock, ast.messageParts, ast.placeHolderNames, this.visitAllExpressions(ast.expressions, context), ast.sourceSpan), context);
        }
      }, {
        key: "visitExternalExpr",
        value: function visitExternalExpr(ast, context) {
          return this.transformExpr(ast, context);
        }
      }, {
        key: "visitConditionalExpr",
        value: function visitConditionalExpr(ast, context) {
          return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitNotExpr",
        value: function visitNotExpr(ast, context) {
          return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);
        }
      }, {
        key: "visitAssertNotNullExpr",
        value: function visitAssertNotNullExpr(ast, context) {
          return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);
        }
      }, {
        key: "visitCastExpr",
        value: function visitCastExpr(ast, context) {
          return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitFunctionExpr",
        value: function visitFunctionExpr(ast, context) {
          return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitBinaryOperatorExpr",
        value: function visitBinaryOperatorExpr(ast, context) {
          return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitReadPropExpr",
        value: function visitReadPropExpr(ast, context) {
          return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitReadKeyExpr",
        value: function visitReadKeyExpr(ast, context) {
          return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitLiteralArrayExpr",
        value: function visitLiteralArrayExpr(ast, context) {
          return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);
        }
      }, {
        key: "visitLiteralMapExpr",
        value: function visitLiteralMapExpr(ast, context) {
          var _this42 = this;

          var entries = ast.entries.map(function (entry) {
            return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this42, context), entry.quoted);
          });
          var mapType = new MapType(ast.valueType, null);
          return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);
        }
      }, {
        key: "visitCommaExpr",
        value: function visitCommaExpr(ast, context) {
          return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);
        }
      }, {
        key: "visitAllExpressions",
        value: function visitAllExpressions(exprs, context) {
          var _this43 = this;

          return exprs.map(function (expr) {
            return expr.visitExpression(_this43, context);
          });
        }
      }, {
        key: "visitDeclareVarStmt",
        value: function visitDeclareVarStmt(stmt, context) {
          var value = stmt.value && stmt.value.visitExpression(this, context);
          return this.transformStmt(new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan), context);
        }
      }, {
        key: "visitDeclareFunctionStmt",
        value: function visitDeclareFunctionStmt(stmt, context) {
          return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);
        }
      }, {
        key: "visitExpressionStmt",
        value: function visitExpressionStmt(stmt, context) {
          return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);
        }
      }, {
        key: "visitReturnStmt",
        value: function visitReturnStmt(stmt, context) {
          return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);
        }
      }, {
        key: "visitDeclareClassStmt",
        value: function visitDeclareClassStmt(stmt, context) {
          var _this44 = this;

          var parent = stmt.parent.visitExpression(this, context);
          var getters = stmt.getters.map(function (getter) {
            return new ClassGetter(getter.name, _this44.visitAllStatements(getter.body, context), getter.type, getter.modifiers);
          });
          var ctorMethod = stmt.constructorMethod && new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);
          var methods = stmt.methods.map(function (method) {
            return new ClassMethod(method.name, method.params, _this44.visitAllStatements(method.body, context), method.type, method.modifiers);
          });
          return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);
        }
      }, {
        key: "visitIfStmt",
        value: function visitIfStmt(stmt, context) {
          return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);
        }
      }, {
        key: "visitTryCatchStmt",
        value: function visitTryCatchStmt(stmt, context) {
          return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);
        }
      }, {
        key: "visitThrowStmt",
        value: function visitThrowStmt(stmt, context) {
          return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);
        }
      }, {
        key: "visitCommentStmt",
        value: function visitCommentStmt(stmt, context) {
          return this.transformStmt(stmt, context);
        }
      }, {
        key: "visitJSDocCommentStmt",
        value: function visitJSDocCommentStmt(stmt, context) {
          return this.transformStmt(stmt, context);
        }
      }, {
        key: "visitAllStatements",
        value: function visitAllStatements(stmts, context) {
          var _this45 = this;

          return stmts.map(function (stmt) {
            return stmt.visitStatement(_this45, context);
          });
        }
      }]);

      return AstTransformer;
    }();

    var RecursiveAstVisitor =
    /*#__PURE__*/
    function () {
      function RecursiveAstVisitor() {
        _classCallCheck(this, RecursiveAstVisitor);
      }

      _createClass(RecursiveAstVisitor, [{
        key: "visitType",
        value: function visitType(ast, context) {
          return ast;
        }
      }, {
        key: "visitExpression",
        value: function visitExpression(ast, context) {
          if (ast.type) {
            ast.type.visitType(this, context);
          }

          return ast;
        }
      }, {
        key: "visitBuiltinType",
        value: function visitBuiltinType(type, context) {
          return this.visitType(type, context);
        }
      }, {
        key: "visitExpressionType",
        value: function visitExpressionType(type, context) {
          var _this46 = this;

          type.value.visitExpression(this, context);

          if (type.typeParams !== null) {
            type.typeParams.forEach(function (param) {
              return _this46.visitType(param, context);
            });
          }

          return this.visitType(type, context);
        }
      }, {
        key: "visitArrayType",
        value: function visitArrayType(type, context) {
          return this.visitType(type, context);
        }
      }, {
        key: "visitMapType",
        value: function visitMapType(type, context) {
          return this.visitType(type, context);
        }
      }, {
        key: "visitWrappedNodeExpr",
        value: function visitWrappedNodeExpr(ast, context) {
          return ast;
        }
      }, {
        key: "visitTypeofExpr",
        value: function visitTypeofExpr(ast, context) {
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitReadVarExpr",
        value: function visitReadVarExpr(ast, context) {
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitWriteVarExpr",
        value: function visitWriteVarExpr(ast, context) {
          ast.value.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitWriteKeyExpr",
        value: function visitWriteKeyExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          ast.index.visitExpression(this, context);
          ast.value.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitWritePropExpr",
        value: function visitWritePropExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          ast.value.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitInvokeMethodExpr",
        value: function visitInvokeMethodExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitInvokeFunctionExpr",
        value: function visitInvokeFunctionExpr(ast, context) {
          ast.fn.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitInstantiateExpr",
        value: function visitInstantiateExpr(ast, context) {
          ast.classExpr.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitLiteralExpr",
        value: function visitLiteralExpr(ast, context) {
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitLocalizedString",
        value: function visitLocalizedString(ast, context) {
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitExternalExpr",
        value: function visitExternalExpr(ast, context) {
          var _this47 = this;

          if (ast.typeParams) {
            ast.typeParams.forEach(function (type) {
              return type.visitType(_this47, context);
            });
          }

          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitConditionalExpr",
        value: function visitConditionalExpr(ast, context) {
          ast.condition.visitExpression(this, context);
          ast.trueCase.visitExpression(this, context);
          ast.falseCase.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitNotExpr",
        value: function visitNotExpr(ast, context) {
          ast.condition.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitAssertNotNullExpr",
        value: function visitAssertNotNullExpr(ast, context) {
          ast.condition.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitCastExpr",
        value: function visitCastExpr(ast, context) {
          ast.value.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitFunctionExpr",
        value: function visitFunctionExpr(ast, context) {
          this.visitAllStatements(ast.statements, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitBinaryOperatorExpr",
        value: function visitBinaryOperatorExpr(ast, context) {
          ast.lhs.visitExpression(this, context);
          ast.rhs.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitReadPropExpr",
        value: function visitReadPropExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitReadKeyExpr",
        value: function visitReadKeyExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          ast.index.visitExpression(this, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitLiteralArrayExpr",
        value: function visitLiteralArrayExpr(ast, context) {
          this.visitAllExpressions(ast.entries, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitLiteralMapExpr",
        value: function visitLiteralMapExpr(ast, context) {
          var _this48 = this;

          ast.entries.forEach(function (entry) {
            return entry.value.visitExpression(_this48, context);
          });
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitCommaExpr",
        value: function visitCommaExpr(ast, context) {
          this.visitAllExpressions(ast.parts, context);
          return this.visitExpression(ast, context);
        }
      }, {
        key: "visitAllExpressions",
        value: function visitAllExpressions(exprs, context) {
          var _this49 = this;

          exprs.forEach(function (expr) {
            return expr.visitExpression(_this49, context);
          });
        }
      }, {
        key: "visitDeclareVarStmt",
        value: function visitDeclareVarStmt(stmt, context) {
          if (stmt.value) {
            stmt.value.visitExpression(this, context);
          }

          if (stmt.type) {
            stmt.type.visitType(this, context);
          }

          return stmt;
        }
      }, {
        key: "visitDeclareFunctionStmt",
        value: function visitDeclareFunctionStmt(stmt, context) {
          this.visitAllStatements(stmt.statements, context);

          if (stmt.type) {
            stmt.type.visitType(this, context);
          }

          return stmt;
        }
      }, {
        key: "visitExpressionStmt",
        value: function visitExpressionStmt(stmt, context) {
          stmt.expr.visitExpression(this, context);
          return stmt;
        }
      }, {
        key: "visitReturnStmt",
        value: function visitReturnStmt(stmt, context) {
          stmt.value.visitExpression(this, context);
          return stmt;
        }
      }, {
        key: "visitDeclareClassStmt",
        value: function visitDeclareClassStmt(stmt, context) {
          var _this50 = this;

          stmt.parent.visitExpression(this, context);
          stmt.getters.forEach(function (getter) {
            return _this50.visitAllStatements(getter.body, context);
          });

          if (stmt.constructorMethod) {
            this.visitAllStatements(stmt.constructorMethod.body, context);
          }

          stmt.methods.forEach(function (method) {
            return _this50.visitAllStatements(method.body, context);
          });
          return stmt;
        }
      }, {
        key: "visitIfStmt",
        value: function visitIfStmt(stmt, context) {
          stmt.condition.visitExpression(this, context);
          this.visitAllStatements(stmt.trueCase, context);
          this.visitAllStatements(stmt.falseCase, context);
          return stmt;
        }
      }, {
        key: "visitTryCatchStmt",
        value: function visitTryCatchStmt(stmt, context) {
          this.visitAllStatements(stmt.bodyStmts, context);
          this.visitAllStatements(stmt.catchStmts, context);
          return stmt;
        }
      }, {
        key: "visitThrowStmt",
        value: function visitThrowStmt(stmt, context) {
          stmt.error.visitExpression(this, context);
          return stmt;
        }
      }, {
        key: "visitCommentStmt",
        value: function visitCommentStmt(stmt, context) {
          return stmt;
        }
      }, {
        key: "visitJSDocCommentStmt",
        value: function visitJSDocCommentStmt(stmt, context) {
          return stmt;
        }
      }, {
        key: "visitAllStatements",
        value: function visitAllStatements(stmts, context) {
          var _this51 = this;

          stmts.forEach(function (stmt) {
            return stmt.visitStatement(_this51, context);
          });
        }
      }]);

      return RecursiveAstVisitor;
    }();

    function findReadVarNames(stmts) {
      var visitor = new _ReadVarVisitor();
      visitor.visitAllStatements(stmts, null);
      return visitor.varNames;
    }

    var _ReadVarVisitor =
    /*#__PURE__*/
    function (_RecursiveAstVisitor) {
      _inherits(_ReadVarVisitor, _RecursiveAstVisitor);

      function _ReadVarVisitor() {
        var _this52;

        _classCallCheck(this, _ReadVarVisitor);

        _this52 = _possibleConstructorReturn(this, _getPrototypeOf(_ReadVarVisitor).apply(this, arguments));
        _this52.varNames = new Set();
        return _this52;
      }

      _createClass(_ReadVarVisitor, [{
        key: "visitDeclareFunctionStmt",
        value: function visitDeclareFunctionStmt(stmt, context) {
          // Don't descend into nested functions
          return stmt;
        }
      }, {
        key: "visitDeclareClassStmt",
        value: function visitDeclareClassStmt(stmt, context) {
          // Don't descend into nested classes
          return stmt;
        }
      }, {
        key: "visitReadVarExpr",
        value: function visitReadVarExpr(ast, context) {
          if (ast.name) {
            this.varNames.add(ast.name);
          }

          return null;
        }
      }]);

      return _ReadVarVisitor;
    }(RecursiveAstVisitor);

    function collectExternalReferences(stmts) {
      var visitor = new _FindExternalReferencesVisitor();
      visitor.visitAllStatements(stmts, null);
      return visitor.externalReferences;
    }

    var _FindExternalReferencesVisitor =
    /*#__PURE__*/
    function (_RecursiveAstVisitor2) {
      _inherits(_FindExternalReferencesVisitor, _RecursiveAstVisitor2);

      function _FindExternalReferencesVisitor() {
        var _this53;

        _classCallCheck(this, _FindExternalReferencesVisitor);

        _this53 = _possibleConstructorReturn(this, _getPrototypeOf(_FindExternalReferencesVisitor).apply(this, arguments));
        _this53.externalReferences = [];
        return _this53;
      }

      _createClass(_FindExternalReferencesVisitor, [{
        key: "visitExternalExpr",
        value: function visitExternalExpr(e, context) {
          this.externalReferences.push(e.value);
          return _get(_getPrototypeOf(_FindExternalReferencesVisitor.prototype), "visitExternalExpr", this).call(this, e, context);
        }
      }]);

      return _FindExternalReferencesVisitor;
    }(RecursiveAstVisitor);

    function applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {
      if (!sourceSpan) {
        return stmt;
      }

      var transformer = new _ApplySourceSpanTransformer(sourceSpan);
      return stmt.visitStatement(transformer, null);
    }

    function applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {
      if (!sourceSpan) {
        return expr;
      }

      var transformer = new _ApplySourceSpanTransformer(sourceSpan);
      return expr.visitExpression(transformer, null);
    }

    var _ApplySourceSpanTransformer =
    /*#__PURE__*/
    function (_AstTransformer) {
      _inherits(_ApplySourceSpanTransformer, _AstTransformer);

      function _ApplySourceSpanTransformer(sourceSpan) {
        var _this54;

        _classCallCheck(this, _ApplySourceSpanTransformer);

        _this54 = _possibleConstructorReturn(this, _getPrototypeOf(_ApplySourceSpanTransformer).call(this));
        _this54.sourceSpan = sourceSpan;
        return _this54;
      }

      _createClass(_ApplySourceSpanTransformer, [{
        key: "_clone",
        value: function _clone(obj) {
          var clone = Object.create(obj.constructor.prototype);

          for (var _i4 = 0, _Object$keys = Object.keys(obj); _i4 < _Object$keys.length; _i4++) {
            var prop = _Object$keys[_i4];
            clone[prop] = obj[prop];
          }

          return clone;
        }
      }, {
        key: "transformExpr",
        value: function transformExpr(expr, context) {
          if (!expr.sourceSpan) {
            expr = this._clone(expr);
            expr.sourceSpan = this.sourceSpan;
          }

          return expr;
        }
      }, {
        key: "transformStmt",
        value: function transformStmt(stmt, context) {
          if (!stmt.sourceSpan) {
            stmt = this._clone(stmt);
            stmt.sourceSpan = this.sourceSpan;
          }

          return stmt;
        }
      }]);

      return _ApplySourceSpanTransformer;
    }(AstTransformer);

    function variable(name, type, sourceSpan) {
      return new ReadVarExpr(name, type, sourceSpan);
    }

    function importExpr(id) {
      var typeParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;
      return new ExternalExpr(id, null, typeParams, sourceSpan);
    }

    function importType(id) {
      var typeParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var typeModifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;
    }

    function expressionType(expr) {
      var typeModifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return new ExpressionType(expr, typeModifiers, typeParams);
    }

    function typeofExpr(expr) {
      return new TypeofExpr(expr);
    }

    function literalArr(values, type, sourceSpan) {
      return new LiteralArrayExpr(values, type, sourceSpan);
    }

    function literalMap(values) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return new LiteralMapExpr(values.map(function (e) {
        return new LiteralMapEntry(e.key, e.value, e.quoted);
      }), type, null);
    }

    function not(expr, sourceSpan) {
      return new NotExpr(expr, sourceSpan);
    }

    function assertNotNull(expr, sourceSpan) {
      return new AssertNotNull(expr, sourceSpan);
    }

    function fn(params, body, type, sourceSpan, name) {
      return new FunctionExpr(params, body, type, sourceSpan, name);
    }

    function ifStmt(condition, thenClause, elseClause) {
      return new IfStmt(condition, thenClause, elseClause);
    }

    function literal(value, type, sourceSpan) {
      return new LiteralExpr(value, type, sourceSpan);
    }

    function localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {
      return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);
    }

    function isNull(exp) {
      return exp instanceof LiteralExpr && exp.value === null;
    }
    /*
     * Serializes a `Tag` into a string.
     * Returns a string like " @foo {bar} baz" (note the leading whitespace before `@foo`).
     */


    function tagToString(tag) {
      var out = '';

      if (tag.tagName) {
        out += " @".concat(tag.tagName);
      }

      if (tag.text) {
        if (tag.text.match(/\/\*|\*\//)) {
          throw new Error('JSDoc text cannot contain "/*" and "*/"');
        }

        out += ' ' + tag.text.replace(/@/g, '\\@');
      }

      return out;
    }

    function serializeTags(tags) {
      if (tags.length === 0) return '';
      var out = '*\n';
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tag = _step.value;
          out += ' *'; // If the tagToString is multi-line, insert " * " prefixes on subsequent lines.

          out += tagToString(tag).replace(/\n/g, '\n * ');
          out += '\n';
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      out += ' ';
      return out;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var DASH_CASE_REGEXP = /-+([a-z0-9])/g;

    function dashCaseToCamelCase(input) {
      return input.replace(DASH_CASE_REGEXP, function () {
        for (var _len = arguments.length, m = new Array(_len), _key = 0; _key < _len; _key++) {
          m[_key] = arguments[_key];
        }

        return m[1].toUpperCase();
      });
    }

    function splitAtColon(input, defaultValues) {
      return _splitAt(input, ':', defaultValues);
    }

    function splitAtPeriod(input, defaultValues) {
      return _splitAt(input, '.', defaultValues);
    }

    function _splitAt(input, character, defaultValues) {
      var characterIndex = input.indexOf(character);
      if (characterIndex == -1) return defaultValues;
      return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
    }

    function visitValue(value, visitor, context) {
      if (Array.isArray(value)) {
        return visitor.visitArray(value, context);
      }

      if (isStrictStringMap(value)) {
        return visitor.visitStringMap(value, context);
      }

      if (value == null || typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean') {
        return visitor.visitPrimitive(value, context);
      }

      return visitor.visitOther(value, context);
    }

    function isDefined(val) {
      return val !== null && val !== undefined;
    }

    function noUndefined(val) {
      return val === undefined ? null : val;
    }

    var ValueTransformer =
    /*#__PURE__*/
    function () {
      function ValueTransformer() {
        _classCallCheck(this, ValueTransformer);
      }

      _createClass(ValueTransformer, [{
        key: "visitArray",
        value: function visitArray(arr, context) {
          var _this55 = this;

          return arr.map(function (value) {
            return visitValue(value, _this55, context);
          });
        }
      }, {
        key: "visitStringMap",
        value: function visitStringMap(map, context) {
          var _this56 = this;

          var result = {};
          Object.keys(map).forEach(function (key) {
            result[key] = visitValue(map[key], _this56, context);
          });
          return result;
        }
      }, {
        key: "visitPrimitive",
        value: function visitPrimitive(value, context) {
          return value;
        }
      }, {
        key: "visitOther",
        value: function visitOther(value, context) {
          return value;
        }
      }]);

      return ValueTransformer;
    }();

    var SyncAsync = {
      assertSync: function assertSync(value) {
        if (isPromise(value)) {
          throw new Error("Illegal state: value cannot be a promise");
        }

        return value;
      },
      then: function then(value, cb) {
        return isPromise(value) ? value.then(cb) : cb(value);
      },
      all: function all(syncAsyncValues) {
        return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;
      }
    };

    function error(msg) {
      throw new Error("Internal Error: ".concat(msg));
    }

    function syntaxError(msg, parseErrors) {
      var error = Error(msg);
      error[ERROR_SYNTAX_ERROR] = true;
      if (parseErrors) error[ERROR_PARSE_ERRORS] = parseErrors;
      return error;
    }

    var ERROR_SYNTAX_ERROR = 'ngSyntaxError';
    var ERROR_PARSE_ERRORS = 'ngParseErrors';

    function isSyntaxError(error) {
      return error[ERROR_SYNTAX_ERROR];
    }

    function getParseErrors(error) {
      return error[ERROR_PARSE_ERRORS] || [];
    } // Escape characters that have a special meaning in Regular Expressions


    function escapeRegExp(s) {
      return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
    }

    var STRING_MAP_PROTO = Object.getPrototypeOf({});

    function isStrictStringMap(obj) {
      return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
    }

    function utf8Encode(str) {
      var encoded = '';

      for (var index = 0; index < str.length; index++) {
        var codePoint = str.charCodeAt(index); // decode surrogate
        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae

        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {
          var low = str.charCodeAt(index + 1);

          if (low >= 0xdc00 && low <= 0xdfff) {
            index++;
            codePoint = (codePoint - 0xd800 << 10) + low - 0xdc00 + 0x10000;
          }
        }

        if (codePoint <= 0x7f) {
          encoded += String.fromCharCode(codePoint);
        } else if (codePoint <= 0x7ff) {
          encoded += String.fromCharCode(codePoint >> 6 & 0x1F | 0xc0, codePoint & 0x3f | 0x80);
        } else if (codePoint <= 0xffff) {
          encoded += String.fromCharCode(codePoint >> 12 | 0xe0, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);
        } else if (codePoint <= 0x1fffff) {
          encoded += String.fromCharCode(codePoint >> 18 & 0x07 | 0xf0, codePoint >> 12 & 0x3f | 0x80, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);
        }
      }

      return encoded;
    }

    function stringify(token) {
      if (typeof token === 'string') {
        return token;
      }

      if (Array.isArray(token)) {
        return '[' + token.map(stringify).join(', ') + ']';
      }

      if (token == null) {
        return '' + token;
      }

      if (token.overriddenName) {
        return "".concat(token.overriddenName);
      }

      if (token.name) {
        return "".concat(token.name);
      }

      if (!token.toString) {
        return 'object';
      } // WARNING: do not try to `JSON.stringify(token)` here
      // see https://github.com/angular/angular/issues/23440


      var res = token.toString();

      if (res == null) {
        return '' + res;
      }

      var newLineIndex = res.indexOf('\n');
      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    /**
     * Lazily retrieves the reference value from a forwardRef.
     */


    function resolveForwardRef(type) {
      if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {
        return type();
      } else {
        return type;
      }
    }
    /**
     * Determine if the argument is shaped like a Promise
     */


    function isPromise(obj) {
      // allow any Promise/A+ compliant thenable.
      // It's up to the caller to ensure that obj.then conforms to the spec
      return !!obj && typeof obj.then === 'function';
    }

    var Version = function Version(full) {
      _classCallCheck(this, Version);

      this.full = full;
      var splits = full.split('.');
      this.major = splits[0];
      this.minor = splits[1];
      this.patch = splits.slice(2).join('.');
    };

    var __window = typeof window !== 'undefined' && window;

    var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;

    var __global = typeof global !== 'undefined' && global; // Check __global first, because in Node tests both __global and __window may be defined and _global
    // should be __global in that case.


    var _global = __global || __window || __self;

    function newArray(size, value) {
      var list = [];

      for (var i = 0; i < size; i++) {
        list.push(value);
      }

      return list;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var CONSTANT_PREFIX = '_c';
    /**
     * `ConstantPool` tries to reuse literal factories when two or more literals are identical.
     * We determine whether literals are identical by creating a key out of their AST using the
     * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely
     * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what
     * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note
     * that we use a variable, rather than something like `null` in order to avoid collisions.
     */

    var UNKNOWN_VALUE_KEY = variable('<unknown>');
    /**
     * Context to use when producing a key.
     *
     * This ensures we see the constant not the reference variable when producing
     * a key.
     */

    var KEY_CONTEXT = {};
    /**
     * A node that is a place-holder that allows the node to be replaced when the actual
     * node is known.
     *
     * This allows the constant pool to change an expression from a direct reference to
     * a constant to a shared constant. It returns a fix-up node that is later allowed to
     * change the referenced expression.
     */

    var FixupExpression =
    /*#__PURE__*/
    function (_Expression24) {
      _inherits(FixupExpression, _Expression24);

      function FixupExpression(resolved) {
        var _this57;

        _classCallCheck(this, FixupExpression);

        _this57 = _possibleConstructorReturn(this, _getPrototypeOf(FixupExpression).call(this, resolved.type));
        _this57.resolved = resolved;
        _this57.original = resolved;
        return _this57;
      }

      _createClass(FixupExpression, [{
        key: "visitExpression",
        value: function visitExpression(visitor, context) {
          if (context === KEY_CONTEXT) {
            // When producing a key we want to traverse the constant not the
            // variable used to refer to it.
            return this.original.visitExpression(visitor, context);
          } else {
            return this.resolved.visitExpression(visitor, context);
          }
        }
      }, {
        key: "isEquivalent",
        value: function isEquivalent(e) {
          return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);
        }
      }, {
        key: "isConstant",
        value: function isConstant() {
          return true;
        }
      }, {
        key: "fixup",
        value: function fixup(expression) {
          this.resolved = expression;
          this.shared = true;
        }
      }]);

      return FixupExpression;
    }(Expression);
    /**
     * A constant pool allows a code emitter to share constant in an output context.
     *
     * The constant pool also supports sharing access to ivy definitions references.
     */


    var ConstantPool =
    /*#__PURE__*/
    function () {
      function ConstantPool() {
        _classCallCheck(this, ConstantPool);

        this.statements = [];
        this.literals = new Map();
        this.literalFactories = new Map();
        this.injectorDefinitions = new Map();
        this.directiveDefinitions = new Map();
        this.componentDefinitions = new Map();
        this.pipeDefinitions = new Map();
        this.nextNameIndex = 0;
      }

      _createClass(ConstantPool, [{
        key: "getConstLiteral",
        value: function getConstLiteral(literal, forceShared) {
          if (literal instanceof LiteralExpr || literal instanceof FixupExpression) {
            // Do no put simple literals into the constant pool or try to produce a constant for a
            // reference to a constant.
            return literal;
          }

          var key = this.keyOf(literal);
          var fixup = this.literals.get(key);
          var newValue = false;

          if (!fixup) {
            fixup = new FixupExpression(literal);
            this.literals.set(key, fixup);
            newValue = true;
          }

          if (!newValue && !fixup.shared || newValue && forceShared) {
            // Replace the expression with a variable
            var name = this.freshName();
            this.statements.push(variable(name).set(literal).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
            fixup.fixup(variable(name));
          }

          return fixup;
        }
      }, {
        key: "getDefinition",
        value: function getDefinition(type, kind, ctx) {
          var forceShared = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var definitions = this.definitionsOf(kind);
          var fixup = definitions.get(type);
          var newValue = false;

          if (!fixup) {
            var property = this.propertyNameOf(kind);
            fixup = new FixupExpression(ctx.importExpr(type).prop(property));
            definitions.set(type, fixup);
            newValue = true;
          }

          if (!newValue && !fixup.shared || newValue && forceShared) {
            var name = this.freshName();
            this.statements.push(variable(name).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
            fixup.fixup(variable(name));
          }

          return fixup;
        }
      }, {
        key: "getLiteralFactory",
        value: function getLiteralFactory(literal) {
          // Create a pure function that builds an array of a mix of constant and variable expressions
          if (literal instanceof LiteralArrayExpr) {
            var argumentsForKey = literal.entries.map(function (e) {
              return e.isConstant() ? e : UNKNOWN_VALUE_KEY;
            });
            var key = this.keyOf(literalArr(argumentsForKey));
            return this._getLiteralFactory(key, literal.entries, function (entries) {
              return literalArr(entries);
            });
          } else {
            var expressionForKey = literalMap(literal.entries.map(function (e) {
              return {
                key: e.key,
                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,
                quoted: e.quoted
              };
            }));

            var _key2 = this.keyOf(expressionForKey);

            return this._getLiteralFactory(_key2, literal.entries.map(function (e) {
              return e.value;
            }), function (entries) {
              return literalMap(entries.map(function (value, index) {
                return {
                  key: literal.entries[index].key,
                  value: value,
                  quoted: literal.entries[index].quoted
                };
              }));
            });
          }
        }
      }, {
        key: "_getLiteralFactory",
        value: function _getLiteralFactory(key, values, resultMap) {
          var _this58 = this;

          var literalFactory = this.literalFactories.get(key);
          var literalFactoryArguments = values.filter(function (e) {
            return !e.isConstant();
          });

          if (!literalFactory) {
            var resultExpressions = values.map(function (e, index) {
              return e.isConstant() ? _this58.getConstLiteral(e, true) : variable("a".concat(index));
            });
            var parameters = resultExpressions.filter(isVariable).map(function (e) {
              return new FnParam(e.name, DYNAMIC_TYPE);
            });
            var pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);
            var name = this.freshName();
            this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
            literalFactory = variable(name);
            this.literalFactories.set(key, literalFactory);
          }

          return {
            literalFactory: literalFactory,
            literalFactoryArguments: literalFactoryArguments
          };
        }
        /**
         * Produce a unique name.
         *
         * The name might be unique among different prefixes if any of the prefixes end in
         * a digit so the prefix should be a constant string (not based on user input) and
         * must not end in a digit.
         */

      }, {
        key: "uniqueName",
        value: function uniqueName(prefix) {
          return "".concat(prefix).concat(this.nextNameIndex++);
        }
      }, {
        key: "definitionsOf",
        value: function definitionsOf(kind) {
          switch (kind) {
            case 2
            /* Component */
            :
              return this.componentDefinitions;

            case 1
            /* Directive */
            :
              return this.directiveDefinitions;

            case 0
            /* Injector */
            :
              return this.injectorDefinitions;

            case 3
            /* Pipe */
            :
              return this.pipeDefinitions;
          }

          error("Unknown definition kind ".concat(kind));
          return this.componentDefinitions;
        }
      }, {
        key: "propertyNameOf",
        value: function propertyNameOf(kind) {
          switch (kind) {
            case 2
            /* Component */
            :
              return 'ɵcmp';

            case 1
            /* Directive */
            :
              return 'ɵdir';

            case 0
            /* Injector */
            :
              return 'ɵinj';

            case 3
            /* Pipe */
            :
              return 'ɵpipe';
          }

          error("Unknown definition kind ".concat(kind));
          return '<unknown>';
        }
      }, {
        key: "freshName",
        value: function freshName() {
          return this.uniqueName(CONSTANT_PREFIX);
        }
      }, {
        key: "keyOf",
        value: function keyOf(expression) {
          return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);
        }
      }]);

      return ConstantPool;
    }();
    /**
     * Visitor used to determine if 2 expressions are equivalent and can be shared in the
     * `ConstantPool`.
     *
     * When the id (string) generated by the visitor is equal, expressions are considered equivalent.
     */


    var KeyVisitor =
    /*#__PURE__*/
    function () {
      function KeyVisitor() {
        _classCallCheck(this, KeyVisitor);

        this.visitWrappedNodeExpr = invalid;
        this.visitWriteVarExpr = invalid;
        this.visitWriteKeyExpr = invalid;
        this.visitWritePropExpr = invalid;
        this.visitInvokeMethodExpr = invalid;
        this.visitInvokeFunctionExpr = invalid;
        this.visitInstantiateExpr = invalid;
        this.visitConditionalExpr = invalid;
        this.visitNotExpr = invalid;
        this.visitAssertNotNullExpr = invalid;
        this.visitCastExpr = invalid;
        this.visitFunctionExpr = invalid;
        this.visitBinaryOperatorExpr = invalid;
        this.visitReadPropExpr = invalid;
        this.visitReadKeyExpr = invalid;
        this.visitCommaExpr = invalid;
        this.visitLocalizedString = invalid;
      }

      _createClass(KeyVisitor, [{
        key: "visitLiteralExpr",
        value: function visitLiteralExpr(ast) {
          return "".concat(typeof ast.value === 'string' ? '"' + ast.value + '"' : ast.value);
        }
      }, {
        key: "visitLiteralArrayExpr",
        value: function visitLiteralArrayExpr(ast, context) {
          var _this59 = this;

          return "[".concat(ast.entries.map(function (entry) {
            return entry.visitExpression(_this59, context);
          }).join(','), "]");
        }
      }, {
        key: "visitLiteralMapExpr",
        value: function visitLiteralMapExpr(ast, context) {
          var _this60 = this;

          var mapKey = function mapKey(entry) {
            var quote = entry.quoted ? '"' : '';
            return "".concat(quote).concat(entry.key).concat(quote);
          };

          var mapEntry = function mapEntry(entry) {
            return "".concat(mapKey(entry), ":").concat(entry.value.visitExpression(_this60, context));
          };

          return "{".concat(ast.entries.map(mapEntry).join(','));
        }
      }, {
        key: "visitExternalExpr",
        value: function visitExternalExpr(ast) {
          return ast.value.moduleName ? "EX:".concat(ast.value.moduleName, ":").concat(ast.value.name) : "EX:".concat(ast.value.runtime.name);
        }
      }, {
        key: "visitReadVarExpr",
        value: function visitReadVarExpr(node) {
          return "VAR:".concat(node.name);
        }
      }, {
        key: "visitTypeofExpr",
        value: function visitTypeofExpr(node, context) {
          return "TYPEOF:".concat(node.expr.visitExpression(this, context));
        }
      }]);

      return KeyVisitor;
    }();

    function invalid(arg) {
      throw new Error("Invalid state: Visitor ".concat(this.constructor.name, " doesn't handle ").concat(arg.constructor.name));
    }

    function isVariable(e) {
      return e instanceof ReadVarExpr;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var CORE = '@angular/core';

    var Identifiers = function Identifiers() {
      _classCallCheck(this, Identifiers);
    };

    Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {
      name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
      moduleName: CORE
    };
    Identifiers.ElementRef = {
      name: 'ElementRef',
      moduleName: CORE
    };
    Identifiers.NgModuleRef = {
      name: 'NgModuleRef',
      moduleName: CORE
    };
    Identifiers.ViewContainerRef = {
      name: 'ViewContainerRef',
      moduleName: CORE
    };
    Identifiers.ChangeDetectorRef = {
      name: 'ChangeDetectorRef',
      moduleName: CORE
    };
    Identifiers.QueryList = {
      name: 'QueryList',
      moduleName: CORE
    };
    Identifiers.TemplateRef = {
      name: 'TemplateRef',
      moduleName: CORE
    };
    Identifiers.Renderer2 = {
      name: 'Renderer2',
      moduleName: CORE
    };
    Identifiers.CodegenComponentFactoryResolver = {
      name: 'ɵCodegenComponentFactoryResolver',
      moduleName: CORE
    };
    Identifiers.ComponentFactoryResolver = {
      name: 'ComponentFactoryResolver',
      moduleName: CORE
    };
    Identifiers.ComponentFactory = {
      name: 'ComponentFactory',
      moduleName: CORE
    };
    Identifiers.ComponentRef = {
      name: 'ComponentRef',
      moduleName: CORE
    };
    Identifiers.NgModuleFactory = {
      name: 'NgModuleFactory',
      moduleName: CORE
    };
    Identifiers.createModuleFactory = {
      name: 'ɵcmf',
      moduleName: CORE
    };
    Identifiers.moduleDef = {
      name: 'ɵmod',
      moduleName: CORE
    };
    Identifiers.moduleProviderDef = {
      name: 'ɵmpd',
      moduleName: CORE
    };
    Identifiers.RegisterModuleFactoryFn = {
      name: 'ɵregisterModuleFactory',
      moduleName: CORE
    };
    Identifiers.inject = {
      name: 'ɵɵinject',
      moduleName: CORE
    };
    Identifiers.directiveInject = {
      name: 'ɵɵdirectiveInject',
      moduleName: CORE
    };
    Identifiers.INJECTOR = {
      name: 'INJECTOR',
      moduleName: CORE
    };
    Identifiers.Injector = {
      name: 'Injector',
      moduleName: CORE
    };
    Identifiers.ɵɵdefineInjectable = {
      name: 'ɵɵdefineInjectable',
      moduleName: CORE
    };
    Identifiers.InjectableDef = {
      name: 'ɵɵInjectableDef',
      moduleName: CORE
    };
    Identifiers.ViewEncapsulation = {
      name: 'ViewEncapsulation',
      moduleName: CORE
    };
    Identifiers.ChangeDetectionStrategy = {
      name: 'ChangeDetectionStrategy',
      moduleName: CORE
    };
    Identifiers.SecurityContext = {
      name: 'SecurityContext',
      moduleName: CORE
    };
    Identifiers.LOCALE_ID = {
      name: 'LOCALE_ID',
      moduleName: CORE
    };
    Identifiers.TRANSLATIONS_FORMAT = {
      name: 'TRANSLATIONS_FORMAT',
      moduleName: CORE
    };
    Identifiers.inlineInterpolate = {
      name: 'ɵinlineInterpolate',
      moduleName: CORE
    };
    Identifiers.interpolate = {
      name: 'ɵinterpolate',
      moduleName: CORE
    };
    Identifiers.EMPTY_ARRAY = {
      name: 'ɵEMPTY_ARRAY',
      moduleName: CORE
    };
    Identifiers.EMPTY_MAP = {
      name: 'ɵEMPTY_MAP',
      moduleName: CORE
    };
    Identifiers.Renderer = {
      name: 'Renderer',
      moduleName: CORE
    };
    Identifiers.viewDef = {
      name: 'ɵvid',
      moduleName: CORE
    };
    Identifiers.elementDef = {
      name: 'ɵeld',
      moduleName: CORE
    };
    Identifiers.anchorDef = {
      name: 'ɵand',
      moduleName: CORE
    };
    Identifiers.textDef = {
      name: 'ɵted',
      moduleName: CORE
    };
    Identifiers.directiveDef = {
      name: 'ɵdid',
      moduleName: CORE
    };
    Identifiers.providerDef = {
      name: 'ɵprd',
      moduleName: CORE
    };
    Identifiers.queryDef = {
      name: 'ɵqud',
      moduleName: CORE
    };
    Identifiers.pureArrayDef = {
      name: 'ɵpad',
      moduleName: CORE
    };
    Identifiers.pureObjectDef = {
      name: 'ɵpod',
      moduleName: CORE
    };
    Identifiers.purePipeDef = {
      name: 'ɵppd',
      moduleName: CORE
    };
    Identifiers.pipeDef = {
      name: 'ɵpid',
      moduleName: CORE
    };
    Identifiers.nodeValue = {
      name: 'ɵnov',
      moduleName: CORE
    };
    Identifiers.ngContentDef = {
      name: 'ɵncd',
      moduleName: CORE
    };
    Identifiers.unwrapValue = {
      name: 'ɵunv',
      moduleName: CORE
    };
    Identifiers.createRendererType2 = {
      name: 'ɵcrt',
      moduleName: CORE
    }; // type only

    Identifiers.RendererType2 = {
      name: 'RendererType2',
      moduleName: CORE
    }; // type only

    Identifiers.ViewDefinition = {
      name: 'ɵViewDefinition',
      moduleName: CORE
    };
    Identifiers.createComponentFactory = {
      name: 'ɵccf',
      moduleName: CORE
    };
    Identifiers.setClassMetadata = {
      name: 'ɵsetClassMetadata',
      moduleName: CORE
    };

    function createTokenForReference(reference) {
      return {
        identifier: {
          reference: reference
        }
      };
    }

    function createTokenForExternalReference(reflector, reference) {
      return createTokenForReference(reflector.resolveExternalReference(reference));
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * A token representing the a reference to a static type.
     *
     * This token is unique for a filePath and name and can be used as a hash table key.
     */


    var StaticSymbol =
    /*#__PURE__*/
    function () {
      function StaticSymbol(filePath, name, members) {
        _classCallCheck(this, StaticSymbol);

        this.filePath = filePath;
        this.name = name;
        this.members = members;
      }

      _createClass(StaticSymbol, [{
        key: "assertNoMembers",
        value: function assertNoMembers() {
          if (this.members.length) {
            throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
          }
        }
      }]);

      return StaticSymbol;
    }();
    /**
     * A cache of static symbol used by the StaticReflector to return the same symbol for the
     * same symbol values.
     */


    var StaticSymbolCache =
    /*#__PURE__*/
    function () {
      function StaticSymbolCache() {
        _classCallCheck(this, StaticSymbolCache);

        this.cache = new Map();
      }

      _createClass(StaticSymbolCache, [{
        key: "get",
        value: function get(declarationFile, name, members) {
          members = members || [];
          var memberSuffix = members.length ? ".".concat(members.join('.')) : '';
          var key = "\"".concat(declarationFile, "\".").concat(name).concat(memberSuffix);
          var result = this.cache.get(key);

          if (!result) {
            result = new StaticSymbol(declarationFile, name, members);
            this.cache.set(key, result);
          }

          return result;
        }
      }]);

      return StaticSymbolCache;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // group 0: "[prop] or (event) or @trigger"
    // group 1: "prop" from "[prop]"
    // group 2: "event" from "(event)"
    // group 3: "@trigger" from "@trigger"


    var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;

    function sanitizeIdentifier(name) {
      return name.replace(/\W/g, '_');
    }

    var _anonymousTypeIndex = 0;

    function identifierName(compileIdentifier) {
      if (!compileIdentifier || !compileIdentifier.reference) {
        return null;
      }

      var ref = compileIdentifier.reference;

      if (ref instanceof StaticSymbol) {
        return ref.name;
      }

      if (ref['__anonymousType']) {
        return ref['__anonymousType'];
      }

      var identifier = stringify(ref);

      if (identifier.indexOf('(') >= 0) {
        // case: anonymous functions!
        identifier = "anonymous_".concat(_anonymousTypeIndex++);
        ref['__anonymousType'] = identifier;
      } else {
        identifier = sanitizeIdentifier(identifier);
      }

      return identifier;
    }

    function identifierModuleUrl(compileIdentifier) {
      var ref = compileIdentifier.reference;

      if (ref instanceof StaticSymbol) {
        return ref.filePath;
      } // Runtime type


      return "./".concat(stringify(ref));
    }

    function viewClassName(compType, embeddedTemplateIndex) {
      return "View_".concat(identifierName({
        reference: compType
      }), "_").concat(embeddedTemplateIndex);
    }

    function rendererTypeName(compType) {
      return "RenderType_".concat(identifierName({
        reference: compType
      }));
    }

    function hostViewClassName(compType) {
      return "HostView_".concat(identifierName({
        reference: compType
      }));
    }

    function componentFactoryName(compType) {
      return "".concat(identifierName({
        reference: compType
      }), "NgFactory");
    }

    var CompileSummaryKind;

    (function (CompileSummaryKind) {
      CompileSummaryKind[CompileSummaryKind["Pipe"] = 0] = "Pipe";
      CompileSummaryKind[CompileSummaryKind["Directive"] = 1] = "Directive";
      CompileSummaryKind[CompileSummaryKind["NgModule"] = 2] = "NgModule";
      CompileSummaryKind[CompileSummaryKind["Injectable"] = 3] = "Injectable";
    })(CompileSummaryKind || (CompileSummaryKind = {}));

    function tokenName(token) {
      return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);
    }

    function tokenReference(token) {
      if (token.identifier != null) {
        return token.identifier.reference;
      } else {
        return token.value;
      }
    }
    /**
     * Metadata about a stylesheet
     */


    var CompileStylesheetMetadata = function CompileStylesheetMetadata() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          moduleUrl = _ref3.moduleUrl,
          styles = _ref3.styles,
          styleUrls = _ref3.styleUrls;

      _classCallCheck(this, CompileStylesheetMetadata);

      this.moduleUrl = moduleUrl || null;
      this.styles = _normalizeArray(styles);
      this.styleUrls = _normalizeArray(styleUrls);
    };
    /**
     * Metadata regarding compilation of a template.
     */


    var CompileTemplateMetadata =
    /*#__PURE__*/
    function () {
      function CompileTemplateMetadata(_ref4) {
        var encapsulation = _ref4.encapsulation,
            template = _ref4.template,
            templateUrl = _ref4.templateUrl,
            htmlAst = _ref4.htmlAst,
            styles = _ref4.styles,
            styleUrls = _ref4.styleUrls,
            externalStylesheets = _ref4.externalStylesheets,
            animations = _ref4.animations,
            ngContentSelectors = _ref4.ngContentSelectors,
            interpolation = _ref4.interpolation,
            isInline = _ref4.isInline,
            preserveWhitespaces = _ref4.preserveWhitespaces;

        _classCallCheck(this, CompileTemplateMetadata);

        this.encapsulation = encapsulation;
        this.template = template;
        this.templateUrl = templateUrl;
        this.htmlAst = htmlAst;
        this.styles = _normalizeArray(styles);
        this.styleUrls = _normalizeArray(styleUrls);
        this.externalStylesheets = _normalizeArray(externalStylesheets);
        this.animations = animations ? flatten(animations) : [];
        this.ngContentSelectors = ngContentSelectors || [];

        if (interpolation && interpolation.length != 2) {
          throw new Error("'interpolation' should have a start and an end symbol.");
        }

        this.interpolation = interpolation;
        this.isInline = isInline;
        this.preserveWhitespaces = preserveWhitespaces;
      }

      _createClass(CompileTemplateMetadata, [{
        key: "toSummary",
        value: function toSummary() {
          return {
            ngContentSelectors: this.ngContentSelectors,
            encapsulation: this.encapsulation,
            styles: this.styles,
            animations: this.animations
          };
        }
      }]);

      return CompileTemplateMetadata;
    }();
    /**
     * Metadata regarding compilation of a directive.
     */


    var CompileDirectiveMetadata =
    /*#__PURE__*/
    function () {
      function CompileDirectiveMetadata(_ref5) {
        var isHost = _ref5.isHost,
            type = _ref5.type,
            isComponent = _ref5.isComponent,
            selector = _ref5.selector,
            exportAs = _ref5.exportAs,
            changeDetection = _ref5.changeDetection,
            inputs = _ref5.inputs,
            outputs = _ref5.outputs,
            hostListeners = _ref5.hostListeners,
            hostProperties = _ref5.hostProperties,
            hostAttributes = _ref5.hostAttributes,
            providers = _ref5.providers,
            viewProviders = _ref5.viewProviders,
            queries = _ref5.queries,
            guards = _ref5.guards,
            viewQueries = _ref5.viewQueries,
            entryComponents = _ref5.entryComponents,
            template = _ref5.template,
            componentViewType = _ref5.componentViewType,
            rendererType = _ref5.rendererType,
            componentFactory = _ref5.componentFactory;

        _classCallCheck(this, CompileDirectiveMetadata);

        this.isHost = !!isHost;
        this.type = type;
        this.isComponent = isComponent;
        this.selector = selector;
        this.exportAs = exportAs;
        this.changeDetection = changeDetection;
        this.inputs = inputs;
        this.outputs = outputs;
        this.hostListeners = hostListeners;
        this.hostProperties = hostProperties;
        this.hostAttributes = hostAttributes;
        this.providers = _normalizeArray(providers);
        this.viewProviders = _normalizeArray(viewProviders);
        this.queries = _normalizeArray(queries);
        this.guards = guards;
        this.viewQueries = _normalizeArray(viewQueries);
        this.entryComponents = _normalizeArray(entryComponents);
        this.template = template;
        this.componentViewType = componentViewType;
        this.rendererType = rendererType;
        this.componentFactory = componentFactory;
      }

      _createClass(CompileDirectiveMetadata, [{
        key: "toSummary",
        value: function toSummary() {
          return {
            summaryKind: CompileSummaryKind.Directive,
            type: this.type,
            isComponent: this.isComponent,
            selector: this.selector,
            exportAs: this.exportAs,
            inputs: this.inputs,
            outputs: this.outputs,
            hostListeners: this.hostListeners,
            hostProperties: this.hostProperties,
            hostAttributes: this.hostAttributes,
            providers: this.providers,
            viewProviders: this.viewProviders,
            queries: this.queries,
            guards: this.guards,
            viewQueries: this.viewQueries,
            entryComponents: this.entryComponents,
            changeDetection: this.changeDetection,
            template: this.template && this.template.toSummary(),
            componentViewType: this.componentViewType,
            rendererType: this.rendererType,
            componentFactory: this.componentFactory
          };
        }
      }], [{
        key: "create",
        value: function create(_ref6) {
          var isHost = _ref6.isHost,
              type = _ref6.type,
              isComponent = _ref6.isComponent,
              selector = _ref6.selector,
              exportAs = _ref6.exportAs,
              changeDetection = _ref6.changeDetection,
              inputs = _ref6.inputs,
              outputs = _ref6.outputs,
              host = _ref6.host,
              providers = _ref6.providers,
              viewProviders = _ref6.viewProviders,
              queries = _ref6.queries,
              guards = _ref6.guards,
              viewQueries = _ref6.viewQueries,
              entryComponents = _ref6.entryComponents,
              template = _ref6.template,
              componentViewType = _ref6.componentViewType,
              rendererType = _ref6.rendererType,
              componentFactory = _ref6.componentFactory;
          var hostListeners = {};
          var hostProperties = {};
          var hostAttributes = {};

          if (host != null) {
            Object.keys(host).forEach(function (key) {
              var value = host[key];
              var matches = key.match(HOST_REG_EXP);

              if (matches === null) {
                hostAttributes[key] = value;
              } else if (matches[1] != null) {
                hostProperties[matches[1]] = value;
              } else if (matches[2] != null) {
                hostListeners[matches[2]] = value;
              }
            });
          }

          var inputsMap = {};

          if (inputs != null) {
            inputs.forEach(function (bindConfig) {
              // canonical syntax: `dirProp: elProp`
              // if there is no `:`, use dirProp = elProp
              var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
              inputsMap[parts[0]] = parts[1];
            });
          }

          var outputsMap = {};

          if (outputs != null) {
            outputs.forEach(function (bindConfig) {
              // canonical syntax: `dirProp: elProp`
              // if there is no `:`, use dirProp = elProp
              var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
              outputsMap[parts[0]] = parts[1];
            });
          }

          return new CompileDirectiveMetadata({
            isHost: isHost,
            type: type,
            isComponent: !!isComponent,
            selector: selector,
            exportAs: exportAs,
            changeDetection: changeDetection,
            inputs: inputsMap,
            outputs: outputsMap,
            hostListeners: hostListeners,
            hostProperties: hostProperties,
            hostAttributes: hostAttributes,
            providers: providers,
            viewProviders: viewProviders,
            queries: queries,
            guards: guards,
            viewQueries: viewQueries,
            entryComponents: entryComponents,
            template: template,
            componentViewType: componentViewType,
            rendererType: rendererType,
            componentFactory: componentFactory
          });
        }
      }]);

      return CompileDirectiveMetadata;
    }();

    var CompilePipeMetadata =
    /*#__PURE__*/
    function () {
      function CompilePipeMetadata(_ref7) {
        var type = _ref7.type,
            name = _ref7.name,
            pure = _ref7.pure;

        _classCallCheck(this, CompilePipeMetadata);

        this.type = type;
        this.name = name;
        this.pure = !!pure;
      }

      _createClass(CompilePipeMetadata, [{
        key: "toSummary",
        value: function toSummary() {
          return {
            summaryKind: CompileSummaryKind.Pipe,
            type: this.type,
            name: this.name,
            pure: this.pure
          };
        }
      }]);

      return CompilePipeMetadata;
    }();

    var CompileShallowModuleMetadata = function CompileShallowModuleMetadata() {
      _classCallCheck(this, CompileShallowModuleMetadata);
    };
    /**
     * Metadata regarding compilation of a module.
     */


    var CompileNgModuleMetadata =
    /*#__PURE__*/
    function () {
      function CompileNgModuleMetadata(_ref8) {
        var type = _ref8.type,
            providers = _ref8.providers,
            declaredDirectives = _ref8.declaredDirectives,
            exportedDirectives = _ref8.exportedDirectives,
            declaredPipes = _ref8.declaredPipes,
            exportedPipes = _ref8.exportedPipes,
            entryComponents = _ref8.entryComponents,
            bootstrapComponents = _ref8.bootstrapComponents,
            importedModules = _ref8.importedModules,
            exportedModules = _ref8.exportedModules,
            schemas = _ref8.schemas,
            transitiveModule = _ref8.transitiveModule,
            id = _ref8.id;

        _classCallCheck(this, CompileNgModuleMetadata);

        this.type = type || null;
        this.declaredDirectives = _normalizeArray(declaredDirectives);
        this.exportedDirectives = _normalizeArray(exportedDirectives);
        this.declaredPipes = _normalizeArray(declaredPipes);
        this.exportedPipes = _normalizeArray(exportedPipes);
        this.providers = _normalizeArray(providers);
        this.entryComponents = _normalizeArray(entryComponents);
        this.bootstrapComponents = _normalizeArray(bootstrapComponents);
        this.importedModules = _normalizeArray(importedModules);
        this.exportedModules = _normalizeArray(exportedModules);
        this.schemas = _normalizeArray(schemas);
        this.id = id || null;
        this.transitiveModule = transitiveModule || null;
      }

      _createClass(CompileNgModuleMetadata, [{
        key: "toSummary",
        value: function toSummary() {
          var module = this.transitiveModule;
          return {
            summaryKind: CompileSummaryKind.NgModule,
            type: this.type,
            entryComponents: module.entryComponents,
            providers: module.providers,
            modules: module.modules,
            exportedDirectives: module.exportedDirectives,
            exportedPipes: module.exportedPipes
          };
        }
      }]);

      return CompileNgModuleMetadata;
    }();

    var TransitiveCompileNgModuleMetadata =
    /*#__PURE__*/
    function () {
      function TransitiveCompileNgModuleMetadata() {
        _classCallCheck(this, TransitiveCompileNgModuleMetadata);

        this.directivesSet = new Set();
        this.directives = [];
        this.exportedDirectivesSet = new Set();
        this.exportedDirectives = [];
        this.pipesSet = new Set();
        this.pipes = [];
        this.exportedPipesSet = new Set();
        this.exportedPipes = [];
        this.modulesSet = new Set();
        this.modules = [];
        this.entryComponentsSet = new Set();
        this.entryComponents = [];
        this.providers = [];
      }

      _createClass(TransitiveCompileNgModuleMetadata, [{
        key: "addProvider",
        value: function addProvider(provider, module) {
          this.providers.push({
            provider: provider,
            module: module
          });
        }
      }, {
        key: "addDirective",
        value: function addDirective(id) {
          if (!this.directivesSet.has(id.reference)) {
            this.directivesSet.add(id.reference);
            this.directives.push(id);
          }
        }
      }, {
        key: "addExportedDirective",
        value: function addExportedDirective(id) {
          if (!this.exportedDirectivesSet.has(id.reference)) {
            this.exportedDirectivesSet.add(id.reference);
            this.exportedDirectives.push(id);
          }
        }
      }, {
        key: "addPipe",
        value: function addPipe(id) {
          if (!this.pipesSet.has(id.reference)) {
            this.pipesSet.add(id.reference);
            this.pipes.push(id);
          }
        }
      }, {
        key: "addExportedPipe",
        value: function addExportedPipe(id) {
          if (!this.exportedPipesSet.has(id.reference)) {
            this.exportedPipesSet.add(id.reference);
            this.exportedPipes.push(id);
          }
        }
      }, {
        key: "addModule",
        value: function addModule(id) {
          if (!this.modulesSet.has(id.reference)) {
            this.modulesSet.add(id.reference);
            this.modules.push(id);
          }
        }
      }, {
        key: "addEntryComponent",
        value: function addEntryComponent(ec) {
          if (!this.entryComponentsSet.has(ec.componentType)) {
            this.entryComponentsSet.add(ec.componentType);
            this.entryComponents.push(ec);
          }
        }
      }]);

      return TransitiveCompileNgModuleMetadata;
    }();

    function _normalizeArray(obj) {
      return obj || [];
    }

    var ProviderMeta = function ProviderMeta(token, _ref9) {
      var useClass = _ref9.useClass,
          useValue = _ref9.useValue,
          useExisting = _ref9.useExisting,
          useFactory = _ref9.useFactory,
          deps = _ref9.deps,
          multi = _ref9.multi;

      _classCallCheck(this, ProviderMeta);

      this.token = token;
      this.useClass = useClass || null;
      this.useValue = useValue;
      this.useExisting = useExisting;
      this.useFactory = useFactory || null;
      this.dependencies = deps || null;
      this.multi = !!multi;
    };

    function flatten(list) {
      return list.reduce(function (flat, item) {
        var flatItem = Array.isArray(item) ? flatten(item) : item;
        return flat.concat(flatItem);
      }, []);
    }

    function jitSourceUrl(url) {
      // Note: We need 3 "/" so that ng shows up as a separate domain
      // in the chrome dev tools.
      return url.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, 'ng:///');
    }

    function templateSourceUrl(ngModuleType, compMeta, templateMeta) {
      var url;

      if (templateMeta.isInline) {
        if (compMeta.type.reference instanceof StaticSymbol) {
          // Note: a .ts file might contain multiple components with inline templates,
          // so we need to give them unique urls, as these will be used for sourcemaps.
          url = "".concat(compMeta.type.reference.filePath, ".").concat(compMeta.type.reference.name, ".html");
        } else {
          url = "".concat(identifierName(ngModuleType), "/").concat(identifierName(compMeta.type), ".html");
        }
      } else {
        url = templateMeta.templateUrl;
      }

      return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);
    }

    function sharedStylesheetJitUrl(meta, id) {
      var pathParts = meta.moduleUrl.split(/\/\\/g);
      var baseName = pathParts[pathParts.length - 1];
      return jitSourceUrl("css/".concat(id).concat(baseName, ".ngstyle.js"));
    }

    function ngModuleJitUrl(moduleMeta) {
      return jitSourceUrl("".concat(identifierName(moduleMeta.type), "/module.ngfactory.js"));
    }

    function templateJitUrl(ngModuleType, compMeta) {
      return jitSourceUrl("".concat(identifierName(ngModuleType), "/").concat(identifierName(compMeta.type), ".ngfactory.js"));
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var CORE$1 = '@angular/core';

    var Identifiers$1 = function Identifiers$1() {
      _classCallCheck(this, Identifiers$1);
    };
    /* Methods */


    Identifiers$1.NEW_METHOD = 'factory';
    Identifiers$1.TRANSFORM_METHOD = 'transform';
    Identifiers$1.PATCH_DEPS = 'patchedDeps';
    /* Instructions */

    Identifiers$1.namespaceHTML = {
      name: 'ɵɵnamespaceHTML',
      moduleName: CORE$1
    };
    Identifiers$1.namespaceMathML = {
      name: 'ɵɵnamespaceMathML',
      moduleName: CORE$1
    };
    Identifiers$1.namespaceSVG = {
      name: 'ɵɵnamespaceSVG',
      moduleName: CORE$1
    };
    Identifiers$1.element = {
      name: 'ɵɵelement',
      moduleName: CORE$1
    };
    Identifiers$1.elementStart = {
      name: 'ɵɵelementStart',
      moduleName: CORE$1
    };
    Identifiers$1.elementEnd = {
      name: 'ɵɵelementEnd',
      moduleName: CORE$1
    };
    Identifiers$1.select = {
      name: 'ɵɵselect',
      moduleName: CORE$1
    };
    Identifiers$1.advance = {
      name: 'ɵɵadvance',
      moduleName: CORE$1
    };
    Identifiers$1.updateSyntheticHostBinding = {
      name: 'ɵɵupdateSyntheticHostBinding',
      moduleName: CORE$1
    };
    Identifiers$1.componentHostSyntheticListener = {
      name: 'ɵɵcomponentHostSyntheticListener',
      moduleName: CORE$1
    };
    Identifiers$1.attribute = {
      name: 'ɵɵattribute',
      moduleName: CORE$1
    };
    Identifiers$1.attributeInterpolate1 = {
      name: 'ɵɵattributeInterpolate1',
      moduleName: CORE$1
    };
    Identifiers$1.attributeInterpolate2 = {
      name: 'ɵɵattributeInterpolate2',
      moduleName: CORE$1
    };
    Identifiers$1.attributeInterpolate3 = {
      name: 'ɵɵattributeInterpolate3',
      moduleName: CORE$1
    };
    Identifiers$1.attributeInterpolate4 = {
      name: 'ɵɵattributeInterpolate4',
      moduleName: CORE$1
    };
    Identifiers$1.attributeInterpolate5 = {
      name: 'ɵɵattributeInterpolate5',
      moduleName: CORE$1
    };
    Identifiers$1.attributeInterpolate6 = {
      name: 'ɵɵattributeInterpolate6',
      moduleName: CORE$1
    };
    Identifiers$1.attributeInterpolate7 = {
      name: 'ɵɵattributeInterpolate7',
      moduleName: CORE$1
    };
    Identifiers$1.attributeInterpolate8 = {
      name: 'ɵɵattributeInterpolate8',
      moduleName: CORE$1
    };
    Identifiers$1.attributeInterpolateV = {
      name: 'ɵɵattributeInterpolateV',
      moduleName: CORE$1
    };
    Identifiers$1.classProp = {
      name: 'ɵɵclassProp',
      moduleName: CORE$1
    };
    Identifiers$1.elementContainerStart = {
      name: 'ɵɵelementContainerStart',
      moduleName: CORE$1
    };
    Identifiers$1.elementContainerEnd = {
      name: 'ɵɵelementContainerEnd',
      moduleName: CORE$1
    };
    Identifiers$1.elementContainer = {
      name: 'ɵɵelementContainer',
      moduleName: CORE$1
    };
    Identifiers$1.styleMap = {
      name: 'ɵɵstyleMap',
      moduleName: CORE$1
    };
    Identifiers$1.styleMapInterpolate1 = {
      name: 'ɵɵstyleMapInterpolate1',
      moduleName: CORE$1
    };
    Identifiers$1.styleMapInterpolate2 = {
      name: 'ɵɵstyleMapInterpolate2',
      moduleName: CORE$1
    };
    Identifiers$1.styleMapInterpolate3 = {
      name: 'ɵɵstyleMapInterpolate3',
      moduleName: CORE$1
    };
    Identifiers$1.styleMapInterpolate4 = {
      name: 'ɵɵstyleMapInterpolate4',
      moduleName: CORE$1
    };
    Identifiers$1.styleMapInterpolate5 = {
      name: 'ɵɵstyleMapInterpolate5',
      moduleName: CORE$1
    };
    Identifiers$1.styleMapInterpolate6 = {
      name: 'ɵɵstyleMapInterpolate6',
      moduleName: CORE$1
    };
    Identifiers$1.styleMapInterpolate7 = {
      name: 'ɵɵstyleMapInterpolate7',
      moduleName: CORE$1
    };
    Identifiers$1.styleMapInterpolate8 = {
      name: 'ɵɵstyleMapInterpolate8',
      moduleName: CORE$1
    };
    Identifiers$1.styleMapInterpolateV = {
      name: 'ɵɵstyleMapInterpolateV',
      moduleName: CORE$1
    };
    Identifiers$1.classMap = {
      name: 'ɵɵclassMap',
      moduleName: CORE$1
    };
    Identifiers$1.classMapInterpolate1 = {
      name: 'ɵɵclassMapInterpolate1',
      moduleName: CORE$1
    };
    Identifiers$1.classMapInterpolate2 = {
      name: 'ɵɵclassMapInterpolate2',
      moduleName: CORE$1
    };
    Identifiers$1.classMapInterpolate3 = {
      name: 'ɵɵclassMapInterpolate3',
      moduleName: CORE$1
    };
    Identifiers$1.classMapInterpolate4 = {
      name: 'ɵɵclassMapInterpolate4',
      moduleName: CORE$1
    };
    Identifiers$1.classMapInterpolate5 = {
      name: 'ɵɵclassMapInterpolate5',
      moduleName: CORE$1
    };
    Identifiers$1.classMapInterpolate6 = {
      name: 'ɵɵclassMapInterpolate6',
      moduleName: CORE$1
    };
    Identifiers$1.classMapInterpolate7 = {
      name: 'ɵɵclassMapInterpolate7',
      moduleName: CORE$1
    };
    Identifiers$1.classMapInterpolate8 = {
      name: 'ɵɵclassMapInterpolate8',
      moduleName: CORE$1
    };
    Identifiers$1.classMapInterpolateV = {
      name: 'ɵɵclassMapInterpolateV',
      moduleName: CORE$1
    };
    Identifiers$1.styleProp = {
      name: 'ɵɵstyleProp',
      moduleName: CORE$1
    };
    Identifiers$1.stylePropInterpolate1 = {
      name: 'ɵɵstylePropInterpolate1',
      moduleName: CORE$1
    };
    Identifiers$1.stylePropInterpolate2 = {
      name: 'ɵɵstylePropInterpolate2',
      moduleName: CORE$1
    };
    Identifiers$1.stylePropInterpolate3 = {
      name: 'ɵɵstylePropInterpolate3',
      moduleName: CORE$1
    };
    Identifiers$1.stylePropInterpolate4 = {
      name: 'ɵɵstylePropInterpolate4',
      moduleName: CORE$1
    };
    Identifiers$1.stylePropInterpolate5 = {
      name: 'ɵɵstylePropInterpolate5',
      moduleName: CORE$1
    };
    Identifiers$1.stylePropInterpolate6 = {
      name: 'ɵɵstylePropInterpolate6',
      moduleName: CORE$1
    };
    Identifiers$1.stylePropInterpolate7 = {
      name: 'ɵɵstylePropInterpolate7',
      moduleName: CORE$1
    };
    Identifiers$1.stylePropInterpolate8 = {
      name: 'ɵɵstylePropInterpolate8',
      moduleName: CORE$1
    };
    Identifiers$1.stylePropInterpolateV = {
      name: 'ɵɵstylePropInterpolateV',
      moduleName: CORE$1
    };
    Identifiers$1.containerCreate = {
      name: 'ɵɵcontainer',
      moduleName: CORE$1
    };
    Identifiers$1.nextContext = {
      name: 'ɵɵnextContext',
      moduleName: CORE$1
    };
    Identifiers$1.templateCreate = {
      name: 'ɵɵtemplate',
      moduleName: CORE$1
    };
    Identifiers$1.text = {
      name: 'ɵɵtext',
      moduleName: CORE$1
    };
    Identifiers$1.enableBindings = {
      name: 'ɵɵenableBindings',
      moduleName: CORE$1
    };
    Identifiers$1.disableBindings = {
      name: 'ɵɵdisableBindings',
      moduleName: CORE$1
    };
    Identifiers$1.getCurrentView = {
      name: 'ɵɵgetCurrentView',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolate = {
      name: 'ɵɵtextInterpolate',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolate1 = {
      name: 'ɵɵtextInterpolate1',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolate2 = {
      name: 'ɵɵtextInterpolate2',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolate3 = {
      name: 'ɵɵtextInterpolate3',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolate4 = {
      name: 'ɵɵtextInterpolate4',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolate5 = {
      name: 'ɵɵtextInterpolate5',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolate6 = {
      name: 'ɵɵtextInterpolate6',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolate7 = {
      name: 'ɵɵtextInterpolate7',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolate8 = {
      name: 'ɵɵtextInterpolate8',
      moduleName: CORE$1
    };
    Identifiers$1.textInterpolateV = {
      name: 'ɵɵtextInterpolateV',
      moduleName: CORE$1
    };
    Identifiers$1.restoreView = {
      name: 'ɵɵrestoreView',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunction0 = {
      name: 'ɵɵpureFunction0',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunction1 = {
      name: 'ɵɵpureFunction1',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunction2 = {
      name: 'ɵɵpureFunction2',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunction3 = {
      name: 'ɵɵpureFunction3',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunction4 = {
      name: 'ɵɵpureFunction4',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunction5 = {
      name: 'ɵɵpureFunction5',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunction6 = {
      name: 'ɵɵpureFunction6',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunction7 = {
      name: 'ɵɵpureFunction7',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunction8 = {
      name: 'ɵɵpureFunction8',
      moduleName: CORE$1
    };
    Identifiers$1.pureFunctionV = {
      name: 'ɵɵpureFunctionV',
      moduleName: CORE$1
    };
    Identifiers$1.pipeBind1 = {
      name: 'ɵɵpipeBind1',
      moduleName: CORE$1
    };
    Identifiers$1.pipeBind2 = {
      name: 'ɵɵpipeBind2',
      moduleName: CORE$1
    };
    Identifiers$1.pipeBind3 = {
      name: 'ɵɵpipeBind3',
      moduleName: CORE$1
    };
    Identifiers$1.pipeBind4 = {
      name: 'ɵɵpipeBind4',
      moduleName: CORE$1
    };
    Identifiers$1.pipeBindV = {
      name: 'ɵɵpipeBindV',
      moduleName: CORE$1
    };
    Identifiers$1.hostProperty = {
      name: 'ɵɵhostProperty',
      moduleName: CORE$1
    };
    Identifiers$1.property = {
      name: 'ɵɵproperty',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolate = {
      name: 'ɵɵpropertyInterpolate',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolate1 = {
      name: 'ɵɵpropertyInterpolate1',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolate2 = {
      name: 'ɵɵpropertyInterpolate2',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolate3 = {
      name: 'ɵɵpropertyInterpolate3',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolate4 = {
      name: 'ɵɵpropertyInterpolate4',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolate5 = {
      name: 'ɵɵpropertyInterpolate5',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolate6 = {
      name: 'ɵɵpropertyInterpolate6',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolate7 = {
      name: 'ɵɵpropertyInterpolate7',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolate8 = {
      name: 'ɵɵpropertyInterpolate8',
      moduleName: CORE$1
    };
    Identifiers$1.propertyInterpolateV = {
      name: 'ɵɵpropertyInterpolateV',
      moduleName: CORE$1
    };
    Identifiers$1.i18n = {
      name: 'ɵɵi18n',
      moduleName: CORE$1
    };
    Identifiers$1.i18nAttributes = {
      name: 'ɵɵi18nAttributes',
      moduleName: CORE$1
    };
    Identifiers$1.i18nExp = {
      name: 'ɵɵi18nExp',
      moduleName: CORE$1
    };
    Identifiers$1.i18nStart = {
      name: 'ɵɵi18nStart',
      moduleName: CORE$1
    };
    Identifiers$1.i18nEnd = {
      name: 'ɵɵi18nEnd',
      moduleName: CORE$1
    };
    Identifiers$1.i18nApply = {
      name: 'ɵɵi18nApply',
      moduleName: CORE$1
    };
    Identifiers$1.i18nPostprocess = {
      name: 'ɵɵi18nPostprocess',
      moduleName: CORE$1
    };
    Identifiers$1.pipe = {
      name: 'ɵɵpipe',
      moduleName: CORE$1
    };
    Identifiers$1.projection = {
      name: 'ɵɵprojection',
      moduleName: CORE$1
    };
    Identifiers$1.projectionDef = {
      name: 'ɵɵprojectionDef',
      moduleName: CORE$1
    };
    Identifiers$1.reference = {
      name: 'ɵɵreference',
      moduleName: CORE$1
    };
    Identifiers$1.inject = {
      name: 'ɵɵinject',
      moduleName: CORE$1
    };
    Identifiers$1.injectAttribute = {
      name: 'ɵɵinjectAttribute',
      moduleName: CORE$1
    };
    Identifiers$1.injectPipeChangeDetectorRef = {
      name: 'ɵɵinjectPipeChangeDetectorRef',
      moduleName: CORE$1
    };
    Identifiers$1.directiveInject = {
      name: 'ɵɵdirectiveInject',
      moduleName: CORE$1
    };
    Identifiers$1.invalidFactory = {
      name: 'ɵɵinvalidFactory',
      moduleName: CORE$1
    };
    Identifiers$1.invalidFactoryDep = {
      name: 'ɵɵinvalidFactoryDep',
      moduleName: CORE$1
    };
    Identifiers$1.templateRefExtractor = {
      name: 'ɵɵtemplateRefExtractor',
      moduleName: CORE$1
    };
    Identifiers$1.resolveWindow = {
      name: 'ɵɵresolveWindow',
      moduleName: CORE$1
    };
    Identifiers$1.resolveDocument = {
      name: 'ɵɵresolveDocument',
      moduleName: CORE$1
    };
    Identifiers$1.resolveBody = {
      name: 'ɵɵresolveBody',
      moduleName: CORE$1
    };
    Identifiers$1.defineComponent = {
      name: 'ɵɵdefineComponent',
      moduleName: CORE$1
    };
    Identifiers$1.setComponentScope = {
      name: 'ɵɵsetComponentScope',
      moduleName: CORE$1
    };
    Identifiers$1.ComponentDefWithMeta = {
      name: 'ɵɵComponentDefWithMeta',
      moduleName: CORE$1
    };
    Identifiers$1.FactoryDef = {
      name: 'ɵɵFactoryDef',
      moduleName: CORE$1
    };
    Identifiers$1.defineDirective = {
      name: 'ɵɵdefineDirective',
      moduleName: CORE$1
    };
    Identifiers$1.DirectiveDefWithMeta = {
      name: 'ɵɵDirectiveDefWithMeta',
      moduleName: CORE$1
    };
    Identifiers$1.InjectorDef = {
      name: 'ɵɵInjectorDef',
      moduleName: CORE$1
    };
    Identifiers$1.defineInjector = {
      name: 'ɵɵdefineInjector',
      moduleName: CORE$1
    };
    Identifiers$1.NgModuleDefWithMeta = {
      name: 'ɵɵNgModuleDefWithMeta',
      moduleName: CORE$1
    };
    Identifiers$1.ModuleWithProviders = {
      name: 'ModuleWithProviders',
      moduleName: CORE$1
    };
    Identifiers$1.defineNgModule = {
      name: 'ɵɵdefineNgModule',
      moduleName: CORE$1
    };
    Identifiers$1.setNgModuleScope = {
      name: 'ɵɵsetNgModuleScope',
      moduleName: CORE$1
    };
    Identifiers$1.PipeDefWithMeta = {
      name: 'ɵɵPipeDefWithMeta',
      moduleName: CORE$1
    };
    Identifiers$1.definePipe = {
      name: 'ɵɵdefinePipe',
      moduleName: CORE$1
    };
    Identifiers$1.queryRefresh = {
      name: 'ɵɵqueryRefresh',
      moduleName: CORE$1
    };
    Identifiers$1.viewQuery = {
      name: 'ɵɵviewQuery',
      moduleName: CORE$1
    };
    Identifiers$1.staticViewQuery = {
      name: 'ɵɵstaticViewQuery',
      moduleName: CORE$1
    };
    Identifiers$1.staticContentQuery = {
      name: 'ɵɵstaticContentQuery',
      moduleName: CORE$1
    };
    Identifiers$1.loadQuery = {
      name: 'ɵɵloadQuery',
      moduleName: CORE$1
    };
    Identifiers$1.contentQuery = {
      name: 'ɵɵcontentQuery',
      moduleName: CORE$1
    };
    Identifiers$1.NgOnChangesFeature = {
      name: 'ɵɵNgOnChangesFeature',
      moduleName: CORE$1
    };
    Identifiers$1.InheritDefinitionFeature = {
      name: 'ɵɵInheritDefinitionFeature',
      moduleName: CORE$1
    };
    Identifiers$1.CopyDefinitionFeature = {
      name: 'ɵɵCopyDefinitionFeature',
      moduleName: CORE$1
    };
    Identifiers$1.ProvidersFeature = {
      name: 'ɵɵProvidersFeature',
      moduleName: CORE$1
    };
    Identifiers$1.listener = {
      name: 'ɵɵlistener',
      moduleName: CORE$1
    };
    Identifiers$1.getFactoryOf = {
      name: 'ɵɵgetFactoryOf',
      moduleName: CORE$1
    };
    Identifiers$1.getInheritedFactory = {
      name: 'ɵɵgetInheritedFactory',
      moduleName: CORE$1
    }; // sanitization-related functions

    Identifiers$1.sanitizeHtml = {
      name: 'ɵɵsanitizeHtml',
      moduleName: CORE$1
    };
    Identifiers$1.sanitizeStyle = {
      name: 'ɵɵsanitizeStyle',
      moduleName: CORE$1
    };
    Identifiers$1.defaultStyleSanitizer = {
      name: 'ɵɵdefaultStyleSanitizer',
      moduleName: CORE$1
    };
    Identifiers$1.sanitizeResourceUrl = {
      name: 'ɵɵsanitizeResourceUrl',
      moduleName: CORE$1
    };
    Identifiers$1.sanitizeScript = {
      name: 'ɵɵsanitizeScript',
      moduleName: CORE$1
    };
    Identifiers$1.sanitizeUrl = {
      name: 'ɵɵsanitizeUrl',
      moduleName: CORE$1
    };
    Identifiers$1.sanitizeUrlOrResourceUrl = {
      name: 'ɵɵsanitizeUrlOrResourceUrl',
      moduleName: CORE$1
    };
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Convert an object map with `Expression` values into a `LiteralMapExpr`.
     */

    function mapToMapExpression(map) {
      var result = Object.keys(map).map(function (key) {
        return {
          key: key,
          // The assertion here is because really TypeScript doesn't allow us to express that if the
          // key is present, it will have a value, but this is true in reality.
          value: map[key],
          quoted: false
        };
      });
      return literalMap(result);
    }
    /**
     * Convert metadata into an `Expression` in the given `OutputContext`.
     *
     * This operation will handle arrays, references to symbols, or literal `null` or `undefined`.
     */


    function convertMetaToOutput(meta, ctx) {
      if (Array.isArray(meta)) {
        return literalArr(meta.map(function (entry) {
          return convertMetaToOutput(entry, ctx);
        }));
      }

      if (meta instanceof StaticSymbol) {
        return ctx.importExpr(meta);
      }

      if (meta == null) {
        return literal(meta);
      }

      throw new Error("Internal error: Unsupported or unknown metadata: ".concat(meta));
    }

    function typeWithParameters(type, numParams) {
      var params = null;

      if (numParams > 0) {
        params = [];

        for (var i = 0; i < numParams; i++) {
          params.push(DYNAMIC_TYPE);
        }
      }

      return expressionType(type, null, params);
    }

    var ANIMATE_SYMBOL_PREFIX = '@';

    function prepareSyntheticPropertyName(name) {
      return "".concat(ANIMATE_SYMBOL_PREFIX).concat(name);
    }

    function prepareSyntheticListenerName(name, phase) {
      return "".concat(ANIMATE_SYMBOL_PREFIX).concat(name, ".").concat(phase);
    }

    function isSyntheticPropertyOrListener(name) {
      return name.charAt(0) == ANIMATE_SYMBOL_PREFIX;
    }

    function getSyntheticPropertyName(name) {
      // this will strip out listener phase values...
      // @foo.start => @foo
      var i = name.indexOf('.');
      name = i > 0 ? name.substring(0, i) : name;

      if (name.charAt(0) !== ANIMATE_SYMBOL_PREFIX) {
        name = ANIMATE_SYMBOL_PREFIX + name;
      }

      return name;
    }

    function prepareSyntheticListenerFunctionName(name, phase) {
      return "animation_".concat(name, "_").concat(phase);
    }

    function jitOnlyGuardedExpression(expr) {
      var ngJitMode = new ExternalExpr({
        name: 'ngJitMode',
        moduleName: null
      });
      var jitFlagNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(ngJitMode), literal('undefined'));
      var jitFlagUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, jitFlagNotDefined, ngJitMode,
      /* type */
      undefined,
      /* sourceSpan */
      undefined, true);
      return new BinaryOperatorExpr(BinaryOperator.And, jitFlagUndefinedOrTrue, expr);
    }

    function wrapReference(value) {
      var wrapped = new WrappedNodeExpr(value);
      return {
        value: wrapped,
        type: wrapped
      };
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var $EOF = 0;
    var $BSPACE = 8;
    var $TAB = 9;
    var $LF = 10;
    var $VTAB = 11;
    var $FF = 12;
    var $CR = 13;
    var $SPACE = 32;
    var $BANG = 33;
    var $DQ = 34;
    var $HASH = 35;
    var $$ = 36;
    var $PERCENT = 37;
    var $AMPERSAND = 38;
    var $SQ = 39;
    var $LPAREN = 40;
    var $RPAREN = 41;
    var $STAR = 42;
    var $PLUS = 43;
    var $COMMA = 44;
    var $MINUS = 45;
    var $PERIOD = 46;
    var $SLASH = 47;
    var $COLON = 58;
    var $SEMICOLON = 59;
    var $LT = 60;
    var $EQ = 61;
    var $GT = 62;
    var $QUESTION = 63;
    var $0 = 48;
    var $7 = 55;
    var $9 = 57;
    var $A = 65;
    var $E = 69;
    var $F = 70;
    var $X = 88;
    var $Z = 90;
    var $LBRACKET = 91;
    var $BACKSLASH = 92;
    var $RBRACKET = 93;
    var $CARET = 94;
    var $_ = 95;
    var $a = 97;
    var $b = 98;
    var $e = 101;
    var $f = 102;
    var $n = 110;
    var $r = 114;
    var $t = 116;
    var $u = 117;
    var $v = 118;
    var $x = 120;
    var $z = 122;
    var $LBRACE = 123;
    var $BAR = 124;
    var $RBRACE = 125;
    var $NBSP = 160;
    var $PIPE = 124;
    var $TILDA = 126;
    var $AT = 64;
    var $BT = 96;

    function isWhitespace(code) {
      return code >= $TAB && code <= $SPACE || code == $NBSP;
    }

    function isDigit(code) {
      return $0 <= code && code <= $9;
    }

    function isAsciiLetter(code) {
      return code >= $a && code <= $z || code >= $A && code <= $Z;
    }

    function isAsciiHexDigit(code) {
      return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
    }

    function isNewLine(code) {
      return code === $LF || code === $CR;
    }

    function isOctalDigit(code) {
      return $0 <= code && code <= $7;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var ParseLocation =
    /*#__PURE__*/
    function () {
      function ParseLocation(file, offset, line, col) {
        _classCallCheck(this, ParseLocation);

        this.file = file;
        this.offset = offset;
        this.line = line;
        this.col = col;
      }

      _createClass(ParseLocation, [{
        key: "toString",
        value: function toString() {
          return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
        }
      }, {
        key: "moveBy",
        value: function moveBy(delta) {
          var source = this.file.content;
          var len = source.length;
          var offset = this.offset;
          var line = this.line;
          var col = this.col;

          while (offset > 0 && delta < 0) {
            offset--;
            delta++;
            var ch = source.charCodeAt(offset);

            if (ch == $LF) {
              line--;
              var priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
              col = priorLine > 0 ? offset - priorLine : offset;
            } else {
              col--;
            }
          }

          while (offset < len && delta > 0) {
            var _ch = source.charCodeAt(offset);

            offset++;
            delta--;

            if (_ch == $LF) {
              line++;
              col = 0;
            } else {
              col++;
            }
          }

          return new ParseLocation(this.file, offset, line, col);
        } // Return the source around the location
        // Up to `maxChars` or `maxLines` on each side of the location

      }, {
        key: "getContext",
        value: function getContext(maxChars, maxLines) {
          var content = this.file.content;
          var startOffset = this.offset;

          if (startOffset != null) {
            if (startOffset > content.length - 1) {
              startOffset = content.length - 1;
            }

            var endOffset = startOffset;
            var ctxChars = 0;
            var ctxLines = 0;

            while (ctxChars < maxChars && startOffset > 0) {
              startOffset--;
              ctxChars++;

              if (content[startOffset] == '\n') {
                if (++ctxLines == maxLines) {
                  break;
                }
              }
            }

            ctxChars = 0;
            ctxLines = 0;

            while (ctxChars < maxChars && endOffset < content.length - 1) {
              endOffset++;
              ctxChars++;

              if (content[endOffset] == '\n') {
                if (++ctxLines == maxLines) {
                  break;
                }
              }
            }

            return {
              before: content.substring(startOffset, this.offset),
              after: content.substring(this.offset, endOffset + 1)
            };
          }

          return null;
        }
      }]);

      return ParseLocation;
    }();

    var ParseSourceFile = function ParseSourceFile(content, url) {
      _classCallCheck(this, ParseSourceFile);

      this.content = content;
      this.url = url;
    };

    var ParseSourceSpan =
    /*#__PURE__*/
    function () {
      function ParseSourceSpan(start, end) {
        var details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        _classCallCheck(this, ParseSourceSpan);

        this.start = start;
        this.end = end;
        this.details = details;
      }

      _createClass(ParseSourceSpan, [{
        key: "toString",
        value: function toString() {
          return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
      }]);

      return ParseSourceSpan;
    }();

    var EMPTY_PARSE_LOCATION = new ParseLocation(new ParseSourceFile('', ''), 0, 0, 0);
    var EMPTY_SOURCE_SPAN = new ParseSourceSpan(EMPTY_PARSE_LOCATION, EMPTY_PARSE_LOCATION);
    var ParseErrorLevel;

    (function (ParseErrorLevel) {
      ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
      ParseErrorLevel[ParseErrorLevel["ERROR"] = 1] = "ERROR";
    })(ParseErrorLevel || (ParseErrorLevel = {}));

    var ParseError =
    /*#__PURE__*/
    function () {
      function ParseError(span, msg) {
        var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;

        _classCallCheck(this, ParseError);

        this.span = span;
        this.msg = msg;
        this.level = level;
      }

      _createClass(ParseError, [{
        key: "contextualMessage",
        value: function contextualMessage() {
          var ctx = this.span.start.getContext(100, 3);
          return ctx ? "".concat(this.msg, " (\"").concat(ctx.before, "[").concat(ParseErrorLevel[this.level], " ->]").concat(ctx.after, "\")") : this.msg;
        }
      }, {
        key: "toString",
        value: function toString() {
          var details = this.span.details ? ", ".concat(this.span.details) : '';
          return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(details);
        }
      }]);

      return ParseError;
    }();

    function typeSourceSpan(kind, type) {
      var moduleUrl = identifierModuleUrl(type);
      var sourceFileName = moduleUrl != null ? "in ".concat(kind, " ").concat(identifierName(type), " in ").concat(moduleUrl) : "in ".concat(kind, " ").concat(identifierName(type));
      var sourceFile = new ParseSourceFile('', sourceFileName);
      return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
    }
    /**
     * Generates Source Span object for a given R3 Type for JIT mode.
     *
     * @param kind Component or Directive.
     * @param typeName name of the Component or Directive.
     * @param sourceUrl reference to Component or Directive source.
     * @returns instance of ParseSourceSpan that represent a given Component or Directive.
     */


    function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {
      var sourceFileName = "in ".concat(kind, " ").concat(typeName, " in ").concat(sourceUrl);
      var sourceFile = new ParseSourceFile('', sourceFileName);
      return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var Text =
    /*#__PURE__*/
    function () {
      function Text(value, sourceSpan) {
        _classCallCheck(this, Text);

        this.value = value;
        this.sourceSpan = sourceSpan;
      }

      _createClass(Text, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitText(this);
        }
      }]);

      return Text;
    }();

    var BoundText =
    /*#__PURE__*/
    function () {
      function BoundText(value, sourceSpan, i18n) {
        _classCallCheck(this, BoundText);

        this.value = value;
        this.sourceSpan = sourceSpan;
        this.i18n = i18n;
      }

      _createClass(BoundText, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitBoundText(this);
        }
      }]);

      return BoundText;
    }();

    var TextAttribute =
    /*#__PURE__*/
    function () {
      function TextAttribute(name, value, sourceSpan, valueSpan, i18n) {
        _classCallCheck(this, TextAttribute);

        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
        this.valueSpan = valueSpan;
        this.i18n = i18n;
      }

      _createClass(TextAttribute, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitTextAttribute(this);
        }
      }]);

      return TextAttribute;
    }();

    var BoundAttribute =
    /*#__PURE__*/
    function () {
      function BoundAttribute(name, type, securityContext, value, unit, sourceSpan, valueSpan, i18n) {
        _classCallCheck(this, BoundAttribute);

        this.name = name;
        this.type = type;
        this.securityContext = securityContext;
        this.value = value;
        this.unit = unit;
        this.sourceSpan = sourceSpan;
        this.valueSpan = valueSpan;
        this.i18n = i18n;
      }

      _createClass(BoundAttribute, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitBoundAttribute(this);
        }
      }], [{
        key: "fromBoundElementProperty",
        value: function fromBoundElementProperty(prop, i18n) {
          return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.valueSpan, i18n);
        }
      }]);

      return BoundAttribute;
    }();

    var BoundEvent =
    /*#__PURE__*/
    function () {
      function BoundEvent(name, type, handler, target, phase, sourceSpan, handlerSpan) {
        _classCallCheck(this, BoundEvent);

        this.name = name;
        this.type = type;
        this.handler = handler;
        this.target = target;
        this.phase = phase;
        this.sourceSpan = sourceSpan;
        this.handlerSpan = handlerSpan;
      }

      _createClass(BoundEvent, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitBoundEvent(this);
        }
      }], [{
        key: "fromParsedEvent",
        value: function fromParsedEvent(event) {
          var target = event.type === 0
          /* Regular */
          ? event.targetOrPhase : null;
          var phase = event.type === 1
          /* Animation */
          ? event.targetOrPhase : null;
          return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan);
        }
      }]);

      return BoundEvent;
    }();

    var Element =
    /*#__PURE__*/
    function () {
      function Element(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
        _classCallCheck(this, Element);

        this.name = name;
        this.attributes = attributes;
        this.inputs = inputs;
        this.outputs = outputs;
        this.children = children;
        this.references = references;
        this.sourceSpan = sourceSpan;
        this.startSourceSpan = startSourceSpan;
        this.endSourceSpan = endSourceSpan;
        this.i18n = i18n; // If the element is empty then the source span should include any closing tag

        if (children.length === 0 && startSourceSpan && endSourceSpan) {
          this.sourceSpan = new ParseSourceSpan(sourceSpan.start, endSourceSpan.end);
        }
      }

      _createClass(Element, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitElement(this);
        }
      }]);

      return Element;
    }();

    var Template =
    /*#__PURE__*/
    function () {
      function Template(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
        _classCallCheck(this, Template);

        this.tagName = tagName;
        this.attributes = attributes;
        this.inputs = inputs;
        this.outputs = outputs;
        this.templateAttrs = templateAttrs;
        this.children = children;
        this.references = references;
        this.variables = variables;
        this.sourceSpan = sourceSpan;
        this.startSourceSpan = startSourceSpan;
        this.endSourceSpan = endSourceSpan;
        this.i18n = i18n;
      }

      _createClass(Template, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitTemplate(this);
        }
      }]);

      return Template;
    }();

    var Content =
    /*#__PURE__*/
    function () {
      function Content(selector, attributes, sourceSpan, i18n) {
        _classCallCheck(this, Content);

        this.selector = selector;
        this.attributes = attributes;
        this.sourceSpan = sourceSpan;
        this.i18n = i18n;
      }

      _createClass(Content, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitContent(this);
        }
      }]);

      return Content;
    }();

    var Variable =
    /*#__PURE__*/
    function () {
      function Variable(name, value, sourceSpan, valueSpan) {
        _classCallCheck(this, Variable);

        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
        this.valueSpan = valueSpan;
      }

      _createClass(Variable, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitVariable(this);
        }
      }]);

      return Variable;
    }();

    var Reference =
    /*#__PURE__*/
    function () {
      function Reference(name, value, sourceSpan, valueSpan) {
        _classCallCheck(this, Reference);

        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
        this.valueSpan = valueSpan;
      }

      _createClass(Reference, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitReference(this);
        }
      }]);

      return Reference;
    }();

    var Icu =
    /*#__PURE__*/
    function () {
      function Icu(vars, placeholders, sourceSpan, i18n) {
        _classCallCheck(this, Icu);

        this.vars = vars;
        this.placeholders = placeholders;
        this.sourceSpan = sourceSpan;
        this.i18n = i18n;
      }

      _createClass(Icu, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitIcu(this);
        }
      }]);

      return Icu;
    }();

    var NullVisitor =
    /*#__PURE__*/
    function () {
      function NullVisitor() {
        _classCallCheck(this, NullVisitor);
      }

      _createClass(NullVisitor, [{
        key: "visitElement",
        value: function visitElement(element) {}
      }, {
        key: "visitTemplate",
        value: function visitTemplate(template) {}
      }, {
        key: "visitContent",
        value: function visitContent(content) {}
      }, {
        key: "visitVariable",
        value: function visitVariable(variable) {}
      }, {
        key: "visitReference",
        value: function visitReference(reference) {}
      }, {
        key: "visitTextAttribute",
        value: function visitTextAttribute(attribute) {}
      }, {
        key: "visitBoundAttribute",
        value: function visitBoundAttribute(attribute) {}
      }, {
        key: "visitBoundEvent",
        value: function visitBoundEvent(attribute) {}
      }, {
        key: "visitText",
        value: function visitText(text) {}
      }, {
        key: "visitBoundText",
        value: function visitBoundText(text) {}
      }, {
        key: "visitIcu",
        value: function visitIcu(icu) {}
      }]);

      return NullVisitor;
    }();

    var RecursiveVisitor =
    /*#__PURE__*/
    function () {
      function RecursiveVisitor() {
        _classCallCheck(this, RecursiveVisitor);
      }

      _createClass(RecursiveVisitor, [{
        key: "visitElement",
        value: function visitElement(element) {
          visitAll(this, element.attributes);
          visitAll(this, element.children);
          visitAll(this, element.references);
        }
      }, {
        key: "visitTemplate",
        value: function visitTemplate(template) {
          visitAll(this, template.attributes);
          visitAll(this, template.children);
          visitAll(this, template.references);
          visitAll(this, template.variables);
        }
      }, {
        key: "visitContent",
        value: function visitContent(content) {}
      }, {
        key: "visitVariable",
        value: function visitVariable(variable) {}
      }, {
        key: "visitReference",
        value: function visitReference(reference) {}
      }, {
        key: "visitTextAttribute",
        value: function visitTextAttribute(attribute) {}
      }, {
        key: "visitBoundAttribute",
        value: function visitBoundAttribute(attribute) {}
      }, {
        key: "visitBoundEvent",
        value: function visitBoundEvent(attribute) {}
      }, {
        key: "visitText",
        value: function visitText(text) {}
      }, {
        key: "visitBoundText",
        value: function visitBoundText(text) {}
      }, {
        key: "visitIcu",
        value: function visitIcu(icu) {}
      }]);

      return RecursiveVisitor;
    }();

    var TransformVisitor =
    /*#__PURE__*/
    function () {
      function TransformVisitor() {
        _classCallCheck(this, TransformVisitor);
      }

      _createClass(TransformVisitor, [{
        key: "visitElement",
        value: function visitElement(element) {
          var newAttributes = transformAll(this, element.attributes);
          var newInputs = transformAll(this, element.inputs);
          var newOutputs = transformAll(this, element.outputs);
          var newChildren = transformAll(this, element.children);
          var newReferences = transformAll(this, element.references);

          if (newAttributes != element.attributes || newInputs != element.inputs || newOutputs != element.outputs || newChildren != element.children || newReferences != element.references) {
            return new Element(element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
          }

          return element;
        }
      }, {
        key: "visitTemplate",
        value: function visitTemplate(template) {
          var newAttributes = transformAll(this, template.attributes);
          var newInputs = transformAll(this, template.inputs);
          var newOutputs = transformAll(this, template.outputs);
          var newTemplateAttrs = transformAll(this, template.templateAttrs);
          var newChildren = transformAll(this, template.children);
          var newReferences = transformAll(this, template.references);
          var newVariables = transformAll(this, template.variables);

          if (newAttributes != template.attributes || newInputs != template.inputs || newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs || newChildren != template.children || newReferences != template.references || newVariables != template.variables) {
            return new Template(template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren, newReferences, newVariables, template.sourceSpan, template.startSourceSpan, template.endSourceSpan);
          }

          return template;
        }
      }, {
        key: "visitContent",
        value: function visitContent(content) {
          return content;
        }
      }, {
        key: "visitVariable",
        value: function visitVariable(variable) {
          return variable;
        }
      }, {
        key: "visitReference",
        value: function visitReference(reference) {
          return reference;
        }
      }, {
        key: "visitTextAttribute",
        value: function visitTextAttribute(attribute) {
          return attribute;
        }
      }, {
        key: "visitBoundAttribute",
        value: function visitBoundAttribute(attribute) {
          return attribute;
        }
      }, {
        key: "visitBoundEvent",
        value: function visitBoundEvent(attribute) {
          return attribute;
        }
      }, {
        key: "visitText",
        value: function visitText(text) {
          return text;
        }
      }, {
        key: "visitBoundText",
        value: function visitBoundText(text) {
          return text;
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu) {
          return icu;
        }
      }]);

      return TransformVisitor;
    }();

    function visitAll(visitor, nodes) {
      var result = [];

      if (visitor.visit) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var node = _step2.value;
            var newNode = visitor.visit(node) || node.visit(visitor);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _node = _step3.value;

            var _newNode = _node.visit(visitor);

            if (_newNode) {
              result.push(_newNode);
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      return result;
    }

    function transformAll(visitor, nodes) {
      var result = [];
      var changed = false;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = nodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var node = _step4.value;
          var newNode = node.visit(visitor);

          if (newNode) {
            result.push(newNode);
          }

          changed = changed || newNode != node;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return changed ? result : nodes;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var Message =
    /**
     * @param nodes message AST
     * @param placeholders maps placeholder names to static content
     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)
     * @param meaning
     * @param description
     * @param customId
     */
    function Message(nodes, placeholders, placeholderToMessage, meaning, description, customId) {
      _classCallCheck(this, Message);

      this.nodes = nodes;
      this.placeholders = placeholders;
      this.placeholderToMessage = placeholderToMessage;
      this.meaning = meaning;
      this.description = description;
      this.customId = customId;
      this.id = this.customId;
      /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */

      this.legacyIds = [];

      if (nodes.length) {
        this.sources = [{
          filePath: nodes[0].sourceSpan.start.file.url,
          startLine: nodes[0].sourceSpan.start.line + 1,
          startCol: nodes[0].sourceSpan.start.col + 1,
          endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
          endCol: nodes[0].sourceSpan.start.col + 1
        }];
      } else {
        this.sources = [];
      }
    };

    var Text$1 =
    /*#__PURE__*/
    function () {
      function Text$1(value, sourceSpan) {
        _classCallCheck(this, Text$1);

        this.value = value;
        this.sourceSpan = sourceSpan;
      }

      _createClass(Text$1, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitText(this, context);
        }
      }]);

      return Text$1;
    }(); // TODO(vicb): do we really need this node (vs an array) ?


    var Container =
    /*#__PURE__*/
    function () {
      function Container(children, sourceSpan) {
        _classCallCheck(this, Container);

        this.children = children;
        this.sourceSpan = sourceSpan;
      }

      _createClass(Container, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitContainer(this, context);
        }
      }]);

      return Container;
    }();

    var Icu$1 =
    /*#__PURE__*/
    function () {
      function Icu$1(expression, type, cases, sourceSpan) {
        _classCallCheck(this, Icu$1);

        this.expression = expression;
        this.type = type;
        this.cases = cases;
        this.sourceSpan = sourceSpan;
      }

      _createClass(Icu$1, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitIcu(this, context);
        }
      }]);

      return Icu$1;
    }();

    var TagPlaceholder =
    /*#__PURE__*/
    function () {
      function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {
        _classCallCheck(this, TagPlaceholder);

        this.tag = tag;
        this.attrs = attrs;
        this.startName = startName;
        this.closeName = closeName;
        this.children = children;
        this.isVoid = isVoid;
        this.sourceSpan = sourceSpan;
      }

      _createClass(TagPlaceholder, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitTagPlaceholder(this, context);
        }
      }]);

      return TagPlaceholder;
    }();

    var Placeholder =
    /*#__PURE__*/
    function () {
      function Placeholder(value, name, sourceSpan) {
        _classCallCheck(this, Placeholder);

        this.value = value;
        this.name = name;
        this.sourceSpan = sourceSpan;
      }

      _createClass(Placeholder, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitPlaceholder(this, context);
        }
      }]);

      return Placeholder;
    }();

    var IcuPlaceholder =
    /*#__PURE__*/
    function () {
      function IcuPlaceholder(value, name, sourceSpan) {
        _classCallCheck(this, IcuPlaceholder);

        this.value = value;
        this.name = name;
        this.sourceSpan = sourceSpan;
      }

      _createClass(IcuPlaceholder, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitIcuPlaceholder(this, context);
        }
      }]);

      return IcuPlaceholder;
    }(); // Clone the AST


    var CloneVisitor =
    /*#__PURE__*/
    function () {
      function CloneVisitor() {
        _classCallCheck(this, CloneVisitor);
      }

      _createClass(CloneVisitor, [{
        key: "visitText",
        value: function visitText(text, context) {
          return new Text$1(text.value, text.sourceSpan);
        }
      }, {
        key: "visitContainer",
        value: function visitContainer(container, context) {
          var _this61 = this;

          var children = container.children.map(function (n) {
            return n.visit(_this61, context);
          });
          return new Container(children, container.sourceSpan);
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu, context) {
          var _this62 = this;

          var cases = {};
          Object.keys(icu.cases).forEach(function (key) {
            return cases[key] = icu.cases[key].visit(_this62, context);
          });
          var msg = new Icu$1(icu.expression, icu.type, cases, icu.sourceSpan);
          msg.expressionPlaceholder = icu.expressionPlaceholder;
          return msg;
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, context) {
          var _this63 = this;

          var children = ph.children.map(function (n) {
            return n.visit(_this63, context);
          });
          return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, context) {
          return new Placeholder(ph.value, ph.name, ph.sourceSpan);
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);
        }
      }]);

      return CloneVisitor;
    }(); // Visit all the nodes recursively


    var RecurseVisitor =
    /*#__PURE__*/
    function () {
      function RecurseVisitor() {
        _classCallCheck(this, RecurseVisitor);
      }

      _createClass(RecurseVisitor, [{
        key: "visitText",
        value: function visitText(text, context) {}
      }, {
        key: "visitContainer",
        value: function visitContainer(container, context) {
          var _this64 = this;

          container.children.forEach(function (child) {
            return child.visit(_this64);
          });
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu, context) {
          var _this65 = this;

          Object.keys(icu.cases).forEach(function (k) {
            icu.cases[k].visit(_this65);
          });
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, context) {
          var _this66 = this;

          ph.children.forEach(function (child) {
            return child.visit(_this66);
          });
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, context) {}
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {}
      }]);

      return RecurseVisitor;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Return the message id or compute it using the XLIFF1 digest.
     */


    function _digest2(message) {
      return message.id || computeDigest(message);
    }
    /**
     * Compute the message id using the XLIFF1 digest.
     */


    function computeDigest(message) {
      return sha1(serializeNodes(message.nodes).join('') + "[".concat(message.meaning, "]"));
    }
    /**
     * Return the message id or compute it using the XLIFF2/XMB/$localize digest.
     */


    function decimalDigest(message) {
      return message.id || computeDecimalDigest(message);
    }
    /**
     * Compute the message id using the XLIFF2/XMB/$localize digest.
     */


    function computeDecimalDigest(message) {
      var visitor = new _SerializerIgnoreIcuExpVisitor();
      var parts = message.nodes.map(function (a) {
        return a.visit(visitor, null);
      });
      return computeMsgId(parts.join(''), message.meaning);
    }
    /**
     * Serialize the i18n ast to something xml-like in order to generate an UID.
     *
     * The visitor is also used in the i18n parser tests
     *
     * @internal
     */


    var _SerializerVisitor =
    /*#__PURE__*/
    function () {
      function _SerializerVisitor() {
        _classCallCheck(this, _SerializerVisitor);
      }

      _createClass(_SerializerVisitor, [{
        key: "visitText",
        value: function visitText(text, context) {
          return text.value;
        }
      }, {
        key: "visitContainer",
        value: function visitContainer(container, context) {
          var _this67 = this;

          return "[".concat(container.children.map(function (child) {
            return child.visit(_this67);
          }).join(', '), "]");
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu, context) {
          var _this68 = this;

          var strCases = Object.keys(icu.cases).map(function (k) {
            return "".concat(k, " {").concat(icu.cases[k].visit(_this68), "}");
          });
          return "{".concat(icu.expression, ", ").concat(icu.type, ", ").concat(strCases.join(', '), "}");
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, context) {
          var _this69 = this;

          return ph.isVoid ? "<ph tag name=\"".concat(ph.startName, "\"/>") : "<ph tag name=\"".concat(ph.startName, "\">").concat(ph.children.map(function (child) {
            return child.visit(_this69);
          }).join(', '), "</ph name=\"").concat(ph.closeName, "\">");
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, context) {
          return ph.value ? "<ph name=\"".concat(ph.name, "\">").concat(ph.value, "</ph>") : "<ph name=\"".concat(ph.name, "\"/>");
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          return "<ph icu name=\"".concat(ph.name, "\">").concat(ph.value.visit(this), "</ph>");
        }
      }]);

      return _SerializerVisitor;
    }();

    var serializerVisitor = new _SerializerVisitor();

    function serializeNodes(nodes) {
      return nodes.map(function (a) {
        return a.visit(serializerVisitor, null);
      });
    }
    /**
     * Serialize the i18n ast to something xml-like in order to generate an UID.
     *
     * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.
     *
     * @internal
     */


    var _SerializerIgnoreIcuExpVisitor =
    /*#__PURE__*/
    function (_SerializerVisitor2) {
      _inherits(_SerializerIgnoreIcuExpVisitor, _SerializerVisitor2);

      function _SerializerIgnoreIcuExpVisitor() {
        _classCallCheck(this, _SerializerIgnoreIcuExpVisitor);

        return _possibleConstructorReturn(this, _getPrototypeOf(_SerializerIgnoreIcuExpVisitor).apply(this, arguments));
      }

      _createClass(_SerializerIgnoreIcuExpVisitor, [{
        key: "visitIcu",
        value: function visitIcu(icu, context) {
          var _this70 = this;

          var strCases = Object.keys(icu.cases).map(function (k) {
            return "".concat(k, " {").concat(icu.cases[k].visit(_this70), "}");
          }); // Do not take the expression into account

          return "{".concat(icu.type, ", ").concat(strCases.join(', '), "}");
        }
      }]);

      return _SerializerIgnoreIcuExpVisitor;
    }(_SerializerVisitor);
    /**
     * Compute the SHA1 of the given string
     *
     * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     */


    function sha1(str) {
      var utf8 = utf8Encode(str);
      var words32 = stringToWords32(utf8, Endian.Big);
      var len = utf8.length * 8;
      var w = newArray(80);
      var a = 0x67452301,
          b = 0xefcdab89,
          c = 0x98badcfe,
          d = 0x10325476,
          e = 0xc3d2e1f0;
      words32[len >> 5] |= 0x80 << 24 - len % 32;
      words32[(len + 64 >> 9 << 4) + 15] = len;

      for (var i = 0; i < words32.length; i += 16) {
        var h0 = a,
            h1 = b,
            h2 = c,
            h3 = d,
            h4 = e;

        for (var j = 0; j < 80; j++) {
          if (j < 16) {
            w[j] = words32[i + j];
          } else {
            w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
          }

          var fkVal = fk(j, b, c, d);
          var f = fkVal[0];
          var k = fkVal[1];
          var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
          e = d;
          d = c;
          c = rol32(b, 30);
          b = a;
          a = temp;
        }

        a = add32(a, h0);
        b = add32(b, h1);
        c = add32(c, h2);
        d = add32(d, h3);
        e = add32(e, h4);
      }

      return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }

    function fk(index, b, c, d) {
      if (index < 20) {
        return [b & c | ~b & d, 0x5a827999];
      }

      if (index < 40) {
        return [b ^ c ^ d, 0x6ed9eba1];
      }

      if (index < 60) {
        return [b & c | b & d | c & d, 0x8f1bbcdc];
      }

      return [b ^ c ^ d, 0xca62c1d6];
    }
    /**
     * Compute the fingerprint of the given string
     *
     * The output is 64 bit number encoded as a decimal string
     *
     * based on:
     * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java
     */


    function fingerprint(str) {
      var utf8 = utf8Encode(str);
      var hi = hash32(utf8, 0);
      var lo = hash32(utf8, 102072);

      if (hi == 0 && (lo == 0 || lo == 1)) {
        hi = hi ^ 0x130f9bef;
        lo = lo ^ -0x6b5f56d8;
      }

      return [hi, lo];
    }

    function computeMsgId(msg) {
      var meaning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var msgFingerprint = fingerprint(msg);

      if (meaning) {
        var meaningFingerprint = fingerprint(meaning);
        msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);
      }

      var hi = msgFingerprint[0];
      var lo = msgFingerprint[1];
      return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));
    }

    function hash32(str, c) {
      var a = 0x9e3779b9,
          b = 0x9e3779b9;
      var i;
      var len = str.length;

      for (i = 0; i + 12 <= len; i += 12) {
        a = add32(a, wordAt(str, i, Endian.Little));
        b = add32(b, wordAt(str, i + 4, Endian.Little));
        c = add32(c, wordAt(str, i + 8, Endian.Little));
        var res = mix(a, b, c);
        a = res[0], b = res[1], c = res[2];
      }

      a = add32(a, wordAt(str, i, Endian.Little));
      b = add32(b, wordAt(str, i + 4, Endian.Little)); // the first byte of c is reserved for the length

      c = add32(c, len);
      c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);
      return mix(a, b, c)[2];
    } // clang-format off


    function mix(a, b, c) {
      a = sub32(a, b);
      a = sub32(a, c);
      a ^= c >>> 13;
      b = sub32(b, c);
      b = sub32(b, a);
      b ^= a << 8;
      c = sub32(c, a);
      c = sub32(c, b);
      c ^= b >>> 13;
      a = sub32(a, b);
      a = sub32(a, c);
      a ^= c >>> 12;
      b = sub32(b, c);
      b = sub32(b, a);
      b ^= a << 16;
      c = sub32(c, a);
      c = sub32(c, b);
      c ^= b >>> 5;
      a = sub32(a, b);
      a = sub32(a, c);
      a ^= c >>> 3;
      b = sub32(b, c);
      b = sub32(b, a);
      b ^= a << 10;
      c = sub32(c, a);
      c = sub32(c, b);
      c ^= b >>> 15;
      return [a, b, c];
    } // clang-format on
    // Utils


    var Endian;

    (function (Endian) {
      Endian[Endian["Little"] = 0] = "Little";
      Endian[Endian["Big"] = 1] = "Big";
    })(Endian || (Endian = {}));

    function add32(a, b) {
      return add32to64(a, b)[1];
    }

    function add32to64(a, b) {
      var low = (a & 0xffff) + (b & 0xffff);
      var high = (a >>> 16) + (b >>> 16) + (low >>> 16);
      return [high >>> 16, high << 16 | low & 0xffff];
    }

    function add64(a, b) {
      var ah = a[0],
          al = a[1];
      var bh = b[0],
          bl = b[1];
      var result = add32to64(al, bl);
      var carry = result[0];
      var l = result[1];
      var h = add32(add32(ah, bh), carry);
      return [h, l];
    }

    function sub32(a, b) {
      var low = (a & 0xffff) - (b & 0xffff);
      var high = (a >> 16) - (b >> 16) + (low >> 16);
      return high << 16 | low & 0xffff;
    } // Rotate a 32b number left `count` position


    function rol32(a, count) {
      return a << count | a >>> 32 - count;
    } // Rotate a 64b number left `count` position


    function rol64(num, count) {
      var hi = num[0],
          lo = num[1];
      var h = hi << count | lo >>> 32 - count;
      var l = lo << count | hi >>> 32 - count;
      return [h, l];
    }

    function stringToWords32(str, endian) {
      var size = str.length + 3 >>> 2;
      var words32 = [];

      for (var i = 0; i < size; i++) {
        words32[i] = wordAt(str, i * 4, endian);
      }

      return words32;
    }

    function byteAt(str, index) {
      return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;
    }

    function wordAt(str, index, endian) {
      var word = 0;

      if (endian === Endian.Big) {
        for (var i = 0; i < 4; i++) {
          word += byteAt(str, index + i) << 24 - 8 * i;
        }
      } else {
        for (var _i5 = 0; _i5 < 4; _i5++) {
          word += byteAt(str, index + _i5) << 8 * _i5;
        }
      }

      return word;
    }

    function words32ToByteString(words32) {
      return words32.reduce(function (str, word) {
        return str + word32ToByteString(word);
      }, '');
    }

    function word32ToByteString(word) {
      var str = '';

      for (var i = 0; i < 4; i++) {
        str += String.fromCharCode(word >>> 8 * (3 - i) & 0xff);
      }

      return str;
    }

    function byteStringToHexString(str) {
      var hex = '';

      for (var i = 0; i < str.length; i++) {
        var b = byteAt(str, i);
        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);
      }

      return hex.toLowerCase();
    } // based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)


    function byteStringToDecString(str) {
      var decimal = '';
      var toThePower = '1';

      for (var i = str.length - 1; i >= 0; i--) {
        decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));
        toThePower = numberTimesBigInt(256, toThePower);
      }

      return decimal.split('').reverse().join('');
    } // x and y decimal, lowest significant digit first


    function addBigInt(x, y) {
      var sum = '';
      var len = Math.max(x.length, y.length);

      for (var i = 0, carry = 0; i < len || carry; i++) {
        var tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);

        if (tmpSum >= 10) {
          carry = 1;
          sum += tmpSum - 10;
        } else {
          carry = 0;
          sum += tmpSum;
        }
      }

      return sum;
    }

    function numberTimesBigInt(num, b) {
      var product = '';
      var bToThePower = b;

      for (; num !== 0; num = num >>> 1) {
        if (num & 1) product = addBigInt(product, bToThePower);
        bToThePower = addBigInt(bToThePower, bToThePower);
      }

      return product;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var Serializer =
    /*#__PURE__*/
    function () {
      function Serializer() {
        _classCallCheck(this, Serializer);
      }

      _createClass(Serializer, [{
        key: "createNameMapper",
        // Creates a name mapper, see `PlaceholderMapper`
        // Returning `null` means that no name mapping is used.
        value: function createNameMapper(message) {
          return null;
        }
      }]);

      return Serializer;
    }();
    /**
     * A simple mapper that take a function to transform an internal name to a public name
     */


    var SimplePlaceholderMapper =
    /*#__PURE__*/
    function (_RecurseVisitor) {
      _inherits(SimplePlaceholderMapper, _RecurseVisitor);

      // create a mapping from the message
      function SimplePlaceholderMapper(message, mapName) {
        var _this71;

        _classCallCheck(this, SimplePlaceholderMapper);

        _this71 = _possibleConstructorReturn(this, _getPrototypeOf(SimplePlaceholderMapper).call(this));
        _this71.mapName = mapName;
        _this71.internalToPublic = {};
        _this71.publicToNextId = {};
        _this71.publicToInternal = {};
        message.nodes.forEach(function (node) {
          return node.visit(_assertThisInitialized(_this71));
        });
        return _this71;
      }

      _createClass(SimplePlaceholderMapper, [{
        key: "toPublicName",
        value: function toPublicName(internalName) {
          return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;
        }
      }, {
        key: "toInternalName",
        value: function toInternalName(publicName) {
          return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;
        }
      }, {
        key: "visitText",
        value: function visitText(text, context) {
          return null;
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, context) {
          this.visitPlaceholderName(ph.startName);

          _get(_getPrototypeOf(SimplePlaceholderMapper.prototype), "visitTagPlaceholder", this).call(this, ph, context);

          this.visitPlaceholderName(ph.closeName);
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, context) {
          this.visitPlaceholderName(ph.name);
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          this.visitPlaceholderName(ph.name);
        } // XMB placeholders could only contains A-Z, 0-9 and _

      }, {
        key: "visitPlaceholderName",
        value: function visitPlaceholderName(internalName) {
          if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {
            return;
          }

          var publicName = this.mapName(internalName);

          if (this.publicToInternal.hasOwnProperty(publicName)) {
            // Create a new XMB when it has already been used
            var nextId = this.publicToNextId[publicName];
            this.publicToNextId[publicName] = nextId + 1;
            publicName = "".concat(publicName, "_").concat(nextId);
          } else {
            this.publicToNextId[publicName] = 1;
          }

          this.internalToPublic[internalName] = publicName;
          this.publicToInternal[publicName] = internalName;
        }
      }]);

      return SimplePlaceholderMapper;
    }(RecurseVisitor);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _Visitor =
    /*#__PURE__*/
    function () {
      function _Visitor() {
        _classCallCheck(this, _Visitor);
      }

      _createClass(_Visitor, [{
        key: "visitTag",
        value: function visitTag(tag) {
          var _this72 = this;

          var strAttrs = this._serializeAttributes(tag.attrs);

          if (tag.children.length == 0) {
            return "<".concat(tag.name).concat(strAttrs, "/>");
          }

          var strChildren = tag.children.map(function (node) {
            return node.visit(_this72);
          });
          return "<".concat(tag.name).concat(strAttrs, ">").concat(strChildren.join(''), "</").concat(tag.name, ">");
        }
      }, {
        key: "visitText",
        value: function visitText(text) {
          return text.value;
        }
      }, {
        key: "visitDeclaration",
        value: function visitDeclaration(decl) {
          return "<?xml".concat(this._serializeAttributes(decl.attrs), " ?>");
        }
      }, {
        key: "_serializeAttributes",
        value: function _serializeAttributes(attrs) {
          var strAttrs = Object.keys(attrs).map(function (name) {
            return "".concat(name, "=\"").concat(attrs[name], "\"");
          }).join(' ');
          return strAttrs.length > 0 ? ' ' + strAttrs : '';
        }
      }, {
        key: "visitDoctype",
        value: function visitDoctype(doctype) {
          return "<!DOCTYPE ".concat(doctype.rootTag, " [\n").concat(doctype.dtd, "\n]>");
        }
      }]);

      return _Visitor;
    }();

    var _visitor = new _Visitor();

    function serialize(nodes) {
      return nodes.map(function (node) {
        return node.visit(_visitor);
      }).join('');
    }

    var Declaration =
    /*#__PURE__*/
    function () {
      function Declaration(unescapedAttrs) {
        var _this73 = this;

        _classCallCheck(this, Declaration);

        this.attrs = {};
        Object.keys(unescapedAttrs).forEach(function (k) {
          _this73.attrs[k] = escapeXml(unescapedAttrs[k]);
        });
      }

      _createClass(Declaration, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitDeclaration(this);
        }
      }]);

      return Declaration;
    }();

    var Doctype =
    /*#__PURE__*/
    function () {
      function Doctype(rootTag, dtd) {
        _classCallCheck(this, Doctype);

        this.rootTag = rootTag;
        this.dtd = dtd;
      }

      _createClass(Doctype, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitDoctype(this);
        }
      }]);

      return Doctype;
    }();

    var Tag =
    /*#__PURE__*/
    function () {
      function Tag(name) {
        var _this74 = this;

        var unescapedAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

        _classCallCheck(this, Tag);

        this.name = name;
        this.children = children;
        this.attrs = {};
        Object.keys(unescapedAttrs).forEach(function (k) {
          _this74.attrs[k] = escapeXml(unescapedAttrs[k]);
        });
      }

      _createClass(Tag, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitTag(this);
        }
      }]);

      return Tag;
    }();

    var Text$2 =
    /*#__PURE__*/
    function () {
      function Text$2(unescapedValue) {
        _classCallCheck(this, Text$2);

        this.value = escapeXml(unescapedValue);
      }

      _createClass(Text$2, [{
        key: "visit",
        value: function visit(visitor) {
          return visitor.visitText(this);
        }
      }]);

      return Text$2;
    }();

    var CR =
    /*#__PURE__*/
    function (_Text$) {
      _inherits(CR, _Text$);

      function CR() {
        var ws = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        _classCallCheck(this, CR);

        return _possibleConstructorReturn(this, _getPrototypeOf(CR).call(this, "\n".concat(new Array(ws + 1).join(' '))));
      }

      return CR;
    }(Text$2);

    var _ESCAPED_CHARS = [[/&/g, '&amp;'], [/"/g, '&quot;'], [/'/g, '&apos;'], [/</g, '&lt;'], [/>/g, '&gt;']]; // Escape `_ESCAPED_CHARS` characters in the given text with encoded entities

    function escapeXml(text) {
      return _ESCAPED_CHARS.reduce(function (text, entry) {
        return text.replace(entry[0], entry[1]);
      }, text);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _MESSAGES_TAG = 'messagebundle';
    var _MESSAGE_TAG = 'msg';
    var _PLACEHOLDER_TAG = 'ph';
    var _EXAMPLE_TAG = 'ex';
    var _SOURCE_TAG = 'source';
    var _DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";

    var Xmb =
    /*#__PURE__*/
    function (_Serializer) {
      _inherits(Xmb, _Serializer);

      function Xmb() {
        _classCallCheck(this, Xmb);

        return _possibleConstructorReturn(this, _getPrototypeOf(Xmb).apply(this, arguments));
      }

      _createClass(Xmb, [{
        key: "write",
        value: function write(messages, locale) {
          var exampleVisitor = new ExampleVisitor();
          var visitor = new _Visitor$1();
          var rootNode = new Tag(_MESSAGES_TAG);
          messages.forEach(function (message) {
            var attrs = {
              id: message.id
            };

            if (message.description) {
              attrs['desc'] = message.description;
            }

            if (message.meaning) {
              attrs['meaning'] = message.meaning;
            }

            var sourceTags = [];
            message.sources.forEach(function (source) {
              sourceTags.push(new Tag(_SOURCE_TAG, {}, [new Text$2("".concat(source.filePath, ":").concat(source.startLine).concat(source.endLine !== source.startLine ? ',' + source.endLine : ''))]));
            });
            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [].concat(sourceTags, _toConsumableArray(visitor.serialize(message.nodes)))));
          });
          rootNode.children.push(new CR());
          return serialize([new Declaration({
            version: '1.0',
            encoding: 'UTF-8'
          }), new CR(), new Doctype(_MESSAGES_TAG, _DOCTYPE), new CR(), exampleVisitor.addDefaultExamples(rootNode), new CR()]);
        }
      }, {
        key: "load",
        value: function load(content, url) {
          throw new Error('Unsupported');
        }
      }, {
        key: "digest",
        value: function digest(message) {
          return digest$1(message);
        }
      }, {
        key: "createNameMapper",
        value: function createNameMapper(message) {
          return new SimplePlaceholderMapper(message, toPublicName);
        }
      }]);

      return Xmb;
    }(Serializer);

    var _Visitor$1 =
    /*#__PURE__*/
    function () {
      function _Visitor$1() {
        _classCallCheck(this, _Visitor$1);
      }

      _createClass(_Visitor$1, [{
        key: "visitText",
        value: function visitText(text, context) {
          return [new Text$2(text.value)];
        }
      }, {
        key: "visitContainer",
        value: function visitContainer(container, context) {
          var _this75 = this;

          var nodes = [];
          container.children.forEach(function (node) {
            return nodes.push.apply(nodes, _toConsumableArray(node.visit(_this75)));
          });
          return nodes;
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu, context) {
          var _this76 = this;

          var nodes = [new Text$2("{".concat(icu.expressionPlaceholder, ", ").concat(icu.type, ", "))];
          Object.keys(icu.cases).forEach(function (c) {
            nodes.push.apply(nodes, [new Text$2("".concat(c, " {"))].concat(_toConsumableArray(icu.cases[c].visit(_this76)), [new Text$2("} ")]));
          });
          nodes.push(new Text$2("}"));
          return nodes;
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, context) {
          var startTagAsText = new Text$2("<".concat(ph.tag, ">"));
          var startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]); // TC requires PH to have a non empty EX, and uses the text node to show the "original" value.

          var startTagPh = new Tag(_PLACEHOLDER_TAG, {
            name: ph.startName
          }, [startEx, startTagAsText]);

          if (ph.isVoid) {
            // void tags have no children nor closing tags
            return [startTagPh];
          }

          var closeTagAsText = new Text$2("</".concat(ph.tag, ">"));
          var closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]); // TC requires PH to have a non empty EX, and uses the text node to show the "original" value.

          var closeTagPh = new Tag(_PLACEHOLDER_TAG, {
            name: ph.closeName
          }, [closeEx, closeTagAsText]);
          return [startTagPh].concat(_toConsumableArray(this.serialize(ph.children)), [closeTagPh]);
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, context) {
          var interpolationAsText = new Text$2("{{".concat(ph.value, "}}")); // Example tag needs to be not-empty for TC.

          var exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);
          return [// TC requires PH to have a non empty EX, and uses the text node to show the "original" value.
          new Tag(_PLACEHOLDER_TAG, {
            name: ph.name
          }, [exTag, interpolationAsText])];
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          var icuExpression = ph.value.expression;
          var icuType = ph.value.type;
          var icuCases = Object.keys(ph.value.cases).map(function (value) {
            return value + ' {...}';
          }).join(' ');
          var icuAsText = new Text$2("{".concat(icuExpression, ", ").concat(icuType, ", ").concat(icuCases, "}"));
          var exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);
          return [// TC requires PH to have a non empty EX, and uses the text node to show the "original" value.
          new Tag(_PLACEHOLDER_TAG, {
            name: ph.name
          }, [exTag, icuAsText])];
        }
      }, {
        key: "serialize",
        value: function serialize(nodes) {
          var _ref10,
              _this77 = this;

          return (_ref10 = []).concat.apply(_ref10, _toConsumableArray(nodes.map(function (node) {
            return node.visit(_this77);
          })));
        }
      }]);

      return _Visitor$1;
    }();

    function digest$1(message) {
      return decimalDigest(message);
    } // TC requires at least one non-empty example on placeholders


    var ExampleVisitor =
    /*#__PURE__*/
    function () {
      function ExampleVisitor() {
        _classCallCheck(this, ExampleVisitor);
      }

      _createClass(ExampleVisitor, [{
        key: "addDefaultExamples",
        value: function addDefaultExamples(node) {
          node.visit(this);
          return node;
        }
      }, {
        key: "visitTag",
        value: function visitTag(tag) {
          var _this78 = this;

          if (tag.name === _PLACEHOLDER_TAG) {
            if (!tag.children || tag.children.length == 0) {
              var exText = new Text$2(tag.attrs['name'] || '...');
              tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];
            }
          } else if (tag.children) {
            tag.children.forEach(function (node) {
              return node.visit(_this78);
            });
          }
        }
      }, {
        key: "visitText",
        value: function visitText(text) {}
      }, {
        key: "visitDeclaration",
        value: function visitDeclaration(decl) {}
      }, {
        key: "visitDoctype",
        value: function visitDoctype(doctype) {}
      }]);

      return ExampleVisitor;
    }(); // XMB/XTB placeholders can only contain A-Z, 0-9 and _


    function toPublicName(internalName) {
      return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */


    var CLOSURE_TRANSLATION_PREFIX = 'MSG_';
    /* Prefix for non-`goog.getMsg` i18n-related vars */

    var TRANSLATION_PREFIX = 'I18N_';
    /** Name of the i18n attributes **/

    var I18N_ATTR = 'i18n';
    var I18N_ATTR_PREFIX = 'i18n-';
    /** Prefix of var expressions used in ICUs */

    var I18N_ICU_VAR_PREFIX = 'VAR_';
    /** Prefix of ICU expressions for post processing */

    var I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';
    /** Placeholder wrapper for i18n expressions **/

    var I18N_PLACEHOLDER_SYMBOL = '�';

    function isI18nAttribute(name) {
      return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);
    }

    function isI18nRootNode(meta) {
      return meta instanceof Message;
    }

    function isSingleI18nIcu(meta) {
      return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu$1;
    }

    function hasI18nAttrs(element) {
      return element.attrs.some(function (attr) {
        return isI18nAttribute(attr.name);
      });
    }

    function icuFromI18nMessage(message) {
      return message.nodes[0];
    }

    function wrapI18nPlaceholder(content) {
      var contextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var blockId = contextId > 0 ? ":".concat(contextId) : '';
      return "".concat(I18N_PLACEHOLDER_SYMBOL).concat(content).concat(blockId).concat(I18N_PLACEHOLDER_SYMBOL);
    }

    function assembleI18nBoundString(strings) {
      var bindingStartIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (!strings.length) return '';
      var acc = '';
      var lastIdx = strings.length - 1;

      for (var i = 0; i < lastIdx; i++) {
        acc += "".concat(strings[i]).concat(wrapI18nPlaceholder(bindingStartIndex + i, contextId));
      }

      acc += strings[lastIdx];
      return acc;
    }

    function getSeqNumberGenerator() {
      var startsAt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var current = startsAt;
      return function () {
        return current++;
      };
    }

    function placeholdersToParams(placeholders) {
      var params = {};
      placeholders.forEach(function (values, key) {
        params[key] = literal(values.length > 1 ? "[".concat(values.join('|'), "]") : values[0]);
      });
      return params;
    }

    function updatePlaceholderMap(map, name) {
      var current = map.get(name) || [];

      for (var _len2 = arguments.length, values = new Array(_len2 > 2 ? _len2 - 2 : 0), _key3 = 2; _key3 < _len2; _key3++) {
        values[_key3 - 2] = arguments[_key3];
      }

      current.push.apply(current, values);
      map.set(name, current);
    }

    function assembleBoundTextPlaceholders(meta) {
      var bindingStartIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var startIdx = bindingStartIndex;
      var placeholders = new Map();
      var node = meta instanceof Message ? meta.nodes.find(function (node) {
        return node instanceof Container;
      }) : meta;

      if (node) {
        node.children.filter(function (child) {
          return child instanceof Placeholder;
        }).forEach(function (child, idx) {
          var content = wrapI18nPlaceholder(startIdx + idx, contextId);
          updatePlaceholderMap(placeholders, child.name, content);
        });
      }

      return placeholders;
    }
    /**
     * Format the placeholder names in a map of placeholders to expressions.
     *
     * The placeholder names are converted from "internal" format (e.g. `START_TAG_DIV_1`) to "external"
     * format (e.g. `startTagDiv_1`).
     *
     * @param params A map of placeholder names to expressions.
     * @param useCamelCase whether to camelCase the placeholder name when formatting.
     * @returns A new map of formatted placeholder names to expressions.
     */


    function i18nFormatPlaceholderNames() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var useCamelCase = arguments.length > 1 ? arguments[1] : undefined;
      var _params = {};

      if (params && Object.keys(params).length) {
        Object.keys(params).forEach(function (key) {
          return _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key];
        });
      }

      return _params;
    }
    /**
     * Converts internal placeholder names to public-facing format
     * (for example to use in goog.getMsg call).
     * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.
     *
     * @param name The placeholder name that should be formatted
     * @returns Formatted placeholder name
     */


    function formatI18nPlaceholderName(name) {
      var useCamelCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var publicName = toPublicName(name);

      if (!useCamelCase) {
        return publicName;
      }

      var chunks = publicName.split('_');

      if (chunks.length === 1) {
        // if no "_" found - just lowercase the value
        return name.toLowerCase();
      }

      var postfix; // eject last element if it's a number

      if (/^\d+$/.test(chunks[chunks.length - 1])) {
        postfix = chunks.pop();
      }

      var raw = chunks.shift().toLowerCase();

      if (chunks.length) {
        raw += chunks.map(function (c) {
          return c.charAt(0).toUpperCase() + c.slice(1).toLowerCase();
        }).join('');
      }

      return postfix ? "".concat(raw, "_").concat(postfix) : raw;
    }
    /**
     * Generates a prefix for translation const name.
     *
     * @param extra Additional local prefix that should be injected into translation var name
     * @returns Complete translation const prefix
     */


    function getTranslationConstPrefix(extra) {
      return "".concat(CLOSURE_TRANSLATION_PREFIX).concat(extra).toUpperCase();
    }
    /**
     * Generate AST to declare a variable. E.g. `var I18N_1;`.
     * @param variable the name of the variable to declare.
     */


    function declareI18nVariable(variable) {
      return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, null, variable.sourceSpan);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in
     * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may
     * bot work in some cases when object keys are mangled by minifier.
     *
     * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with
     * inputs that contain potentially unsafe chars.
     */


    var UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;
    /** Name of the temporary to use during data binding */

    var TEMPORARY_NAME = '_t';
    /** Name of the context parameter passed into a template function */

    var CONTEXT_NAME = 'ctx';
    /** Name of the RenderFlag passed into a template function */

    var RENDER_FLAGS = 'rf';
    /** The prefix reference variables */

    var REFERENCE_PREFIX = '_r';
    /** The name of the implicit context reference */

    var IMPLICIT_REFERENCE = '$implicit';
    /** Non bindable attribute name **/

    var NON_BINDABLE_ATTR = 'ngNonBindable';
    /**
     * Creates an allocator for a temporary variable.
     *
     * A variable declaration is added to the statements the first time the allocator is invoked.
     */

    function temporaryAllocator(statements, name) {
      var temp = null;
      return function () {
        if (!temp) {
          statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));
          temp = variable(name);
        }

        return temp;
      };
    }

    function unsupported(feature) {
      if (this) {
        throw new Error("Builder ".concat(this.constructor.name, " doesn't support ").concat(feature, " yet"));
      }

      throw new Error("Feature ".concat(feature, " is not supported yet"));
    }

    function invalid$1(arg) {
      throw new Error("Invalid state: Visitor ".concat(this.constructor.name, " doesn't handle ").concat(arg.constructor.name));
    }

    function asLiteral(value) {
      if (Array.isArray(value)) {
        return literalArr(value.map(asLiteral));
      }

      return literal(value, INFERRED_TYPE);
    }

    function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {
      if (Object.getOwnPropertyNames(keys).length > 0) {
        return mapToExpression(keys, keepDeclared);
      }

      return null;
    }

    function mapToExpression(map, keepDeclared) {
      return literalMap(Object.getOwnPropertyNames(map).map(function (key) {
        // canonical syntax: `dirProp: publicProp`
        // if there is no `:`, use dirProp = elProp
        var value = map[key];
        var declaredName;
        var publicName;
        var minifiedName;

        if (Array.isArray(value)) {
          var _value = _slicedToArray(value, 2);

          publicName = _value[0];
          declaredName = _value[1];
        } else {
          var _splitAtColon = splitAtColon(key, [key, value]);

          var _splitAtColon2 = _slicedToArray(_splitAtColon, 2);

          declaredName = _splitAtColon2[0];
          publicName = _splitAtColon2[1];
        }

        minifiedName = declaredName;
        return {
          key: minifiedName,
          // put quotes around keys that contain potentially unsafe characters
          quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),
          value: keepDeclared && publicName !== declaredName ? literalArr([asLiteral(publicName), asLiteral(declaredName)]) : asLiteral(publicName)
        };
      }));
    }
    /**
     *  Remove trailing null nodes as they are implied.
     */


    function trimTrailingNulls(parameters) {
      while (isNull(parameters[parameters.length - 1])) {
        parameters.pop();
      }

      return parameters;
    }

    function getQueryPredicate(query, constantPool) {
      if (Array.isArray(query.predicate)) {
        var predicate = [];
        query.predicate.forEach(function (selector) {
          // Each item in predicates array may contain strings with comma-separated refs
          // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them
          // as separate array entities
          var selectors = selector.split(',').map(function (token) {
            return literal(token.trim());
          });
          predicate.push.apply(predicate, _toConsumableArray(selectors));
        });
        return constantPool.getConstLiteral(literalArr(predicate), true);
      } else {
        return query.predicate;
      }
    }

    function noop() {}

    var DefinitionMap =
    /*#__PURE__*/
    function () {
      function DefinitionMap() {
        _classCallCheck(this, DefinitionMap);

        this.values = [];
      }

      _createClass(DefinitionMap, [{
        key: "set",
        value: function set(key, value) {
          if (value) {
            this.values.push({
              key: key,
              value: value,
              quoted: false
            });
          }
        }
      }, {
        key: "toLiteralMap",
        value: function toLiteralMap() {
          return literalMap(this.values);
        }
      }]);

      return DefinitionMap;
    }();
    /**
     * Extract a map of properties to values for a given element or template node, which can be used
     * by the directive matching machinery.
     *
     * @param elOrTpl the element or template in question
     * @return an object set up for directive matching. For attributes on the element/template, this
     * object maps a property name to its (static) value. For any bindings, this map simply maps the
     * property name to an empty string.
     */


    function getAttrsForDirectiveMatching(elOrTpl) {
      var attributesMap = {};

      if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {
        elOrTpl.templateAttrs.forEach(function (a) {
          return attributesMap[a.name] = '';
        });
      } else {
        elOrTpl.attributes.forEach(function (a) {
          if (!isI18nAttribute(a.name)) {
            attributesMap[a.name] = a.value;
          }
        });
        elOrTpl.inputs.forEach(function (i) {
          attributesMap[i.name] = '';
        });
        elOrTpl.outputs.forEach(function (o) {
          attributesMap[o.name] = '';
        });
      }

      return attributesMap;
    }
    /** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */


    function chainedInstruction(reference, calls, span) {
      var expression = importExpr(reference, null, span);

      if (calls.length > 0) {
        for (var i = 0; i < calls.length; i++) {
          expression = expression.callFn(calls[i], span);
        }
      } else {
        // Add a blank invocation, in case the `calls` array is empty.
        expression = expression.callFn([], span);
      }

      return expression;
    }
    /**
     * Gets the number of arguments expected to be passed to a generated instruction in the case of
     * interpolation instructions.
     * @param interpolation An interpolation ast
     */


    function getInterpolationArgsLength(interpolation) {
      var expressions = interpolation.expressions,
          strings = interpolation.strings;

      if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {
        // If the interpolation has one interpolated value, but the prefix and suffix are both empty
        // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or
        // `textInterpolate`.
        return 1;
      } else {
        return expressions.length + strings.length;
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var R3FactoryDelegateType;

    (function (R3FactoryDelegateType) {
      R3FactoryDelegateType[R3FactoryDelegateType["Class"] = 0] = "Class";
      R3FactoryDelegateType[R3FactoryDelegateType["Function"] = 1] = "Function";
      R3FactoryDelegateType[R3FactoryDelegateType["Factory"] = 2] = "Factory";
    })(R3FactoryDelegateType || (R3FactoryDelegateType = {}));

    var R3FactoryTarget;

    (function (R3FactoryTarget) {
      R3FactoryTarget[R3FactoryTarget["Directive"] = 0] = "Directive";
      R3FactoryTarget[R3FactoryTarget["Component"] = 1] = "Component";
      R3FactoryTarget[R3FactoryTarget["Injectable"] = 2] = "Injectable";
      R3FactoryTarget[R3FactoryTarget["Pipe"] = 3] = "Pipe";
      R3FactoryTarget[R3FactoryTarget["NgModule"] = 4] = "NgModule";
    })(R3FactoryTarget || (R3FactoryTarget = {}));
    /**
     * Resolved type of a dependency.
     *
     * Occasionally, dependencies will have special significance which is known statically. In that
     * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency
     * should be generated specially (usually by calling a special injection function instead of the
     * standard one).
     */


    var R3ResolvedDependencyType;

    (function (R3ResolvedDependencyType) {
      /**
       * A normal token dependency.
       */
      R3ResolvedDependencyType[R3ResolvedDependencyType["Token"] = 0] = "Token";
      /**
       * The dependency is for an attribute.
       *
       * The token expression is a string representing the attribute name.
       */

      R3ResolvedDependencyType[R3ResolvedDependencyType["Attribute"] = 1] = "Attribute";
      /**
       * Injecting the `ChangeDetectorRef` token. Needs special handling when injected into a pipe.
       */

      R3ResolvedDependencyType[R3ResolvedDependencyType["ChangeDetectorRef"] = 2] = "ChangeDetectorRef";
      /**
       * An invalid dependency (no token could be determined). An error should be thrown at runtime.
       */

      R3ResolvedDependencyType[R3ResolvedDependencyType["Invalid"] = 3] = "Invalid";
    })(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));
    /**
     * Construct a factory function expression for the given `R3FactoryMetadata`.
     */


    function compileFactoryFunction(meta) {
      var t = variable('t');
      var statements = []; // The type to instantiate via constructor invocation. If there is no delegated factory, meaning
      // this type is always created by constructor invocation, then this is the type-to-create
      // parameter provided by the user (t) if specified, or the current type if not. If there is a
      // delegated factory (which is used to create the current type) then this is only the type-to-
      // create parameter (t).

      var typeForCtor = !isDelegatedMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) : t;
      var ctorExpr = null;

      if (meta.deps !== null) {
        // There is a constructor (either explicitly or implicitly defined).
        if (meta.deps !== 'invalid') {
          ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.injectFn, meta.target === R3FactoryTarget.Pipe));
        }
      } else {
        var baseFactory = variable("\u0275".concat(meta.name, "_BaseFactory"));
        var getInheritedFactory = importExpr(Identifiers$1.getInheritedFactory);
        var baseFactoryStmt = baseFactory.set(getInheritedFactory.callFn([meta.internalType])).toDeclStmt(INFERRED_TYPE, [StmtModifier.Exported, StmtModifier.Final]);
        statements.push(baseFactoryStmt); // There is no constructor, use the base class' factory to construct typeForCtor.

        ctorExpr = baseFactory.callFn([typeForCtor]);
      }

      var ctorExprFinal = ctorExpr;
      var body = [];
      var retExpr = null;

      function makeConditionalFactory(nonCtorExpr) {
        var r = variable('r');
        body.push(r.set(NULL_EXPR).toDeclStmt());
        var ctorStmt = null;

        if (ctorExprFinal !== null) {
          ctorStmt = r.set(ctorExprFinal).toStmt();
        } else {
          ctorStmt = importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt();
        }

        body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));
        return r;
      }

      if (isDelegatedMetadata(meta) && meta.delegateType === R3FactoryDelegateType.Factory) {
        var delegateFactory = variable("\u0275".concat(meta.name, "_BaseFactory"));
        var getFactoryOf = importExpr(Identifiers$1.getFactoryOf);

        if (meta.delegate.isEquivalent(meta.internalType)) {
          throw new Error("Illegal state: compiling factory that delegates to itself");
        }

        var delegateFactoryStmt = delegateFactory.set(getFactoryOf.callFn([meta.delegate])).toDeclStmt(INFERRED_TYPE, [StmtModifier.Exported, StmtModifier.Final]);
        statements.push(delegateFactoryStmt);
        retExpr = makeConditionalFactory(delegateFactory.callFn([]));
      } else if (isDelegatedMetadata(meta)) {
        // This type is created with a delegated factory. If a type parameter is not specified, call
        // the factory instead.
        var delegateArgs = injectDependencies(meta.delegateDeps, meta.injectFn, meta.target === R3FactoryTarget.Pipe); // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.

        var factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);
        retExpr = makeConditionalFactory(factoryExpr);
      } else if (isExpressionFactoryMetadata(meta)) {
        // TODO(alxhub): decide whether to lower the value here or in the caller
        retExpr = makeConditionalFactory(meta.expression);
      } else {
        retExpr = ctorExpr;
      }

      if (retExpr !== null) {
        body.push(new ReturnStatement(retExpr));
      } else {
        body.push(importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt());
      }

      return {
        factory: fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, "".concat(meta.name, "_Factory")),
        statements: statements,
        type: expressionType(importExpr(Identifiers$1.FactoryDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]))
      };
    }

    function injectDependencies(deps, injectFn, isPipe) {
      return deps.map(function (dep, index) {
        return compileInjectDependency(dep, injectFn, isPipe, index);
      });
    }

    function compileInjectDependency(dep, injectFn, isPipe, index) {
      // Interpret the dependency according to its resolved type.
      switch (dep.resolved) {
        case R3ResolvedDependencyType.Token:
        case R3ResolvedDependencyType.ChangeDetectorRef:
          // Build up the injection flags according to the metadata.
          var flags = 0
          /* Default */
          | (dep.self ? 2
          /* Self */
          : 0) | (dep.skipSelf ? 4
          /* SkipSelf */
          : 0) | (dep.host ? 1
          /* Host */
          : 0) | (dep.optional ? 8
          /* Optional */
          : 0); // If this dependency is optional or otherwise has non-default flags, then additional
          // parameters describing how to inject the dependency must be passed to the inject function
          // that's being used.

          var flagsParam = flags !== 0
          /* Default */
          || dep.optional ? literal(flags) : null; // We have a separate instruction for injecting ChangeDetectorRef into a pipe.

          if (isPipe && dep.resolved === R3ResolvedDependencyType.ChangeDetectorRef) {
            return importExpr(Identifiers$1.injectPipeChangeDetectorRef).callFn(flagsParam ? [flagsParam] : []);
          } // Build up the arguments to the injectFn call.


          var injectArgs = [dep.token];

          if (flagsParam) {
            injectArgs.push(flagsParam);
          }

          return importExpr(injectFn).callFn(injectArgs);

        case R3ResolvedDependencyType.Attribute:
          // In the case of attributes, the attribute name in question is given as the token.
          return importExpr(Identifiers$1.injectAttribute).callFn([dep.token]);

        case R3ResolvedDependencyType.Invalid:
          return importExpr(Identifiers$1.invalidFactoryDep).callFn([literal(index)]);

        default:
          return unsupported("Unknown R3ResolvedDependencyType: ".concat(R3ResolvedDependencyType[dep.resolved]));
      }
    }
    /**
     * A helper function useful for extracting `R3DependencyMetadata` from a Render2
     * `CompileTypeMetadata` instance.
     */


    function dependenciesFromGlobalMetadata(type, outputCtx, reflector) {
      // Use the `CompileReflector` to look up references to some well-known Angular types. These will
      // be compared with the token to statically determine whether the token has significance to
      // Angular, and set the correct `R3ResolvedDependencyType` as a result.
      var injectorRef = reflector.resolveExternalReference(Identifiers.Injector); // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.

      var deps = [];
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = type.diDeps[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var dependency = _step5.value;

          if (dependency.token) {
            var tokenRef = tokenReference(dependency.token);
            var resolved = dependency.isAttribute ? R3ResolvedDependencyType.Attribute : R3ResolvedDependencyType.Token; // In the case of most dependencies, the token will be a reference to a type. Sometimes,
            // however, it can be a string, in the case of older Angular code or @Attribute injection.

            var token = tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : literal(tokenRef); // Construct the dependency.

            deps.push({
              token: token,
              resolved: resolved,
              host: !!dependency.isHost,
              optional: !!dependency.isOptional,
              self: !!dependency.isSelf,
              skipSelf: !!dependency.isSkipSelf
            });
          } else {
            unsupported('dependency without a token');
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return deps;
    }

    function isDelegatedMetadata(meta) {
      return meta.delegateType !== undefined;
    }

    function isExpressionFactoryMetadata(meta) {
      return meta.expression !== undefined;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function _compileInjectable(meta) {
      var result = null;
      var factoryMeta = {
        name: meta.name,
        type: meta.type,
        internalType: meta.internalType,
        typeArgumentCount: meta.typeArgumentCount,
        deps: [],
        injectFn: Identifiers.inject,
        target: R3FactoryTarget.Injectable
      };

      if (meta.useClass !== undefined) {
        // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is
        // used to instantiate the class with dependencies injected, or deps are not specified and
        // the factory of the class is used to instantiate it.
        //
        // A special case exists for useClass: Type where Type is the injectable type itself and no
        // deps are specified, in which case 'useClass' is effectively ignored.
        var useClassOnSelf = meta.useClass.isEquivalent(meta.internalType);
        var deps = undefined;

        if (meta.userDeps !== undefined) {
          deps = meta.userDeps;
        }

        if (deps !== undefined) {
          // factory: () => new meta.useClass(...deps)
          result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
            delegate: meta.useClass,
            delegateDeps: deps,
            delegateType: R3FactoryDelegateType.Class
          }));
        } else if (useClassOnSelf) {
          result = compileFactoryFunction(factoryMeta);
        } else {
          result = delegateToFactory(meta.type.value, meta.useClass);
        }
      } else if (meta.useFactory !== undefined) {
        if (meta.userDeps !== undefined) {
          result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
            delegate: meta.useFactory,
            delegateDeps: meta.userDeps || [],
            delegateType: R3FactoryDelegateType.Function
          }));
        } else {
          result = {
            statements: [],
            factory: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])
          };
        }
      } else if (meta.useValue !== undefined) {
        // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for
        // client code because meta.useValue is an Expression which will be defined even if the actual
        // value is undefined.
        result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
          expression: meta.useValue
        }));
      } else if (meta.useExisting !== undefined) {
        // useExisting is an `inject` call on the existing token.
        result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
          expression: importExpr(Identifiers.inject).callFn([meta.useExisting])
        }));
      } else {
        result = delegateToFactory(meta.type.value, meta.internalType);
      }

      var token = meta.internalType;
      var injectableProps = {
        token: token,
        factory: result.factory
      }; // Only generate providedIn property if it has a non-null value

      if (meta.providedIn.value !== null) {
        injectableProps.providedIn = meta.providedIn;
      }

      var expression = importExpr(Identifiers.ɵɵdefineInjectable).callFn([mapToMapExpression(injectableProps)]);
      var type = new ExpressionType(importExpr(Identifiers.InjectableDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));
      return {
        expression: expression,
        type: type,
        statements: result.statements
      };
    }

    function delegateToFactory(type, internalType) {
      return {
        statements: [],
        // If types are the same, we can generate `factory: type.ɵfac`
        // If types are different, we have to generate a wrapper function to ensure
        // the internal type has been resolved (`factory: function(t) { return type.ɵfac(t); }`)
        factory: type.node === internalType.node ? internalType.prop('ɵfac') : fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(internalType.callMethod('ɵfac', [variable('t')]))])
      };
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function assertArrayOfStrings(identifier, value) {
      if (value == null) {
        return;
      }

      if (!Array.isArray(value)) {
        throw new Error("Expected '".concat(identifier, "' to be an array of strings."));
      }

      for (var i = 0; i < value.length; i += 1) {
        if (typeof value[i] !== 'string') {
          throw new Error("Expected '".concat(identifier, "' to be an array of strings."));
        }
      }
    }

    var UNUSABLE_INTERPOLATION_REGEXPS = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];

    function assertInterpolationSymbols(identifier, value) {
      if (value != null && !(Array.isArray(value) && value.length == 2)) {
        throw new Error("Expected '".concat(identifier, "' to be an array, [start, end]."));
      } else if (value != null) {
        var start = value[0];
        var end = value[1]; // Check for unusable interpolation symbols

        UNUSABLE_INTERPOLATION_REGEXPS.forEach(function (regexp) {
          if (regexp.test(start) || regexp.test(end)) {
            throw new Error("['".concat(start, "', '").concat(end, "'] contains unusable interpolation symbol."));
          }
        });
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var InterpolationConfig =
    /*#__PURE__*/
    function () {
      function InterpolationConfig(start, end) {
        _classCallCheck(this, InterpolationConfig);

        this.start = start;
        this.end = end;
      }

      _createClass(InterpolationConfig, null, [{
        key: "fromArray",
        value: function fromArray(markers) {
          if (!markers) {
            return DEFAULT_INTERPOLATION_CONFIG;
          }

          assertInterpolationSymbols('interpolation', markers);
          return new InterpolationConfig(markers[0], markers[1]);
        }
      }]);

      return InterpolationConfig;
    }();

    var DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit

    var VERSION = 3;
    var JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';

    var SourceMapGenerator =
    /*#__PURE__*/
    function () {
      function SourceMapGenerator() {
        var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _classCallCheck(this, SourceMapGenerator);

        this.file = file;
        this.sourcesContent = new Map();
        this.lines = [];
        this.lastCol0 = 0;
        this.hasMappings = false;
      } // The content is `null` when the content is expected to be loaded using the URL


      _createClass(SourceMapGenerator, [{
        key: "addSource",
        value: function addSource(url) {
          var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (!this.sourcesContent.has(url)) {
            this.sourcesContent.set(url, content);
          }

          return this;
        }
      }, {
        key: "addLine",
        value: function addLine() {
          this.lines.push([]);
          this.lastCol0 = 0;
          return this;
        }
      }, {
        key: "addMapping",
        value: function addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {
          if (!this.currentLine) {
            throw new Error("A line must be added before mappings can be added");
          }

          if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
            throw new Error("Unknown source file \"".concat(sourceUrl, "\""));
          }

          if (col0 == null) {
            throw new Error("The column in the generated code must be provided");
          }

          if (col0 < this.lastCol0) {
            throw new Error("Mapping should be added in output order");
          }

          if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
            throw new Error("The source location must be provided when a source url is provided");
          }

          this.hasMappings = true;
          this.lastCol0 = col0;
          this.currentLine.push({
            col0: col0,
            sourceUrl: sourceUrl,
            sourceLine0: sourceLine0,
            sourceCol0: sourceCol0
          });
          return this;
        }
        /**
        * @internal strip this from published d.ts files due to
        * https://github.com/microsoft/TypeScript/issues/36216
        */

      }, {
        key: "toJSON",
        value: function toJSON() {
          var _this79 = this;

          if (!this.hasMappings) {
            return null;
          }

          var sourcesIndex = new Map();
          var sources = [];
          var sourcesContent = [];
          Array.from(this.sourcesContent.keys()).forEach(function (url, i) {
            sourcesIndex.set(url, i);
            sources.push(url);
            sourcesContent.push(_this79.sourcesContent.get(url) || null);
          });
          var mappings = '';
          var lastCol0 = 0;
          var lastSourceIndex = 0;
          var lastSourceLine0 = 0;
          var lastSourceCol0 = 0;
          this.lines.forEach(function (segments) {
            lastCol0 = 0;
            mappings += segments.map(function (segment) {
              // zero-based starting column of the line in the generated code
              var segAsStr = toBase64VLQ(segment.col0 - lastCol0);
              lastCol0 = segment.col0;

              if (segment.sourceUrl != null) {
                // zero-based index into the “sources” list
                segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);
                lastSourceIndex = sourcesIndex.get(segment.sourceUrl); // the zero-based starting line in the original source

                segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);
                lastSourceLine0 = segment.sourceLine0; // the zero-based starting column in the original source

                segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);
                lastSourceCol0 = segment.sourceCol0;
              }

              return segAsStr;
            }).join(',');
            mappings += ';';
          });
          mappings = mappings.slice(0, -1);
          return {
            'file': this.file || '',
            'version': VERSION,
            'sourceRoot': '',
            'sources': sources,
            'sourcesContent': sourcesContent,
            'mappings': mappings
          };
        }
      }, {
        key: "toJsComment",
        value: function toJsComment() {
          return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : '';
        }
      }, {
        key: "currentLine",
        get: function get() {
          return this.lines.slice(-1)[0];
        }
      }]);

      return SourceMapGenerator;
    }();

    function toBase64String(value) {
      var b64 = '';
      value = utf8Encode(value);

      for (var i = 0; i < value.length;) {
        var i1 = value.charCodeAt(i++);
        var i2 = value.charCodeAt(i++);
        var i3 = value.charCodeAt(i++);
        b64 += toBase64Digit(i1 >> 2);
        b64 += toBase64Digit((i1 & 3) << 4 | (isNaN(i2) ? 0 : i2 >> 4));
        b64 += isNaN(i2) ? '=' : toBase64Digit((i2 & 15) << 2 | i3 >> 6);
        b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);
      }

      return b64;
    }

    function toBase64VLQ(value) {
      value = value < 0 ? (-value << 1) + 1 : value << 1;
      var out = '';

      do {
        var digit = value & 31;
        value = value >> 5;

        if (value > 0) {
          digit = digit | 32;
        }

        out += toBase64Digit(digit);
      } while (value > 0);

      return out;
    }

    var B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    function toBase64Digit(value) {
      if (value < 0 || value >= 64) {
        throw new Error("Can only encode value in the range [0, 63]");
      }

      return B64_DIGITS[value];
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
    var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
    var _INDENT_WITH = '  ';
    var CATCH_ERROR_VAR$1 = variable('error', null, null);
    var CATCH_STACK_VAR$1 = variable('stack', null, null);

    var _EmittedLine = function _EmittedLine(indent) {
      _classCallCheck(this, _EmittedLine);

      this.indent = indent;
      this.partsLength = 0;
      this.parts = [];
      this.srcSpans = [];
    };

    var EmitterVisitorContext =
    /*#__PURE__*/
    function () {
      function EmitterVisitorContext(_indent) {
        _classCallCheck(this, EmitterVisitorContext);

        this._indent = _indent;
        this._classes = [];
        this._preambleLineCount = 0;
        this._lines = [new _EmittedLine(_indent)];
      }

      _createClass(EmitterVisitorContext, [{
        key: "println",
        value: function println(from) {
          var lastPart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          this.print(from || null, lastPart, true);
        }
      }, {
        key: "lineIsEmpty",
        value: function lineIsEmpty() {
          return this._currentLine.parts.length === 0;
        }
      }, {
        key: "lineLength",
        value: function lineLength() {
          return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
        }
      }, {
        key: "print",
        value: function print(from, part) {
          var newLine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (part.length > 0) {
            this._currentLine.parts.push(part);

            this._currentLine.partsLength += part.length;

            this._currentLine.srcSpans.push(from && from.sourceSpan || null);
          }

          if (newLine) {
            this._lines.push(new _EmittedLine(this._indent));
          }
        }
      }, {
        key: "removeEmptyLastLine",
        value: function removeEmptyLastLine() {
          if (this.lineIsEmpty()) {
            this._lines.pop();
          }
        }
      }, {
        key: "incIndent",
        value: function incIndent() {
          this._indent++;

          if (this.lineIsEmpty()) {
            this._currentLine.indent = this._indent;
          }
        }
      }, {
        key: "decIndent",
        value: function decIndent() {
          this._indent--;

          if (this.lineIsEmpty()) {
            this._currentLine.indent = this._indent;
          }
        }
      }, {
        key: "pushClass",
        value: function pushClass(clazz) {
          this._classes.push(clazz);
        }
      }, {
        key: "popClass",
        value: function popClass() {
          return this._classes.pop();
        }
      }, {
        key: "toSource",
        value: function toSource() {
          return this.sourceLines.map(function (l) {
            return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '';
          }).join('\n');
        }
      }, {
        key: "toSourceMapGenerator",
        value: function toSourceMapGenerator(genFilePath) {
          var startsAtLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var map = new SourceMapGenerator(genFilePath);
          var firstOffsetMapped = false;

          var mapFirstOffsetIfNeeded = function mapFirstOffsetIfNeeded() {
            if (!firstOffsetMapped) {
              // Add a single space so that tools won't try to load the file from disk.
              // Note: We are using virtual urls like `ng:///`, so we have to
              // provide a content here.
              map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);
              firstOffsetMapped = true;
            }
          };

          for (var i = 0; i < startsAtLine; i++) {
            map.addLine();
            mapFirstOffsetIfNeeded();
          }

          this.sourceLines.forEach(function (line, lineIdx) {
            map.addLine();
            var spans = line.srcSpans;
            var parts = line.parts;
            var col0 = line.indent * _INDENT_WITH.length;
            var spanIdx = 0; // skip leading parts without source spans

            while (spanIdx < spans.length && !spans[spanIdx]) {
              col0 += parts[spanIdx].length;
              spanIdx++;
            }

            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
              firstOffsetMapped = true;
            } else {
              mapFirstOffsetIfNeeded();
            }

            while (spanIdx < spans.length) {
              var span = spans[spanIdx];
              var source = span.start.file;
              var sourceLine = span.start.line;
              var sourceCol = span.start.col;
              map.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);
              col0 += parts[spanIdx].length;
              spanIdx++; // assign parts without span or the same span to the previous segment

              while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
                col0 += parts[spanIdx].length;
                spanIdx++;
              }
            }
          });
          return map;
        }
      }, {
        key: "setPreambleLineCount",
        value: function setPreambleLineCount(count) {
          return this._preambleLineCount = count;
        }
      }, {
        key: "spanOf",
        value: function spanOf(line, column) {
          var emittedLine = this._lines[line - this._preambleLineCount];

          if (emittedLine) {
            var columnsLeft = column - _createIndent(emittedLine.indent).length;

            for (var partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
              var part = emittedLine.parts[partIndex];

              if (part.length > columnsLeft) {
                return emittedLine.srcSpans[partIndex];
              }

              columnsLeft -= part.length;
            }
          }

          return null;
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */

      }, {
        key: "_currentLine",

        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get: function get() {
          return this._lines[this._lines.length - 1];
        }
      }, {
        key: "currentClass",
        get: function get() {
          return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
        }
      }, {
        key: "sourceLines",
        get: function get() {
          if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
            return this._lines.slice(0, -1);
          }

          return this._lines;
        }
      }], [{
        key: "createRoot",
        value: function createRoot() {
          return new EmitterVisitorContext(0);
        }
      }]);

      return EmitterVisitorContext;
    }();

    var AbstractEmitterVisitor =
    /*#__PURE__*/
    function () {
      function AbstractEmitterVisitor(_escapeDollarInStrings) {
        _classCallCheck(this, AbstractEmitterVisitor);

        this._escapeDollarInStrings = _escapeDollarInStrings;
      }

      _createClass(AbstractEmitterVisitor, [{
        key: "visitExpressionStmt",
        value: function visitExpressionStmt(stmt, ctx) {
          stmt.expr.visitExpression(this, ctx);
          ctx.println(stmt, ';');
          return null;
        }
      }, {
        key: "visitReturnStmt",
        value: function visitReturnStmt(stmt, ctx) {
          ctx.print(stmt, "return ");
          stmt.value.visitExpression(this, ctx);
          ctx.println(stmt, ';');
          return null;
        }
      }, {
        key: "visitIfStmt",
        value: function visitIfStmt(stmt, ctx) {
          ctx.print(stmt, "if (");
          stmt.condition.visitExpression(this, ctx);
          ctx.print(stmt, ") {");
          var hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;

          if (stmt.trueCase.length <= 1 && !hasElseCase) {
            ctx.print(stmt, " ");
            this.visitAllStatements(stmt.trueCase, ctx);
            ctx.removeEmptyLastLine();
            ctx.print(stmt, " ");
          } else {
            ctx.println();
            ctx.incIndent();
            this.visitAllStatements(stmt.trueCase, ctx);
            ctx.decIndent();

            if (hasElseCase) {
              ctx.println(stmt, "} else {");
              ctx.incIndent();
              this.visitAllStatements(stmt.falseCase, ctx);
              ctx.decIndent();
            }
          }

          ctx.println(stmt, "}");
          return null;
        }
      }, {
        key: "visitThrowStmt",
        value: function visitThrowStmt(stmt, ctx) {
          ctx.print(stmt, "throw ");
          stmt.error.visitExpression(this, ctx);
          ctx.println(stmt, ";");
          return null;
        }
      }, {
        key: "visitCommentStmt",
        value: function visitCommentStmt(stmt, ctx) {
          if (stmt.multiline) {
            ctx.println(stmt, "/* ".concat(stmt.comment, " */"));
          } else {
            stmt.comment.split('\n').forEach(function (line) {
              ctx.println(stmt, "// ".concat(line));
            });
          }

          return null;
        }
      }, {
        key: "visitJSDocCommentStmt",
        value: function visitJSDocCommentStmt(stmt, ctx) {
          ctx.println(stmt, "/*".concat(stmt.toString(), "*/"));
          return null;
        }
      }, {
        key: "visitWriteVarExpr",
        value: function visitWriteVarExpr(expr, ctx) {
          var lineWasEmpty = ctx.lineIsEmpty();

          if (!lineWasEmpty) {
            ctx.print(expr, '(');
          }

          ctx.print(expr, "".concat(expr.name, " = "));
          expr.value.visitExpression(this, ctx);

          if (!lineWasEmpty) {
            ctx.print(expr, ')');
          }

          return null;
        }
      }, {
        key: "visitWriteKeyExpr",
        value: function visitWriteKeyExpr(expr, ctx) {
          var lineWasEmpty = ctx.lineIsEmpty();

          if (!lineWasEmpty) {
            ctx.print(expr, '(');
          }

          expr.receiver.visitExpression(this, ctx);
          ctx.print(expr, "[");
          expr.index.visitExpression(this, ctx);
          ctx.print(expr, "] = ");
          expr.value.visitExpression(this, ctx);

          if (!lineWasEmpty) {
            ctx.print(expr, ')');
          }

          return null;
        }
      }, {
        key: "visitWritePropExpr",
        value: function visitWritePropExpr(expr, ctx) {
          var lineWasEmpty = ctx.lineIsEmpty();

          if (!lineWasEmpty) {
            ctx.print(expr, '(');
          }

          expr.receiver.visitExpression(this, ctx);
          ctx.print(expr, ".".concat(expr.name, " = "));
          expr.value.visitExpression(this, ctx);

          if (!lineWasEmpty) {
            ctx.print(expr, ')');
          }

          return null;
        }
      }, {
        key: "visitInvokeMethodExpr",
        value: function visitInvokeMethodExpr(expr, ctx) {
          expr.receiver.visitExpression(this, ctx);
          var name = expr.name;

          if (expr.builtin != null) {
            name = this.getBuiltinMethodName(expr.builtin);

            if (name == null) {
              // some builtins just mean to skip the call.
              return null;
            }
          }

          ctx.print(expr, ".".concat(name, "("));
          this.visitAllExpressions(expr.args, ctx, ",");
          ctx.print(expr, ")");
          return null;
        }
      }, {
        key: "visitInvokeFunctionExpr",
        value: function visitInvokeFunctionExpr(expr, ctx) {
          expr.fn.visitExpression(this, ctx);
          ctx.print(expr, "(");
          this.visitAllExpressions(expr.args, ctx, ',');
          ctx.print(expr, ")");
          return null;
        }
      }, {
        key: "visitWrappedNodeExpr",
        value: function visitWrappedNodeExpr(ast, ctx) {
          throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');
        }
      }, {
        key: "visitTypeofExpr",
        value: function visitTypeofExpr(expr, ctx) {
          ctx.print(expr, 'typeof ');
          expr.expr.visitExpression(this, ctx);
        }
      }, {
        key: "visitReadVarExpr",
        value: function visitReadVarExpr(ast, ctx) {
          var varName = ast.name;

          if (ast.builtin != null) {
            switch (ast.builtin) {
              case BuiltinVar.Super:
                varName = 'super';
                break;

              case BuiltinVar.This:
                varName = 'this';
                break;

              case BuiltinVar.CatchError:
                varName = CATCH_ERROR_VAR$1.name;
                break;

              case BuiltinVar.CatchStack:
                varName = CATCH_STACK_VAR$1.name;
                break;

              default:
                throw new Error("Unknown builtin variable ".concat(ast.builtin));
            }
          }

          ctx.print(ast, varName);
          return null;
        }
      }, {
        key: "visitInstantiateExpr",
        value: function visitInstantiateExpr(ast, ctx) {
          ctx.print(ast, "new ");
          ast.classExpr.visitExpression(this, ctx);
          ctx.print(ast, "(");
          this.visitAllExpressions(ast.args, ctx, ',');
          ctx.print(ast, ")");
          return null;
        }
      }, {
        key: "visitLiteralExpr",
        value: function visitLiteralExpr(ast, ctx) {
          var value = ast.value;

          if (typeof value === 'string') {
            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
          } else {
            ctx.print(ast, "".concat(value));
          }

          return null;
        }
      }, {
        key: "visitLocalizedString",
        value: function visitLocalizedString(ast, ctx) {
          var head = ast.serializeI18nHead();
          ctx.print(ast, '$localize `' + head.raw);

          for (var i = 1; i < ast.messageParts.length; i++) {
            ctx.print(ast, '${');
            ast.expressions[i - 1].visitExpression(this, ctx);
            ctx.print(ast, "}".concat(ast.serializeI18nTemplatePart(i).raw));
          }

          ctx.print(ast, '`');
          return null;
        }
      }, {
        key: "visitConditionalExpr",
        value: function visitConditionalExpr(ast, ctx) {
          ctx.print(ast, "(");
          ast.condition.visitExpression(this, ctx);
          ctx.print(ast, '? ');
          ast.trueCase.visitExpression(this, ctx);
          ctx.print(ast, ': ');
          ast.falseCase.visitExpression(this, ctx);
          ctx.print(ast, ")");
          return null;
        }
      }, {
        key: "visitNotExpr",
        value: function visitNotExpr(ast, ctx) {
          ctx.print(ast, '!');
          ast.condition.visitExpression(this, ctx);
          return null;
        }
      }, {
        key: "visitAssertNotNullExpr",
        value: function visitAssertNotNullExpr(ast, ctx) {
          ast.condition.visitExpression(this, ctx);
          return null;
        }
      }, {
        key: "visitBinaryOperatorExpr",
        value: function visitBinaryOperatorExpr(ast, ctx) {
          var opStr;

          switch (ast.operator) {
            case BinaryOperator.Equals:
              opStr = '==';
              break;

            case BinaryOperator.Identical:
              opStr = '===';
              break;

            case BinaryOperator.NotEquals:
              opStr = '!=';
              break;

            case BinaryOperator.NotIdentical:
              opStr = '!==';
              break;

            case BinaryOperator.And:
              opStr = '&&';
              break;

            case BinaryOperator.BitwiseAnd:
              opStr = '&';
              break;

            case BinaryOperator.Or:
              opStr = '||';
              break;

            case BinaryOperator.Plus:
              opStr = '+';
              break;

            case BinaryOperator.Minus:
              opStr = '-';
              break;

            case BinaryOperator.Divide:
              opStr = '/';
              break;

            case BinaryOperator.Multiply:
              opStr = '*';
              break;

            case BinaryOperator.Modulo:
              opStr = '%';
              break;

            case BinaryOperator.Lower:
              opStr = '<';
              break;

            case BinaryOperator.LowerEquals:
              opStr = '<=';
              break;

            case BinaryOperator.Bigger:
              opStr = '>';
              break;

            case BinaryOperator.BiggerEquals:
              opStr = '>=';
              break;

            default:
              throw new Error("Unknown operator ".concat(ast.operator));
          }

          if (ast.parens) ctx.print(ast, "(");
          ast.lhs.visitExpression(this, ctx);
          ctx.print(ast, " ".concat(opStr, " "));
          ast.rhs.visitExpression(this, ctx);
          if (ast.parens) ctx.print(ast, ")");
          return null;
        }
      }, {
        key: "visitReadPropExpr",
        value: function visitReadPropExpr(ast, ctx) {
          ast.receiver.visitExpression(this, ctx);
          ctx.print(ast, ".");
          ctx.print(ast, ast.name);
          return null;
        }
      }, {
        key: "visitReadKeyExpr",
        value: function visitReadKeyExpr(ast, ctx) {
          ast.receiver.visitExpression(this, ctx);
          ctx.print(ast, "[");
          ast.index.visitExpression(this, ctx);
          ctx.print(ast, "]");
          return null;
        }
      }, {
        key: "visitLiteralArrayExpr",
        value: function visitLiteralArrayExpr(ast, ctx) {
          ctx.print(ast, "[");
          this.visitAllExpressions(ast.entries, ctx, ',');
          ctx.print(ast, "]");
          return null;
        }
      }, {
        key: "visitLiteralMapExpr",
        value: function visitLiteralMapExpr(ast, ctx) {
          var _this80 = this;

          ctx.print(ast, "{");
          this.visitAllObjects(function (entry) {
            ctx.print(ast, "".concat(escapeIdentifier(entry.key, _this80._escapeDollarInStrings, entry.quoted), ":"));
            entry.value.visitExpression(_this80, ctx);
          }, ast.entries, ctx, ',');
          ctx.print(ast, "}");
          return null;
        }
      }, {
        key: "visitCommaExpr",
        value: function visitCommaExpr(ast, ctx) {
          ctx.print(ast, '(');
          this.visitAllExpressions(ast.parts, ctx, ',');
          ctx.print(ast, ')');
          return null;
        }
      }, {
        key: "visitAllExpressions",
        value: function visitAllExpressions(expressions, ctx, separator) {
          var _this81 = this;

          this.visitAllObjects(function (expr) {
            return expr.visitExpression(_this81, ctx);
          }, expressions, ctx, separator);
        }
      }, {
        key: "visitAllObjects",
        value: function visitAllObjects(handler, expressions, ctx, separator) {
          var incrementedIndent = false;

          for (var i = 0; i < expressions.length; i++) {
            if (i > 0) {
              if (ctx.lineLength() > 80) {
                ctx.print(null, separator, true);

                if (!incrementedIndent) {
                  // continuation are marked with double indent.
                  ctx.incIndent();
                  ctx.incIndent();
                  incrementedIndent = true;
                }
              } else {
                ctx.print(null, separator, false);
              }
            }

            handler(expressions[i]);
          }

          if (incrementedIndent) {
            // continuation are marked with double indent.
            ctx.decIndent();
            ctx.decIndent();
          }
        }
      }, {
        key: "visitAllStatements",
        value: function visitAllStatements(statements, ctx) {
          var _this82 = this;

          statements.forEach(function (stmt) {
            return stmt.visitStatement(_this82, ctx);
          });
        }
      }]);

      return AbstractEmitterVisitor;
    }();

    function escapeIdentifier(input, escapeDollar) {
      var alwaysQuote = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (input == null) {
        return null;
      }

      var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {
        if ((arguments.length <= 0 ? undefined : arguments[0]) == '$') {
          return escapeDollar ? '\\$' : '$';
        } else if ((arguments.length <= 0 ? undefined : arguments[0]) == '\n') {
          return '\\n';
        } else if ((arguments.length <= 0 ? undefined : arguments[0]) == '\r') {
          return '\\r';
        } else {
          return "\\".concat(arguments.length <= 0 ? undefined : arguments[0]);
        }
      });
      var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
      return requiresQuotes ? "'".concat(body, "'") : body;
    }

    function _createIndent(count) {
      var res = '';

      for (var i = 0; i < count; i++) {
        res += _INDENT_WITH;
      }

      return res;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var AbstractJsEmitterVisitor =
    /*#__PURE__*/
    function (_AbstractEmitterVisit) {
      _inherits(AbstractJsEmitterVisitor, _AbstractEmitterVisit);

      function AbstractJsEmitterVisitor() {
        _classCallCheck(this, AbstractJsEmitterVisitor);

        return _possibleConstructorReturn(this, _getPrototypeOf(AbstractJsEmitterVisitor).call(this, false));
      }

      _createClass(AbstractJsEmitterVisitor, [{
        key: "visitDeclareClassStmt",
        value: function visitDeclareClassStmt(stmt, ctx) {
          var _this83 = this;

          ctx.pushClass(stmt);

          this._visitClassConstructor(stmt, ctx);

          if (stmt.parent != null) {
            ctx.print(stmt, "".concat(stmt.name, ".prototype = Object.create("));
            stmt.parent.visitExpression(this, ctx);
            ctx.println(stmt, ".prototype);");
          }

          stmt.getters.forEach(function (getter) {
            return _this83._visitClassGetter(stmt, getter, ctx);
          });
          stmt.methods.forEach(function (method) {
            return _this83._visitClassMethod(stmt, method, ctx);
          });
          ctx.popClass();
          return null;
        }
      }, {
        key: "_visitClassConstructor",
        value: function _visitClassConstructor(stmt, ctx) {
          ctx.print(stmt, "function ".concat(stmt.name, "("));

          if (stmt.constructorMethod != null) {
            this._visitParams(stmt.constructorMethod.params, ctx);
          }

          ctx.println(stmt, ") {");
          ctx.incIndent();

          if (stmt.constructorMethod != null) {
            if (stmt.constructorMethod.body.length > 0) {
              ctx.println(stmt, "var self = this;");
              this.visitAllStatements(stmt.constructorMethod.body, ctx);
            }
          }

          ctx.decIndent();
          ctx.println(stmt, "}");
        }
      }, {
        key: "_visitClassGetter",
        value: function _visitClassGetter(stmt, getter, ctx) {
          ctx.println(stmt, "Object.defineProperty(".concat(stmt.name, ".prototype, '").concat(getter.name, "', { get: function() {"));
          ctx.incIndent();

          if (getter.body.length > 0) {
            ctx.println(stmt, "var self = this;");
            this.visitAllStatements(getter.body, ctx);
          }

          ctx.decIndent();
          ctx.println(stmt, "}});");
        }
      }, {
        key: "_visitClassMethod",
        value: function _visitClassMethod(stmt, method, ctx) {
          ctx.print(stmt, "".concat(stmt.name, ".prototype.").concat(method.name, " = function("));

          this._visitParams(method.params, ctx);

          ctx.println(stmt, ") {");
          ctx.incIndent();

          if (method.body.length > 0) {
            ctx.println(stmt, "var self = this;");
            this.visitAllStatements(method.body, ctx);
          }

          ctx.decIndent();
          ctx.println(stmt, "};");
        }
      }, {
        key: "visitWrappedNodeExpr",
        value: function visitWrappedNodeExpr(ast, ctx) {
          throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');
        }
      }, {
        key: "visitReadVarExpr",
        value: function visitReadVarExpr(ast, ctx) {
          if (ast.builtin === BuiltinVar.This) {
            ctx.print(ast, 'self');
          } else if (ast.builtin === BuiltinVar.Super) {
            throw new Error("'super' needs to be handled at a parent ast node, not at the variable level!");
          } else {
            _get(_getPrototypeOf(AbstractJsEmitterVisitor.prototype), "visitReadVarExpr", this).call(this, ast, ctx);
          }

          return null;
        }
      }, {
        key: "visitDeclareVarStmt",
        value: function visitDeclareVarStmt(stmt, ctx) {
          ctx.print(stmt, "var ".concat(stmt.name));

          if (stmt.value) {
            ctx.print(stmt, ' = ');
            stmt.value.visitExpression(this, ctx);
          }

          ctx.println(stmt, ";");
          return null;
        }
      }, {
        key: "visitCastExpr",
        value: function visitCastExpr(ast, ctx) {
          ast.value.visitExpression(this, ctx);
          return null;
        }
      }, {
        key: "visitInvokeFunctionExpr",
        value: function visitInvokeFunctionExpr(expr, ctx) {
          var fnExpr = expr.fn;

          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
            ctx.currentClass.parent.visitExpression(this, ctx);
            ctx.print(expr, ".call(this");

            if (expr.args.length > 0) {
              ctx.print(expr, ", ");
              this.visitAllExpressions(expr.args, ctx, ',');
            }

            ctx.print(expr, ")");
          } else {
            _get(_getPrototypeOf(AbstractJsEmitterVisitor.prototype), "visitInvokeFunctionExpr", this).call(this, expr, ctx);
          }

          return null;
        }
      }, {
        key: "visitFunctionExpr",
        value: function visitFunctionExpr(ast, ctx) {
          ctx.print(ast, "function".concat(ast.name ? ' ' + ast.name : '', "("));

          this._visitParams(ast.params, ctx);

          ctx.println(ast, ") {");
          ctx.incIndent();
          this.visitAllStatements(ast.statements, ctx);
          ctx.decIndent();
          ctx.print(ast, "}");
          return null;
        }
      }, {
        key: "visitDeclareFunctionStmt",
        value: function visitDeclareFunctionStmt(stmt, ctx) {
          ctx.print(stmt, "function ".concat(stmt.name, "("));

          this._visitParams(stmt.params, ctx);

          ctx.println(stmt, ") {");
          ctx.incIndent();
          this.visitAllStatements(stmt.statements, ctx);
          ctx.decIndent();
          ctx.println(stmt, "}");
          return null;
        }
      }, {
        key: "visitTryCatchStmt",
        value: function visitTryCatchStmt(stmt, ctx) {
          ctx.println(stmt, "try {");
          ctx.incIndent();
          this.visitAllStatements(stmt.bodyStmts, ctx);
          ctx.decIndent();
          ctx.println(stmt, "} catch (".concat(CATCH_ERROR_VAR$1.name, ") {"));
          ctx.incIndent();
          var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [StmtModifier.Final])].concat(stmt.catchStmts);
          this.visitAllStatements(catchStmts, ctx);
          ctx.decIndent();
          ctx.println(stmt, "}");
          return null;
        }
      }, {
        key: "visitLocalizedString",
        value: function visitLocalizedString(ast, ctx) {
          var _this84 = this;

          // The following convoluted piece of code is effectively the downlevelled equivalent of
          // ```
          // $localize `...`
          // ```
          // which is effectively like:
          // ```
          // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);
          // ```
          //
          // The `$localize` function expects a "template object", which is an array of "cooked" strings
          // plus a `raw` property that contains an array of "raw" strings.
          //
          // In some environments a helper function called `__makeTemplateObject(cooked, raw)` might be
          // available, in which case we use that. Otherwise we must create our own helper function
          // inline.
          //
          // In the inline function, if `Object.defineProperty` is available we use that to attach the
          // `raw` array.
          ctx.print(ast, '$localize((this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e})(');
          var parts = [ast.serializeI18nHead()];

          for (var i = 1; i < ast.messageParts.length; i++) {
            parts.push(ast.serializeI18nTemplatePart(i));
          }

          ctx.print(ast, "[".concat(parts.map(function (part) {
            return escapeIdentifier(part.cooked, false);
          }).join(', '), "], "));
          ctx.print(ast, "[".concat(parts.map(function (part) {
            return escapeIdentifier(part.raw, false);
          }).join(', '), "])"));
          ast.expressions.forEach(function (expression) {
            ctx.print(ast, ', ');
            expression.visitExpression(_this84, ctx);
          });
          ctx.print(ast, ')');
          return null;
        }
      }, {
        key: "_visitParams",
        value: function _visitParams(params, ctx) {
          this.visitAllObjects(function (param) {
            return ctx.print(null, param.name);
          }, params, ctx, ',');
        }
      }, {
        key: "getBuiltinMethodName",
        value: function getBuiltinMethodName(method) {
          var name;

          switch (method) {
            case BuiltinMethod.ConcatArray:
              name = 'concat';
              break;

            case BuiltinMethod.SubscribeObservable:
              name = 'subscribe';
              break;

            case BuiltinMethod.Bind:
              name = 'bind';
              break;

            default:
              throw new Error("Unknown builtin method: ".concat(method));
          }

          return name;
        }
      }]);

      return AbstractJsEmitterVisitor;
    }(AbstractEmitterVisitor);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * A helper class to manage the evaluation of JIT generated code.
     */


    var JitEvaluator =
    /*#__PURE__*/
    function () {
      function JitEvaluator() {
        _classCallCheck(this, JitEvaluator);
      }

      _createClass(JitEvaluator, [{
        key: "evaluateStatements",

        /**
         *
         * @param sourceUrl The URL of the generated code.
         * @param statements An array of Angular statement AST nodes to be evaluated.
         * @param reflector A helper used when converting the statements to executable code.
         * @param createSourceMaps If true then create a source-map for the generated code and include it
         * inline as a source-map comment.
         * @returns A map of all the variables in the generated code.
         */
        value: function evaluateStatements(sourceUrl, statements, reflector, createSourceMaps) {
          var converter = new JitEmitterVisitor(reflector);
          var ctx = EmitterVisitorContext.createRoot(); // Ensure generated code is in strict mode

          if (statements.length > 0 && !isUseStrictStatement(statements[0])) {
            statements = [literal('use strict').toStmt()].concat(_toConsumableArray(statements));
          }

          converter.visitAllStatements(statements, ctx);
          converter.createReturnStmt(ctx);
          return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);
        }
        /**
         * Evaluate a piece of JIT generated code.
         * @param sourceUrl The URL of this generated code.
         * @param ctx A context object that contains an AST of the code to be evaluated.
         * @param vars A map containing the names and values of variables that the evaluated code might
         * reference.
         * @param createSourceMap If true then create a source-map for the generated code and include it
         * inline as a source-map comment.
         * @returns The result of evaluating the code.
         */

      }, {
        key: "evaluateCode",
        value: function evaluateCode(sourceUrl, ctx, vars, createSourceMap) {
          var fnBody = "\"use strict\";".concat(ctx.toSource(), "\n//# sourceURL=").concat(sourceUrl);
          var fnArgNames = [];
          var fnArgValues = [];

          for (var argName in vars) {
            fnArgValues.push(vars[argName]);
            fnArgNames.push(argName);
          }

          if (createSourceMap) {
            // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise
            // E.g. ```
            // function anonymous(a,b,c
            // /**/) { ... }```
            // We don't want to hard code this fact, so we auto detect it via an empty function first.
            var emptyFn = _construct(Function, _toConsumableArray(fnArgNames.concat('return null;'))).toString();

            var headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\n').length - 1;
            fnBody += "\n".concat(ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment());
          }

          var fn = _construct(Function, _toConsumableArray(fnArgNames.concat(fnBody)));

          return this.executeFunction(fn, fnArgValues);
        }
        /**
         * Execute a JIT generated function by calling it.
         *
         * This method can be overridden in tests to capture the functions that are generated
         * by this `JitEvaluator` class.
         *
         * @param fn A function to execute.
         * @param args The arguments to pass to the function being executed.
         * @returns The return value of the executed function.
         */

      }, {
        key: "executeFunction",
        value: function executeFunction(fn, args) {
          return fn.apply(void 0, _toConsumableArray(args));
        }
      }]);

      return JitEvaluator;
    }();
    /**
     * An Angular AST visitor that converts AST nodes into executable JavaScript code.
     */


    var JitEmitterVisitor =
    /*#__PURE__*/
    function (_AbstractJsEmitterVis) {
      _inherits(JitEmitterVisitor, _AbstractJsEmitterVis);

      function JitEmitterVisitor(reflector) {
        var _this85;

        _classCallCheck(this, JitEmitterVisitor);

        _this85 = _possibleConstructorReturn(this, _getPrototypeOf(JitEmitterVisitor).call(this));
        _this85.reflector = reflector;
        _this85._evalArgNames = [];
        _this85._evalArgValues = [];
        _this85._evalExportedVars = [];
        return _this85;
      }

      _createClass(JitEmitterVisitor, [{
        key: "createReturnStmt",
        value: function createReturnStmt(ctx) {
          var stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(function (resultVar) {
            return new LiteralMapEntry(resultVar, variable(resultVar), false);
          })));
          stmt.visitStatement(this, ctx);
        }
      }, {
        key: "getArgs",
        value: function getArgs() {
          var result = {};

          for (var i = 0; i < this._evalArgNames.length; i++) {
            result[this._evalArgNames[i]] = this._evalArgValues[i];
          }

          return result;
        }
      }, {
        key: "visitExternalExpr",
        value: function visitExternalExpr(ast, ctx) {
          this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);

          return null;
        }
      }, {
        key: "visitWrappedNodeExpr",
        value: function visitWrappedNodeExpr(ast, ctx) {
          this._emitReferenceToExternal(ast, ast.node, ctx);

          return null;
        }
      }, {
        key: "visitDeclareVarStmt",
        value: function visitDeclareVarStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported)) {
            this._evalExportedVars.push(stmt.name);
          }

          return _get(_getPrototypeOf(JitEmitterVisitor.prototype), "visitDeclareVarStmt", this).call(this, stmt, ctx);
        }
      }, {
        key: "visitDeclareFunctionStmt",
        value: function visitDeclareFunctionStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported)) {
            this._evalExportedVars.push(stmt.name);
          }

          return _get(_getPrototypeOf(JitEmitterVisitor.prototype), "visitDeclareFunctionStmt", this).call(this, stmt, ctx);
        }
      }, {
        key: "visitDeclareClassStmt",
        value: function visitDeclareClassStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported)) {
            this._evalExportedVars.push(stmt.name);
          }

          return _get(_getPrototypeOf(JitEmitterVisitor.prototype), "visitDeclareClassStmt", this).call(this, stmt, ctx);
        }
      }, {
        key: "_emitReferenceToExternal",
        value: function _emitReferenceToExternal(ast, value, ctx) {
          var id = this._evalArgValues.indexOf(value);

          if (id === -1) {
            id = this._evalArgValues.length;

            this._evalArgValues.push(value);

            var name = identifierName({
              reference: value
            }) || 'val';

            this._evalArgNames.push("jit_".concat(name, "_").concat(id));
          }

          ctx.print(ast, this._evalArgNames[id]);
        }
      }]);

      return JitEmitterVisitor;
    }(AbstractJsEmitterVisitor);

    function isUseStrictStatement(statement) {
      return statement.isEquivalent(literal('use strict').toStmt());
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Implementation of `CompileReflector` which resolves references to @angular/core
     * symbols at runtime, according to a consumer-provided mapping.
     *
     * Only supports `resolveExternalReference`, all other methods throw.
     */


    var R3JitReflector =
    /*#__PURE__*/
    function () {
      function R3JitReflector(context) {
        _classCallCheck(this, R3JitReflector);

        this.context = context;
      }

      _createClass(R3JitReflector, [{
        key: "resolveExternalReference",
        value: function resolveExternalReference(ref) {
          // This reflector only handles @angular/core imports.
          if (ref.moduleName !== '@angular/core') {
            throw new Error("Cannot resolve external reference to ".concat(ref.moduleName, ", only references to @angular/core are supported."));
          }

          if (!this.context.hasOwnProperty(ref.name)) {
            throw new Error("No value provided for @angular/core symbol '".concat(ref.name, "'."));
          }

          return this.context[ref.name];
        }
      }, {
        key: "parameters",
        value: function parameters(typeOrFunc) {
          throw new Error('Not implemented.');
        }
      }, {
        key: "annotations",
        value: function annotations(typeOrFunc) {
          throw new Error('Not implemented.');
        }
      }, {
        key: "shallowAnnotations",
        value: function shallowAnnotations(typeOrFunc) {
          throw new Error('Not implemented.');
        }
      }, {
        key: "tryAnnotations",
        value: function tryAnnotations(typeOrFunc) {
          throw new Error('Not implemented.');
        }
      }, {
        key: "propMetadata",
        value: function propMetadata(typeOrFunc) {
          throw new Error('Not implemented.');
        }
      }, {
        key: "hasLifecycleHook",
        value: function hasLifecycleHook(type, lcProperty) {
          throw new Error('Not implemented.');
        }
      }, {
        key: "guards",
        value: function guards(typeOrFunc) {
          throw new Error('Not implemented.');
        }
      }, {
        key: "componentModuleUrl",
        value: function componentModuleUrl(type, cmpMetadata) {
          throw new Error('Not implemented.');
        }
      }]);

      return R3JitReflector;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function mapEntry(key, value) {
      return {
        key: key,
        value: value,
        quoted: false
      };
    }

    function mapLiteral(obj) {
      var quoted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return literalMap(Object.keys(obj).map(function (key) {
        return {
          key: key,
          quoted: quoted,
          value: obj[key]
        };
      }));
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.
     */


    function _compileNgModule(meta) {
      var internalType = meta.internalType,
          moduleType = meta.type,
          bootstrap = meta.bootstrap,
          declarations = meta.declarations,
          imports = meta.imports,
          exports = meta.exports,
          schemas = meta.schemas,
          containsForwardDecls = meta.containsForwardDecls,
          emitInline = meta.emitInline,
          id = meta.id;
      var additionalStatements = [];
      var definitionMap = {
        type: internalType
      }; // Only generate the keys in the metadata if the arrays have values.

      if (bootstrap.length) {
        definitionMap.bootstrap = refsToArray(bootstrap, containsForwardDecls);
      } // If requested to emit scope information inline, pass the declarations, imports and exports to
      // the `ɵɵdefineNgModule` call. The JIT compilation uses this.


      if (emitInline) {
        if (declarations.length) {
          definitionMap.declarations = refsToArray(declarations, containsForwardDecls);
        }

        if (imports.length) {
          definitionMap.imports = refsToArray(imports, containsForwardDecls);
        }

        if (exports.length) {
          definitionMap.exports = refsToArray(exports, containsForwardDecls);
        }
      } // If not emitting inline, the scope information is not passed into `ɵɵdefineNgModule` as it would
      // prevent tree-shaking of the declarations, imports and exports references.
      else {
          var setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);

          if (setNgModuleScopeCall !== null) {
            additionalStatements.push(setNgModuleScopeCall);
          }
        }

      if (schemas && schemas.length) {
        definitionMap.schemas = literalArr(schemas.map(function (ref) {
          return ref.value;
        }));
      }

      if (id) {
        definitionMap.id = id;
      }

      var expression = importExpr(Identifiers$1.defineNgModule).callFn([mapToMapExpression(definitionMap)]);
      var type = new ExpressionType(importExpr(Identifiers$1.NgModuleDefWithMeta, [new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports), tupleTypeOf(exports)]));
      return {
        expression: expression,
        type: type,
        additionalStatements: additionalStatements
      };
    }
    /**
     * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the
     * transitive module scope can be computed during runtime in JIT mode. This call is marked pure
     * such that the references to declarations, imports and exports may be elided causing these
     * symbols to become tree-shakeable.
     */


    function generateSetNgModuleScopeCall(meta) {
      var moduleType = meta.adjacentType,
          declarations = meta.declarations,
          imports = meta.imports,
          exports = meta.exports,
          containsForwardDecls = meta.containsForwardDecls;
      var scopeMap = {};

      if (declarations.length) {
        scopeMap.declarations = refsToArray(declarations, containsForwardDecls);
      }

      if (imports.length) {
        scopeMap.imports = refsToArray(imports, containsForwardDecls);
      }

      if (exports.length) {
        scopeMap.exports = refsToArray(exports, containsForwardDecls);
      }

      if (Object.keys(scopeMap).length === 0) {
        return null;
      } // setNgModuleScope(...)


      var fnCall = new InvokeFunctionExpr(
      /* fn */
      importExpr(Identifiers$1.setNgModuleScope),
      /* args */
      [moduleType, mapToMapExpression(scopeMap)]); // (ngJitMode guard) && setNgModuleScope(...)

      var guardedCall = jitOnlyGuardedExpression(fnCall); // function() { (ngJitMode guard) && setNgModuleScope(...); }

      var iife = new FunctionExpr(
      /* params */
      [],
      /* statements */
      [guardedCall.toStmt()]); // (function() { (ngJitMode guard) && setNgModuleScope(...); })()

      var iifeCall = new InvokeFunctionExpr(
      /* fn */
      iife,
      /* args */
      []);
      return iifeCall.toStmt();
    }

    function _compileInjector(meta) {
      var result = compileFactoryFunction({
        name: meta.name,
        type: meta.type,
        internalType: meta.internalType,
        typeArgumentCount: 0,
        deps: meta.deps,
        injectFn: Identifiers$1.inject,
        target: R3FactoryTarget.NgModule
      });
      var definitionMap = {
        factory: result.factory
      };

      if (meta.providers !== null) {
        definitionMap.providers = meta.providers;
      }

      if (meta.imports.length > 0) {
        definitionMap.imports = literalArr(meta.imports);
      }

      var expression = importExpr(Identifiers$1.defineInjector).callFn([mapToMapExpression(definitionMap)]);
      var type = new ExpressionType(importExpr(Identifiers$1.InjectorDef, [new ExpressionType(meta.type.type)]));
      return {
        expression: expression,
        type: type,
        statements: result.statements
      };
    } // TODO(alxhub): integrate this with `compileNgModule`. Currently the two are separate operations.


    function compileNgModuleFromRender2(ctx, ngModule, injectableCompiler) {
      var className = identifierName(ngModule.type);
      var rawImports = ngModule.rawImports ? [ngModule.rawImports] : [];
      var rawExports = ngModule.rawExports ? [ngModule.rawExports] : [];
      var injectorDefArg = mapLiteral({
        'factory': injectableCompiler.factoryFor({
          type: ngModule.type,
          symbol: ngModule.type.reference
        }, ctx),
        'providers': convertMetaToOutput(ngModule.rawProviders, ctx),
        'imports': convertMetaToOutput([].concat(rawImports, rawExports), ctx)
      });
      var injectorDef = importExpr(Identifiers$1.defineInjector).callFn([injectorDefArg]);
      ctx.statements.push(new ClassStmt(
      /* name */
      className,
      /* parent */
      null,
      /* fields */
      [new ClassField(
      /* name */
      'ɵinj',
      /* type */
      INFERRED_TYPE,
      /* modifiers */
      [StmtModifier.Static],
      /* initializer */
      injectorDef)],
      /* getters */
      [],
      /* constructorMethod */
      new ClassMethod(null, [], []),
      /* methods */
      []));
    }

    function accessExportScope(module) {
      var selectorScope = new ReadPropExpr(module, 'ɵmod');
      return new ReadPropExpr(selectorScope, 'exported');
    }

    function tupleTypeOf(exp) {
      var types = exp.map(function (ref) {
        return typeofExpr(ref.type);
      });
      return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;
    }

    function refsToArray(refs, shouldForwardDeclare) {
      var values = literalArr(refs.map(function (ref) {
        return ref.value;
      }));
      return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function compilePipeFromMetadata(metadata) {
      var definitionMapValues = []; // e.g. `name: 'myPipe'`

      definitionMapValues.push({
        key: 'name',
        value: literal(metadata.pipeName),
        quoted: false
      }); // e.g. `type: MyPipe`

      definitionMapValues.push({
        key: 'type',
        value: metadata.type.value,
        quoted: false
      }); // e.g. `pure: true`

      definitionMapValues.push({
        key: 'pure',
        value: literal(metadata.pure),
        quoted: false
      });
      var expression = importExpr(Identifiers$1.definePipe).callFn([literalMap(definitionMapValues)]);
      var type = new ExpressionType(importExpr(Identifiers$1.PipeDefWithMeta, [typeWithParameters(metadata.type.type, metadata.typeArgumentCount), new ExpressionType(new LiteralExpr(metadata.pipeName))]));
      return {
        expression: expression,
        type: type
      };
    }
    /**
     * Write a pipe definition to the output context.
     */


    function compilePipeFromRender2(outputCtx, pipe, reflector) {
      var name = identifierName(pipe.type);

      if (!name) {
        return error("Cannot resolve the name of ".concat(pipe.type));
      }

      var type = outputCtx.importExpr(pipe.type.reference);
      var metadata = {
        name: name,
        type: wrapReference(type),
        internalType: type,
        pipeName: pipe.name,
        typeArgumentCount: 0,
        deps: dependenciesFromGlobalMetadata(pipe.type, outputCtx, reflector),
        pure: pipe.pure
      };
      var res = compilePipeFromMetadata(metadata);
      var factoryRes = compileFactoryFunction(Object.assign(Object.assign({}, metadata), {
        injectFn: Identifiers$1.directiveInject,
        target: R3FactoryTarget.Pipe
      }));
      var definitionField = outputCtx.constantPool.propertyNameOf(3
      /* Pipe */
      );
      var ngFactoryDefStatement = new ClassStmt(
      /* name */
      name,
      /* parent */
      null,
      /* fields */
      [new ClassField(
      /* name */
      'ɵfac',
      /* type */
      INFERRED_TYPE,
      /* modifiers */
      [StmtModifier.Static],
      /* initializer */
      factoryRes.factory)],
      /* getters */
      [],
      /* constructorMethod */
      new ClassMethod(null, [], []),
      /* methods */
      []);
      var pipeDefStatement = new ClassStmt(
      /* name */
      name,
      /* parent */
      null,
      /* fields */
      [new ClassField(
      /* name */
      definitionField,
      /* type */
      INFERRED_TYPE,
      /* modifiers */
      [StmtModifier.Static],
      /* initializer */
      res.expression)],
      /* getters */
      [],
      /* constructorMethod */
      new ClassMethod(null, [], []),
      /* methods */
      []);
      outputCtx.statements.push(ngFactoryDefStatement, pipeDefStatement);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var ParserError = function ParserError(message, input, errLocation, ctxLocation) {
      _classCallCheck(this, ParserError);

      this.input = input;
      this.errLocation = errLocation;
      this.ctxLocation = ctxLocation;
      this.message = "Parser Error: ".concat(message, " ").concat(errLocation, " [").concat(input, "] in ").concat(ctxLocation);
    };

    var ParseSpan =
    /*#__PURE__*/
    function () {
      function ParseSpan(start, end) {
        _classCallCheck(this, ParseSpan);

        this.start = start;
        this.end = end;
      }

      _createClass(ParseSpan, [{
        key: "toAbsolute",
        value: function toAbsolute(absoluteOffset) {
          return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);
        }
      }]);

      return ParseSpan;
    }();

    var AST =
    /*#__PURE__*/
    function () {
      function AST(span,
      /**
       * Absolute location of the expression AST in a source code file.
       */
      sourceSpan) {
        _classCallCheck(this, AST);

        this.span = span;
        this.sourceSpan = sourceSpan;
      }

      _createClass(AST, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return null;
        }
      }, {
        key: "toString",
        value: function toString() {
          return 'AST';
        }
      }]);

      return AST;
    }();
    /**
     * Represents a quoted expression of the form:
     *
     * quote = prefix `:` uninterpretedExpression
     * prefix = identifier
     * uninterpretedExpression = arbitrary string
     *
     * A quoted expression is meant to be pre-processed by an AST transformer that
     * converts it into another AST that no longer contains quoted expressions.
     * It is meant to allow third-party developers to extend Angular template
     * expression language. The `uninterpretedExpression` part of the quote is
     * therefore not interpreted by the Angular's own expression parser.
     */


    var Quote =
    /*#__PURE__*/
    function (_AST) {
      _inherits(Quote, _AST);

      function Quote(span, sourceSpan, prefix, uninterpretedExpression, location) {
        var _this86;

        _classCallCheck(this, Quote);

        _this86 = _possibleConstructorReturn(this, _getPrototypeOf(Quote).call(this, span, sourceSpan));
        _this86.prefix = prefix;
        _this86.uninterpretedExpression = uninterpretedExpression;
        _this86.location = location;
        return _this86;
      }

      _createClass(Quote, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitQuote(this, context);
        }
      }, {
        key: "toString",
        value: function toString() {
          return 'Quote';
        }
      }]);

      return Quote;
    }(AST);

    var EmptyExpr =
    /*#__PURE__*/
    function (_AST2) {
      _inherits(EmptyExpr, _AST2);

      function EmptyExpr() {
        _classCallCheck(this, EmptyExpr);

        return _possibleConstructorReturn(this, _getPrototypeOf(EmptyExpr).apply(this, arguments));
      }

      _createClass(EmptyExpr, [{
        key: "visit",
        value: function visit(visitor) {// do nothing

          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        }
      }]);

      return EmptyExpr;
    }(AST);

    var ImplicitReceiver =
    /*#__PURE__*/
    function (_AST3) {
      _inherits(ImplicitReceiver, _AST3);

      function ImplicitReceiver() {
        _classCallCheck(this, ImplicitReceiver);

        return _possibleConstructorReturn(this, _getPrototypeOf(ImplicitReceiver).apply(this, arguments));
      }

      _createClass(ImplicitReceiver, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitImplicitReceiver(this, context);
        }
      }]);

      return ImplicitReceiver;
    }(AST);
    /**
     * Multiple expressions separated by a semicolon.
     */


    var Chain =
    /*#__PURE__*/
    function (_AST4) {
      _inherits(Chain, _AST4);

      function Chain(span, sourceSpan, expressions) {
        var _this87;

        _classCallCheck(this, Chain);

        _this87 = _possibleConstructorReturn(this, _getPrototypeOf(Chain).call(this, span, sourceSpan));
        _this87.expressions = expressions;
        return _this87;
      }

      _createClass(Chain, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitChain(this, context);
        }
      }]);

      return Chain;
    }(AST);

    var Conditional =
    /*#__PURE__*/
    function (_AST5) {
      _inherits(Conditional, _AST5);

      function Conditional(span, sourceSpan, condition, trueExp, falseExp) {
        var _this88;

        _classCallCheck(this, Conditional);

        _this88 = _possibleConstructorReturn(this, _getPrototypeOf(Conditional).call(this, span, sourceSpan));
        _this88.condition = condition;
        _this88.trueExp = trueExp;
        _this88.falseExp = falseExp;
        return _this88;
      }

      _createClass(Conditional, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitConditional(this, context);
        }
      }]);

      return Conditional;
    }(AST);

    var PropertyRead =
    /*#__PURE__*/
    function (_AST6) {
      _inherits(PropertyRead, _AST6);

      function PropertyRead(span, sourceSpan, receiver, name) {
        var _this89;

        _classCallCheck(this, PropertyRead);

        _this89 = _possibleConstructorReturn(this, _getPrototypeOf(PropertyRead).call(this, span, sourceSpan));
        _this89.receiver = receiver;
        _this89.name = name;
        return _this89;
      }

      _createClass(PropertyRead, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitPropertyRead(this, context);
        }
      }]);

      return PropertyRead;
    }(AST);

    var PropertyWrite =
    /*#__PURE__*/
    function (_AST7) {
      _inherits(PropertyWrite, _AST7);

      function PropertyWrite(span, sourceSpan, receiver, name, value) {
        var _this90;

        _classCallCheck(this, PropertyWrite);

        _this90 = _possibleConstructorReturn(this, _getPrototypeOf(PropertyWrite).call(this, span, sourceSpan));
        _this90.receiver = receiver;
        _this90.name = name;
        _this90.value = value;
        return _this90;
      }

      _createClass(PropertyWrite, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitPropertyWrite(this, context);
        }
      }]);

      return PropertyWrite;
    }(AST);

    var SafePropertyRead =
    /*#__PURE__*/
    function (_AST8) {
      _inherits(SafePropertyRead, _AST8);

      function SafePropertyRead(span, sourceSpan, receiver, name) {
        var _this91;

        _classCallCheck(this, SafePropertyRead);

        _this91 = _possibleConstructorReturn(this, _getPrototypeOf(SafePropertyRead).call(this, span, sourceSpan));
        _this91.receiver = receiver;
        _this91.name = name;
        return _this91;
      }

      _createClass(SafePropertyRead, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitSafePropertyRead(this, context);
        }
      }]);

      return SafePropertyRead;
    }(AST);

    var KeyedRead =
    /*#__PURE__*/
    function (_AST9) {
      _inherits(KeyedRead, _AST9);

      function KeyedRead(span, sourceSpan, obj, key) {
        var _this92;

        _classCallCheck(this, KeyedRead);

        _this92 = _possibleConstructorReturn(this, _getPrototypeOf(KeyedRead).call(this, span, sourceSpan));
        _this92.obj = obj;
        _this92.key = key;
        return _this92;
      }

      _createClass(KeyedRead, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitKeyedRead(this, context);
        }
      }]);

      return KeyedRead;
    }(AST);

    var KeyedWrite =
    /*#__PURE__*/
    function (_AST10) {
      _inherits(KeyedWrite, _AST10);

      function KeyedWrite(span, sourceSpan, obj, key, value) {
        var _this93;

        _classCallCheck(this, KeyedWrite);

        _this93 = _possibleConstructorReturn(this, _getPrototypeOf(KeyedWrite).call(this, span, sourceSpan));
        _this93.obj = obj;
        _this93.key = key;
        _this93.value = value;
        return _this93;
      }

      _createClass(KeyedWrite, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitKeyedWrite(this, context);
        }
      }]);

      return KeyedWrite;
    }(AST);

    var BindingPipe =
    /*#__PURE__*/
    function (_AST11) {
      _inherits(BindingPipe, _AST11);

      function BindingPipe(span, sourceSpan, exp, name, args, nameSpan) {
        var _this94;

        _classCallCheck(this, BindingPipe);

        _this94 = _possibleConstructorReturn(this, _getPrototypeOf(BindingPipe).call(this, span, sourceSpan));
        _this94.exp = exp;
        _this94.name = name;
        _this94.args = args;
        _this94.nameSpan = nameSpan;
        return _this94;
      }

      _createClass(BindingPipe, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitPipe(this, context);
        }
      }]);

      return BindingPipe;
    }(AST);

    var LiteralPrimitive =
    /*#__PURE__*/
    function (_AST12) {
      _inherits(LiteralPrimitive, _AST12);

      function LiteralPrimitive(span, sourceSpan, value) {
        var _this95;

        _classCallCheck(this, LiteralPrimitive);

        _this95 = _possibleConstructorReturn(this, _getPrototypeOf(LiteralPrimitive).call(this, span, sourceSpan));
        _this95.value = value;
        return _this95;
      }

      _createClass(LiteralPrimitive, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitLiteralPrimitive(this, context);
        }
      }]);

      return LiteralPrimitive;
    }(AST);

    var LiteralArray =
    /*#__PURE__*/
    function (_AST13) {
      _inherits(LiteralArray, _AST13);

      function LiteralArray(span, sourceSpan, expressions) {
        var _this96;

        _classCallCheck(this, LiteralArray);

        _this96 = _possibleConstructorReturn(this, _getPrototypeOf(LiteralArray).call(this, span, sourceSpan));
        _this96.expressions = expressions;
        return _this96;
      }

      _createClass(LiteralArray, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitLiteralArray(this, context);
        }
      }]);

      return LiteralArray;
    }(AST);

    var LiteralMap =
    /*#__PURE__*/
    function (_AST14) {
      _inherits(LiteralMap, _AST14);

      function LiteralMap(span, sourceSpan, keys, values) {
        var _this97;

        _classCallCheck(this, LiteralMap);

        _this97 = _possibleConstructorReturn(this, _getPrototypeOf(LiteralMap).call(this, span, sourceSpan));
        _this97.keys = keys;
        _this97.values = values;
        return _this97;
      }

      _createClass(LiteralMap, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitLiteralMap(this, context);
        }
      }]);

      return LiteralMap;
    }(AST);

    var Interpolation =
    /*#__PURE__*/
    function (_AST15) {
      _inherits(Interpolation, _AST15);

      function Interpolation(span, sourceSpan, strings, expressions) {
        var _this98;

        _classCallCheck(this, Interpolation);

        _this98 = _possibleConstructorReturn(this, _getPrototypeOf(Interpolation).call(this, span, sourceSpan));
        _this98.strings = strings;
        _this98.expressions = expressions;
        return _this98;
      }

      _createClass(Interpolation, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitInterpolation(this, context);
        }
      }]);

      return Interpolation;
    }(AST);

    var Binary =
    /*#__PURE__*/
    function (_AST16) {
      _inherits(Binary, _AST16);

      function Binary(span, sourceSpan, operation, left, right) {
        var _this99;

        _classCallCheck(this, Binary);

        _this99 = _possibleConstructorReturn(this, _getPrototypeOf(Binary).call(this, span, sourceSpan));
        _this99.operation = operation;
        _this99.left = left;
        _this99.right = right;
        return _this99;
      }

      _createClass(Binary, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitBinary(this, context);
        }
      }]);

      return Binary;
    }(AST);

    var PrefixNot =
    /*#__PURE__*/
    function (_AST17) {
      _inherits(PrefixNot, _AST17);

      function PrefixNot(span, sourceSpan, expression) {
        var _this100;

        _classCallCheck(this, PrefixNot);

        _this100 = _possibleConstructorReturn(this, _getPrototypeOf(PrefixNot).call(this, span, sourceSpan));
        _this100.expression = expression;
        return _this100;
      }

      _createClass(PrefixNot, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitPrefixNot(this, context);
        }
      }]);

      return PrefixNot;
    }(AST);

    var NonNullAssert =
    /*#__PURE__*/
    function (_AST18) {
      _inherits(NonNullAssert, _AST18);

      function NonNullAssert(span, sourceSpan, expression) {
        var _this101;

        _classCallCheck(this, NonNullAssert);

        _this101 = _possibleConstructorReturn(this, _getPrototypeOf(NonNullAssert).call(this, span, sourceSpan));
        _this101.expression = expression;
        return _this101;
      }

      _createClass(NonNullAssert, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitNonNullAssert(this, context);
        }
      }]);

      return NonNullAssert;
    }(AST);

    var MethodCall =
    /*#__PURE__*/
    function (_AST19) {
      _inherits(MethodCall, _AST19);

      function MethodCall(span, sourceSpan, receiver, name, args) {
        var _this102;

        _classCallCheck(this, MethodCall);

        _this102 = _possibleConstructorReturn(this, _getPrototypeOf(MethodCall).call(this, span, sourceSpan));
        _this102.receiver = receiver;
        _this102.name = name;
        _this102.args = args;
        return _this102;
      }

      _createClass(MethodCall, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitMethodCall(this, context);
        }
      }]);

      return MethodCall;
    }(AST);

    var SafeMethodCall =
    /*#__PURE__*/
    function (_AST20) {
      _inherits(SafeMethodCall, _AST20);

      function SafeMethodCall(span, sourceSpan, receiver, name, args) {
        var _this103;

        _classCallCheck(this, SafeMethodCall);

        _this103 = _possibleConstructorReturn(this, _getPrototypeOf(SafeMethodCall).call(this, span, sourceSpan));
        _this103.receiver = receiver;
        _this103.name = name;
        _this103.args = args;
        return _this103;
      }

      _createClass(SafeMethodCall, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitSafeMethodCall(this, context);
        }
      }]);

      return SafeMethodCall;
    }(AST);

    var FunctionCall =
    /*#__PURE__*/
    function (_AST21) {
      _inherits(FunctionCall, _AST21);

      function FunctionCall(span, sourceSpan, target, args) {
        var _this104;

        _classCallCheck(this, FunctionCall);

        _this104 = _possibleConstructorReturn(this, _getPrototypeOf(FunctionCall).call(this, span, sourceSpan));
        _this104.target = target;
        _this104.args = args;
        return _this104;
      }

      _createClass(FunctionCall, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return visitor.visitFunctionCall(this, context);
        }
      }]);

      return FunctionCall;
    }(AST);
    /**
     * Records the absolute position of a text span in a source file, where `start` and `end` are the
     * starting and ending byte offsets, respectively, of the text span in a source file.
     */


    var AbsoluteSourceSpan = function AbsoluteSourceSpan(start, end) {
      _classCallCheck(this, AbsoluteSourceSpan);

      this.start = start;
      this.end = end;
    };

    var ASTWithSource =
    /*#__PURE__*/
    function (_AST22) {
      _inherits(ASTWithSource, _AST22);

      function ASTWithSource(ast, source, location, absoluteOffset, errors) {
        var _this105;

        _classCallCheck(this, ASTWithSource);

        _this105 = _possibleConstructorReturn(this, _getPrototypeOf(ASTWithSource).call(this, new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length)));
        _this105.ast = ast;
        _this105.source = source;
        _this105.location = location;
        _this105.errors = errors;
        return _this105;
      }

      _createClass(ASTWithSource, [{
        key: "visit",
        value: function visit(visitor) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (visitor.visitASTWithSource) {
            return visitor.visitASTWithSource(this, context);
          }

          return this.ast.visit(visitor, context);
        }
      }, {
        key: "toString",
        value: function toString() {
          return "".concat(this.source, " in ").concat(this.location);
        }
      }]);

      return ASTWithSource;
    }(AST);

    var TemplateBinding = function TemplateBinding(span, sourceSpan, key, keyIsVar, name, expression) {
      _classCallCheck(this, TemplateBinding);

      this.span = span;
      this.key = key;
      this.keyIsVar = keyIsVar;
      this.name = name;
      this.expression = expression;
    };

    var NullAstVisitor =
    /*#__PURE__*/
    function () {
      function NullAstVisitor() {
        _classCallCheck(this, NullAstVisitor);
      }

      _createClass(NullAstVisitor, [{
        key: "visitBinary",
        value: function visitBinary(ast, context) {}
      }, {
        key: "visitChain",
        value: function visitChain(ast, context) {}
      }, {
        key: "visitConditional",
        value: function visitConditional(ast, context) {}
      }, {
        key: "visitFunctionCall",
        value: function visitFunctionCall(ast, context) {}
      }, {
        key: "visitImplicitReceiver",
        value: function visitImplicitReceiver(ast, context) {}
      }, {
        key: "visitInterpolation",
        value: function visitInterpolation(ast, context) {}
      }, {
        key: "visitKeyedRead",
        value: function visitKeyedRead(ast, context) {}
      }, {
        key: "visitKeyedWrite",
        value: function visitKeyedWrite(ast, context) {}
      }, {
        key: "visitLiteralArray",
        value: function visitLiteralArray(ast, context) {}
      }, {
        key: "visitLiteralMap",
        value: function visitLiteralMap(ast, context) {}
      }, {
        key: "visitLiteralPrimitive",
        value: function visitLiteralPrimitive(ast, context) {}
      }, {
        key: "visitMethodCall",
        value: function visitMethodCall(ast, context) {}
      }, {
        key: "visitPipe",
        value: function visitPipe(ast, context) {}
      }, {
        key: "visitPrefixNot",
        value: function visitPrefixNot(ast, context) {}
      }, {
        key: "visitNonNullAssert",
        value: function visitNonNullAssert(ast, context) {}
      }, {
        key: "visitPropertyRead",
        value: function visitPropertyRead(ast, context) {}
      }, {
        key: "visitPropertyWrite",
        value: function visitPropertyWrite(ast, context) {}
      }, {
        key: "visitQuote",
        value: function visitQuote(ast, context) {}
      }, {
        key: "visitSafeMethodCall",
        value: function visitSafeMethodCall(ast, context) {}
      }, {
        key: "visitSafePropertyRead",
        value: function visitSafePropertyRead(ast, context) {}
      }]);

      return NullAstVisitor;
    }();

    var RecursiveAstVisitor$1 =
    /*#__PURE__*/
    function () {
      function RecursiveAstVisitor$1() {
        _classCallCheck(this, RecursiveAstVisitor$1);
      }

      _createClass(RecursiveAstVisitor$1, [{
        key: "visitBinary",
        value: function visitBinary(ast, context) {
          ast.left.visit(this, context);
          ast.right.visit(this, context);
          return null;
        }
      }, {
        key: "visitChain",
        value: function visitChain(ast, context) {
          return this.visitAll(ast.expressions, context);
        }
      }, {
        key: "visitConditional",
        value: function visitConditional(ast, context) {
          ast.condition.visit(this, context);
          ast.trueExp.visit(this, context);
          ast.falseExp.visit(this, context);
          return null;
        }
      }, {
        key: "visitPipe",
        value: function visitPipe(ast, context) {
          ast.exp.visit(this, context);
          this.visitAll(ast.args, context);
          return null;
        }
      }, {
        key: "visitFunctionCall",
        value: function visitFunctionCall(ast, context) {
          ast.target.visit(this, context);
          this.visitAll(ast.args, context);
          return null;
        }
      }, {
        key: "visitImplicitReceiver",
        value: function visitImplicitReceiver(ast, context) {
          return null;
        }
      }, {
        key: "visitInterpolation",
        value: function visitInterpolation(ast, context) {
          return this.visitAll(ast.expressions, context);
        }
      }, {
        key: "visitKeyedRead",
        value: function visitKeyedRead(ast, context) {
          ast.obj.visit(this, context);
          ast.key.visit(this, context);
          return null;
        }
      }, {
        key: "visitKeyedWrite",
        value: function visitKeyedWrite(ast, context) {
          ast.obj.visit(this, context);
          ast.key.visit(this, context);
          ast.value.visit(this, context);
          return null;
        }
      }, {
        key: "visitLiteralArray",
        value: function visitLiteralArray(ast, context) {
          return this.visitAll(ast.expressions, context);
        }
      }, {
        key: "visitLiteralMap",
        value: function visitLiteralMap(ast, context) {
          return this.visitAll(ast.values, context);
        }
      }, {
        key: "visitLiteralPrimitive",
        value: function visitLiteralPrimitive(ast, context) {
          return null;
        }
      }, {
        key: "visitMethodCall",
        value: function visitMethodCall(ast, context) {
          ast.receiver.visit(this, context);
          return this.visitAll(ast.args, context);
        }
      }, {
        key: "visitPrefixNot",
        value: function visitPrefixNot(ast, context) {
          ast.expression.visit(this, context);
          return null;
        }
      }, {
        key: "visitNonNullAssert",
        value: function visitNonNullAssert(ast, context) {
          ast.expression.visit(this, context);
          return null;
        }
      }, {
        key: "visitPropertyRead",
        value: function visitPropertyRead(ast, context) {
          ast.receiver.visit(this, context);
          return null;
        }
      }, {
        key: "visitPropertyWrite",
        value: function visitPropertyWrite(ast, context) {
          ast.receiver.visit(this, context);
          ast.value.visit(this, context);
          return null;
        }
      }, {
        key: "visitSafePropertyRead",
        value: function visitSafePropertyRead(ast, context) {
          ast.receiver.visit(this, context);
          return null;
        }
      }, {
        key: "visitSafeMethodCall",
        value: function visitSafeMethodCall(ast, context) {
          ast.receiver.visit(this, context);
          return this.visitAll(ast.args, context);
        }
      }, {
        key: "visitAll",
        value: function visitAll(asts, context) {
          var _this106 = this;

          asts.forEach(function (ast) {
            return ast.visit(_this106, context);
          });
          return null;
        }
      }, {
        key: "visitQuote",
        value: function visitQuote(ast, context) {
          return null;
        }
      }]);

      return RecursiveAstVisitor$1;
    }();

    var AstTransformer$1 =
    /*#__PURE__*/
    function () {
      function AstTransformer$1() {
        _classCallCheck(this, AstTransformer$1);
      }

      _createClass(AstTransformer$1, [{
        key: "visitImplicitReceiver",
        value: function visitImplicitReceiver(ast, context) {
          return ast;
        }
      }, {
        key: "visitInterpolation",
        value: function visitInterpolation(ast, context) {
          return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));
        }
      }, {
        key: "visitLiteralPrimitive",
        value: function visitLiteralPrimitive(ast, context) {
          return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);
        }
      }, {
        key: "visitPropertyRead",
        value: function visitPropertyRead(ast, context) {
          return new PropertyRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name);
        }
      }, {
        key: "visitPropertyWrite",
        value: function visitPropertyWrite(ast, context) {
          return new PropertyWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));
        }
      }, {
        key: "visitSafePropertyRead",
        value: function visitSafePropertyRead(ast, context) {
          return new SafePropertyRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name);
        }
      }, {
        key: "visitMethodCall",
        value: function visitMethodCall(ast, context) {
          return new MethodCall(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
        }
      }, {
        key: "visitSafeMethodCall",
        value: function visitSafeMethodCall(ast, context) {
          return new SafeMethodCall(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
        }
      }, {
        key: "visitFunctionCall",
        value: function visitFunctionCall(ast, context) {
          return new FunctionCall(ast.span, ast.sourceSpan, ast.target.visit(this), this.visitAll(ast.args));
        }
      }, {
        key: "visitLiteralArray",
        value: function visitLiteralArray(ast, context) {
          return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
        }
      }, {
        key: "visitLiteralMap",
        value: function visitLiteralMap(ast, context) {
          return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));
        }
      }, {
        key: "visitBinary",
        value: function visitBinary(ast, context) {
          return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));
        }
      }, {
        key: "visitPrefixNot",
        value: function visitPrefixNot(ast, context) {
          return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));
        }
      }, {
        key: "visitNonNullAssert",
        value: function visitNonNullAssert(ast, context) {
          return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));
        }
      }, {
        key: "visitConditional",
        value: function visitConditional(ast, context) {
          return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
        }
      }, {
        key: "visitPipe",
        value: function visitPipe(ast, context) {
          return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);
        }
      }, {
        key: "visitKeyedRead",
        value: function visitKeyedRead(ast, context) {
          return new KeyedRead(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this));
        }
      }, {
        key: "visitKeyedWrite",
        value: function visitKeyedWrite(ast, context) {
          return new KeyedWrite(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
        }
      }, {
        key: "visitAll",
        value: function visitAll(asts) {
          var res = [];

          for (var i = 0; i < asts.length; ++i) {
            res[i] = asts[i].visit(this);
          }

          return res;
        }
      }, {
        key: "visitChain",
        value: function visitChain(ast, context) {
          return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
        }
      }, {
        key: "visitQuote",
        value: function visitQuote(ast, context) {
          return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);
        }
      }]);

      return AstTransformer$1;
    }(); // A transformer that only creates new nodes if the transformer makes a change or
    // a change is made a child node.


    var AstMemoryEfficientTransformer =
    /*#__PURE__*/
    function () {
      function AstMemoryEfficientTransformer() {
        _classCallCheck(this, AstMemoryEfficientTransformer);
      }

      _createClass(AstMemoryEfficientTransformer, [{
        key: "visitImplicitReceiver",
        value: function visitImplicitReceiver(ast, context) {
          return ast;
        }
      }, {
        key: "visitInterpolation",
        value: function visitInterpolation(ast, context) {
          var expressions = this.visitAll(ast.expressions);
          if (expressions !== ast.expressions) return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);
          return ast;
        }
      }, {
        key: "visitLiteralPrimitive",
        value: function visitLiteralPrimitive(ast, context) {
          return ast;
        }
      }, {
        key: "visitPropertyRead",
        value: function visitPropertyRead(ast, context) {
          var receiver = ast.receiver.visit(this);

          if (receiver !== ast.receiver) {
            return new PropertyRead(ast.span, ast.sourceSpan, receiver, ast.name);
          }

          return ast;
        }
      }, {
        key: "visitPropertyWrite",
        value: function visitPropertyWrite(ast, context) {
          var receiver = ast.receiver.visit(this);
          var value = ast.value.visit(this);

          if (receiver !== ast.receiver || value !== ast.value) {
            return new PropertyWrite(ast.span, ast.sourceSpan, receiver, ast.name, value);
          }

          return ast;
        }
      }, {
        key: "visitSafePropertyRead",
        value: function visitSafePropertyRead(ast, context) {
          var receiver = ast.receiver.visit(this);

          if (receiver !== ast.receiver) {
            return new SafePropertyRead(ast.span, ast.sourceSpan, receiver, ast.name);
          }

          return ast;
        }
      }, {
        key: "visitMethodCall",
        value: function visitMethodCall(ast, context) {
          var receiver = ast.receiver.visit(this);
          var args = this.visitAll(ast.args);

          if (receiver !== ast.receiver || args !== ast.args) {
            return new MethodCall(ast.span, ast.sourceSpan, receiver, ast.name, args);
          }

          return ast;
        }
      }, {
        key: "visitSafeMethodCall",
        value: function visitSafeMethodCall(ast, context) {
          var receiver = ast.receiver.visit(this);
          var args = this.visitAll(ast.args);

          if (receiver !== ast.receiver || args !== ast.args) {
            return new SafeMethodCall(ast.span, ast.sourceSpan, receiver, ast.name, args);
          }

          return ast;
        }
      }, {
        key: "visitFunctionCall",
        value: function visitFunctionCall(ast, context) {
          var target = ast.target && ast.target.visit(this);
          var args = this.visitAll(ast.args);

          if (target !== ast.target || args !== ast.args) {
            return new FunctionCall(ast.span, ast.sourceSpan, target, args);
          }

          return ast;
        }
      }, {
        key: "visitLiteralArray",
        value: function visitLiteralArray(ast, context) {
          var expressions = this.visitAll(ast.expressions);

          if (expressions !== ast.expressions) {
            return new LiteralArray(ast.span, ast.sourceSpan, expressions);
          }

          return ast;
        }
      }, {
        key: "visitLiteralMap",
        value: function visitLiteralMap(ast, context) {
          var values = this.visitAll(ast.values);

          if (values !== ast.values) {
            return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);
          }

          return ast;
        }
      }, {
        key: "visitBinary",
        value: function visitBinary(ast, context) {
          var left = ast.left.visit(this);
          var right = ast.right.visit(this);

          if (left !== ast.left || right !== ast.right) {
            return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);
          }

          return ast;
        }
      }, {
        key: "visitPrefixNot",
        value: function visitPrefixNot(ast, context) {
          var expression = ast.expression.visit(this);

          if (expression !== ast.expression) {
            return new PrefixNot(ast.span, ast.sourceSpan, expression);
          }

          return ast;
        }
      }, {
        key: "visitNonNullAssert",
        value: function visitNonNullAssert(ast, context) {
          var expression = ast.expression.visit(this);

          if (expression !== ast.expression) {
            return new NonNullAssert(ast.span, ast.sourceSpan, expression);
          }

          return ast;
        }
      }, {
        key: "visitConditional",
        value: function visitConditional(ast, context) {
          var condition = ast.condition.visit(this);
          var trueExp = ast.trueExp.visit(this);
          var falseExp = ast.falseExp.visit(this);

          if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {
            return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);
          }

          return ast;
        }
      }, {
        key: "visitPipe",
        value: function visitPipe(ast, context) {
          var exp = ast.exp.visit(this);
          var args = this.visitAll(ast.args);

          if (exp !== ast.exp || args !== ast.args) {
            return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);
          }

          return ast;
        }
      }, {
        key: "visitKeyedRead",
        value: function visitKeyedRead(ast, context) {
          var obj = ast.obj.visit(this);
          var key = ast.key.visit(this);

          if (obj !== ast.obj || key !== ast.key) {
            return new KeyedRead(ast.span, ast.sourceSpan, obj, key);
          }

          return ast;
        }
      }, {
        key: "visitKeyedWrite",
        value: function visitKeyedWrite(ast, context) {
          var obj = ast.obj.visit(this);
          var key = ast.key.visit(this);
          var value = ast.value.visit(this);

          if (obj !== ast.obj || key !== ast.key || value !== ast.value) {
            return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);
          }

          return ast;
        }
      }, {
        key: "visitAll",
        value: function visitAll(asts) {
          var res = [];
          var modified = false;

          for (var i = 0; i < asts.length; ++i) {
            var original = asts[i];
            var value = original.visit(this);
            res[i] = value;
            modified = modified || value !== original;
          }

          return modified ? res : asts;
        }
      }, {
        key: "visitChain",
        value: function visitChain(ast, context) {
          var expressions = this.visitAll(ast.expressions);

          if (expressions !== ast.expressions) {
            return new Chain(ast.span, ast.sourceSpan, expressions);
          }

          return ast;
        }
      }, {
        key: "visitQuote",
        value: function visitQuote(ast, context) {
          return ast;
        }
      }]);

      return AstMemoryEfficientTransformer;
    }();

    function visitAstChildren(ast, visitor, context) {
      function visit(ast) {
        visitor.visit && visitor.visit(ast, context) || ast.visit(visitor, context);
      }

      function visitAll(asts) {
        asts.forEach(visit);
      }

      ast.visit({
        visitBinary: function visitBinary(ast) {
          visit(ast.left);
          visit(ast.right);
        },
        visitChain: function visitChain(ast) {
          visitAll(ast.expressions);
        },
        visitConditional: function visitConditional(ast) {
          visit(ast.condition);
          visit(ast.trueExp);
          visit(ast.falseExp);
        },
        visitFunctionCall: function visitFunctionCall(ast) {
          if (ast.target) {
            visit(ast.target);
          }

          visitAll(ast.args);
        },
        visitImplicitReceiver: function visitImplicitReceiver(ast) {},
        visitInterpolation: function visitInterpolation(ast) {
          visitAll(ast.expressions);
        },
        visitKeyedRead: function visitKeyedRead(ast) {
          visit(ast.obj);
          visit(ast.key);
        },
        visitKeyedWrite: function visitKeyedWrite(ast) {
          visit(ast.obj);
          visit(ast.key);
          visit(ast.obj);
        },
        visitLiteralArray: function visitLiteralArray(ast) {
          visitAll(ast.expressions);
        },
        visitLiteralMap: function visitLiteralMap(ast) {},
        visitLiteralPrimitive: function visitLiteralPrimitive(ast) {},
        visitMethodCall: function visitMethodCall(ast) {
          visit(ast.receiver);
          visitAll(ast.args);
        },
        visitPipe: function visitPipe(ast) {
          visit(ast.exp);
          visitAll(ast.args);
        },
        visitPrefixNot: function visitPrefixNot(ast) {
          visit(ast.expression);
        },
        visitNonNullAssert: function visitNonNullAssert(ast) {
          visit(ast.expression);
        },
        visitPropertyRead: function visitPropertyRead(ast) {
          visit(ast.receiver);
        },
        visitPropertyWrite: function visitPropertyWrite(ast) {
          visit(ast.receiver);
          visit(ast.value);
        },
        visitQuote: function visitQuote(ast) {},
        visitSafeMethodCall: function visitSafeMethodCall(ast) {
          visit(ast.receiver);
          visitAll(ast.args);
        },
        visitSafePropertyRead: function visitSafePropertyRead(ast) {
          visit(ast.receiver);
        }
      });
    } // Bindings


    var ParsedProperty = function ParsedProperty(name, expression, type, sourceSpan, valueSpan) {
      _classCallCheck(this, ParsedProperty);

      this.name = name;
      this.expression = expression;
      this.type = type;
      this.sourceSpan = sourceSpan;
      this.valueSpan = valueSpan;
      this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;
      this.isAnimation = this.type === ParsedPropertyType.ANIMATION;
    };

    var ParsedPropertyType;

    (function (ParsedPropertyType) {
      ParsedPropertyType[ParsedPropertyType["DEFAULT"] = 0] = "DEFAULT";
      ParsedPropertyType[ParsedPropertyType["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
      ParsedPropertyType[ParsedPropertyType["ANIMATION"] = 2] = "ANIMATION";
    })(ParsedPropertyType || (ParsedPropertyType = {}));

    var ParsedEvent = // Regular events have a target
    // Animation events have a phase
    function ParsedEvent(name, targetOrPhase, type, handler, sourceSpan, handlerSpan) {
      _classCallCheck(this, ParsedEvent);

      this.name = name;
      this.targetOrPhase = targetOrPhase;
      this.type = type;
      this.handler = handler;
      this.sourceSpan = sourceSpan;
      this.handlerSpan = handlerSpan;
    };

    var ParsedVariable = function ParsedVariable(name, value, sourceSpan) {
      _classCallCheck(this, ParsedVariable);

      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    };

    var BoundElementProperty = function BoundElementProperty(name, type, securityContext, value, unit, sourceSpan, valueSpan) {
      _classCallCheck(this, BoundElementProperty);

      this.name = name;
      this.type = type;
      this.securityContext = securityContext;
      this.value = value;
      this.unit = unit;
      this.sourceSpan = sourceSpan;
      this.valueSpan = valueSpan;
    };
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var EventHandlerVars = function EventHandlerVars() {
      _classCallCheck(this, EventHandlerVars);
    };

    EventHandlerVars.event = variable('$event');

    var ConvertActionBindingResult = function ConvertActionBindingResult(
    /**
     * Render2 compatible statements,
     */
    stmts,
    /**
     * Variable name used with render2 compatible statements.
     */
    allowDefault) {
      _classCallCheck(this, ConvertActionBindingResult);

      this.stmts = stmts;
      this.allowDefault = allowDefault;
      /**
       * This is bit of a hack. It converts statements which render2 expects to statements which are
       * expected by render3.
       *
       * Example: `<div click="doSomething($event)">` will generate:
       *
       * Render3:
       * ```
       * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);
       * return pd_b;
       * ```
       *
       * but render2 expects:
       * ```
       * return ctx.doSomething($event);
       * ```
       */
      // TODO(misko): remove this hack once we no longer support ViewEngine.

      this.render3Stmts = stmts.map(function (statement) {
        if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name && statement.value instanceof BinaryOperatorExpr) {
          var lhs = statement.value.lhs;
          return new ReturnStatement(lhs.value);
        }

        return statement;
      });
    };
    /**
     * Converts the given expression AST into an executable output AST, assuming the expression is
     * used in an action binding (e.g. an event handler).
     */


    function convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {
      if (!localResolver) {
        localResolver = new DefaultLocalResolver();
      }

      var actionWithoutBuiltins = convertPropertyBindingBuiltins({
        createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {
          // Note: no caching for literal arrays in actions.
          return function (args) {
            return literalArr(args);
          };
        },
        createLiteralMapConverter: function createLiteralMapConverter(keys) {
          // Note: no caching for literal maps in actions.
          return function (values) {
            var entries = keys.map(function (k, i) {
              return {
                key: k.key,
                value: values[i],
                quoted: k.quoted
              };
            });
            return literalMap(entries);
          };
        },
        createPipeConverter: function createPipeConverter(name) {
          throw new Error("Illegal State: Actions are not allowed to contain pipes. Pipe: ".concat(name));
        }
      }, action);
      var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);
      var actionStmts = [];
      flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
      prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);

      if (visitor.usesImplicitReceiver) {
        localResolver.notifyImplicitReceiverUse();
      }

      var lastIndex = actionStmts.length - 1;
      var preventDefaultVar = null;

      if (lastIndex >= 0) {
        var lastStatement = actionStmts[lastIndex];
        var returnExpr = convertStmtIntoExpression(lastStatement);

        if (returnExpr) {
          // Note: We need to cast the result of the method call to dynamic,
          // as it might be a void method!
          preventDefaultVar = createPreventDefaultVar(bindingId);
          actionStmts[lastIndex] = preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false))).toDeclStmt(null, [StmtModifier.Final]);
        }
      }

      return new ConvertActionBindingResult(actionStmts, preventDefaultVar);
    }

    function convertPropertyBindingBuiltins(converterFactory, ast) {
      return convertBuiltins(converterFactory, ast);
    }

    var ConvertPropertyBindingResult = function ConvertPropertyBindingResult(stmts, currValExpr) {
      _classCallCheck(this, ConvertPropertyBindingResult);

      this.stmts = stmts;
      this.currValExpr = currValExpr;
    };

    var BindingForm;

    (function (BindingForm) {
      // The general form of binding expression, supports all expressions.
      BindingForm[BindingForm["General"] = 0] = "General"; // Try to generate a simple binding (no temporaries or statements)
      // otherwise generate a general binding

      BindingForm[BindingForm["TrySimple"] = 1] = "TrySimple";
    })(BindingForm || (BindingForm = {}));
    /**
     * Converts the given expression AST into an executable output AST, assuming the expression
     * is used in property binding. The expression has to be preprocessed via
     * `convertPropertyBindingBuiltins`.
     */


    function _convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {
      if (!localResolver) {
        localResolver = new DefaultLocalResolver();
      }

      var currValExpr = createCurrValueExpr(bindingId);
      var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);
      var outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
      var stmts = getStatementsFromVisitor(visitor, bindingId);

      if (visitor.usesImplicitReceiver) {
        localResolver.notifyImplicitReceiverUse();
      }

      if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {
        return new ConvertPropertyBindingResult([], outputExpr);
      }

      stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));
      return new ConvertPropertyBindingResult(stmts, currValExpr);
    }
    /**
     * Given some expression, such as a binding or interpolation expression, and a context expression to
     * look values up on, visit each facet of the given expression resolving values from the context
     * expression such that a list of arguments can be derived from the found values that can be used as
     * arguments to an external update instruction.
     *
     * @param localResolver The resolver to use to look up expressions by name appropriately
     * @param contextVariableExpression The expression representing the context variable used to create
     * the final argument expressions
     * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to
     * be resolved and what arguments list to build.
     * @param bindingId A name prefix used to create temporary variable names if they're needed for the
     * arguments generated
     * @returns An array of expressions that can be passed as arguments to instruction expressions like
     * `o.importExpr(R3.propertyInterpolate).callFn(result)`
     */


    function convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {
      var visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);
      var outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);

      if (visitor.usesImplicitReceiver) {
        localResolver.notifyImplicitReceiverUse();
      }

      var stmts = getStatementsFromVisitor(visitor, bindingId); // Removing the first argument, because it was a length for ViewEngine, not Ivy.

      var args = outputExpr.args.slice(1);

      if (expressionWithArgumentsToExtract instanceof Interpolation) {
        // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the
        // args returned to just the value, because we're going to pass it to a special instruction.
        var strings = expressionWithArgumentsToExtract.strings;

        if (args.length === 3 && strings[0] === '' && strings[1] === '') {
          // Single argument interpolate instructions.
          args = [args[1]];
        } else if (args.length >= 19) {
          // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept
          // an array of arguments
          args = [literalArr(args)];
        }
      }

      return {
        stmts: stmts,
        args: args
      };
    }

    function getStatementsFromVisitor(visitor, bindingId) {
      var stmts = [];

      for (var i = 0; i < visitor.temporaryCount; i++) {
        stmts.push(temporaryDeclaration(bindingId, i));
      }

      return stmts;
    }

    function convertBuiltins(converterFactory, ast) {
      var visitor = new _BuiltinAstConverter(converterFactory);
      return ast.visit(visitor);
    }

    function temporaryName(bindingId, temporaryNumber) {
      return "tmp_".concat(bindingId, "_").concat(temporaryNumber);
    }

    function temporaryDeclaration(bindingId, temporaryNumber) {
      return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);
    }

    function prependTemporaryDecls(temporaryCount, bindingId, statements) {
      for (var i = temporaryCount - 1; i >= 0; i--) {
        statements.unshift(temporaryDeclaration(bindingId, i));
      }
    }

    var _Mode;

    (function (_Mode) {
      _Mode[_Mode["Statement"] = 0] = "Statement";
      _Mode[_Mode["Expression"] = 1] = "Expression";
    })(_Mode || (_Mode = {}));

    function ensureStatementMode(mode, ast) {
      if (mode !== _Mode.Statement) {
        throw new Error("Expected a statement, but saw ".concat(ast));
      }
    }

    function ensureExpressionMode(mode, ast) {
      if (mode !== _Mode.Expression) {
        throw new Error("Expected an expression, but saw ".concat(ast));
      }
    }

    function convertToStatementIfNeeded(mode, expr) {
      if (mode === _Mode.Statement) {
        return expr.toStmt();
      } else {
        return expr;
      }
    }

    var _BuiltinAstConverter =
    /*#__PURE__*/
    function (_AstTransformer$) {
      _inherits(_BuiltinAstConverter, _AstTransformer$);

      function _BuiltinAstConverter(_converterFactory) {
        var _this107;

        _classCallCheck(this, _BuiltinAstConverter);

        _this107 = _possibleConstructorReturn(this, _getPrototypeOf(_BuiltinAstConverter).call(this));
        _this107._converterFactory = _converterFactory;
        return _this107;
      }

      _createClass(_BuiltinAstConverter, [{
        key: "visitPipe",
        value: function visitPipe(ast, context) {
          var _this108 = this;

          var args = [ast.exp].concat(_toConsumableArray(ast.args)).map(function (ast) {
            return ast.visit(_this108, context);
          });
          return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));
        }
      }, {
        key: "visitLiteralArray",
        value: function visitLiteralArray(ast, context) {
          var _this109 = this;

          var args = ast.expressions.map(function (ast) {
            return ast.visit(_this109, context);
          });
          return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
        }
      }, {
        key: "visitLiteralMap",
        value: function visitLiteralMap(ast, context) {
          var _this110 = this;

          var args = ast.values.map(function (ast) {
            return ast.visit(_this110, context);
          });
          return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));
        }
      }]);

      return _BuiltinAstConverter;
    }(AstTransformer$1);

    var _AstToIrVisitor =
    /*#__PURE__*/
    function () {
      function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {
        _classCallCheck(this, _AstToIrVisitor);

        this._localResolver = _localResolver;
        this._implicitReceiver = _implicitReceiver;
        this.bindingId = bindingId;
        this.interpolationFunction = interpolationFunction;
        this.baseSourceSpan = baseSourceSpan;
        this.implicitReceiverAccesses = implicitReceiverAccesses;
        this._nodeMap = new Map();
        this._resultMap = new Map();
        this._currentTemporary = 0;
        this.temporaryCount = 0;
        this.usesImplicitReceiver = false;
      }

      _createClass(_AstToIrVisitor, [{
        key: "visitBinary",
        value: function visitBinary(ast, mode) {
          var op;

          switch (ast.operation) {
            case '+':
              op = BinaryOperator.Plus;
              break;

            case '-':
              op = BinaryOperator.Minus;
              break;

            case '*':
              op = BinaryOperator.Multiply;
              break;

            case '/':
              op = BinaryOperator.Divide;
              break;

            case '%':
              op = BinaryOperator.Modulo;
              break;

            case '&&':
              op = BinaryOperator.And;
              break;

            case '||':
              op = BinaryOperator.Or;
              break;

            case '==':
              op = BinaryOperator.Equals;
              break;

            case '!=':
              op = BinaryOperator.NotEquals;
              break;

            case '===':
              op = BinaryOperator.Identical;
              break;

            case '!==':
              op = BinaryOperator.NotIdentical;
              break;

            case '<':
              op = BinaryOperator.Lower;
              break;

            case '>':
              op = BinaryOperator.Bigger;
              break;

            case '<=':
              op = BinaryOperator.LowerEquals;
              break;

            case '>=':
              op = BinaryOperator.BiggerEquals;
              break;

            default:
              throw new Error("Unsupported operation ".concat(ast.operation));
          }

          return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));
        }
      }, {
        key: "visitChain",
        value: function visitChain(ast, mode) {
          ensureStatementMode(mode, ast);
          return this.visitAll(ast.expressions, mode);
        }
      }, {
        key: "visitConditional",
        value: function visitConditional(ast, mode) {
          var value = this._visit(ast.condition, _Mode.Expression);

          return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));
        }
      }, {
        key: "visitPipe",
        value: function visitPipe(ast, mode) {
          throw new Error("Illegal state: Pipes should have been converted into functions. Pipe: ".concat(ast.name));
        }
      }, {
        key: "visitFunctionCall",
        value: function visitFunctionCall(ast, mode) {
          var convertedArgs = this.visitAll(ast.args, _Mode.Expression);
          var fnResult;

          if (ast instanceof BuiltinFunctionCall) {
            fnResult = ast.converter(convertedArgs);
          } else {
            fnResult = this._visit(ast.target, _Mode.Expression).callFn(convertedArgs, this.convertSourceSpan(ast.span));
          }

          return convertToStatementIfNeeded(mode, fnResult);
        }
      }, {
        key: "visitImplicitReceiver",
        value: function visitImplicitReceiver(ast, mode) {
          ensureExpressionMode(mode, ast);
          this.usesImplicitReceiver = true;
          return this._implicitReceiver;
        }
      }, {
        key: "visitInterpolation",
        value: function visitInterpolation(ast, mode) {
          ensureExpressionMode(mode, ast);
          var args = [literal(ast.expressions.length)];

          for (var i = 0; i < ast.strings.length - 1; i++) {
            args.push(literal(ast.strings[i]));
            args.push(this._visit(ast.expressions[i], _Mode.Expression));
          }

          args.push(literal(ast.strings[ast.strings.length - 1]));

          if (this.interpolationFunction) {
            return this.interpolationFunction(args);
          }

          return ast.expressions.length <= 9 ? importExpr(Identifiers.inlineInterpolate).callFn(args) : importExpr(Identifiers.interpolate).callFn([args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))]);
        }
      }, {
        key: "visitKeyedRead",
        value: function visitKeyedRead(ast, mode) {
          var leftMostSafe = this.leftMostSafeNode(ast);

          if (leftMostSafe) {
            return this.convertSafeAccess(ast, leftMostSafe, mode);
          } else {
            return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
          }
        }
      }, {
        key: "visitKeyedWrite",
        value: function visitKeyedWrite(ast, mode) {
          var obj = this._visit(ast.obj, _Mode.Expression);

          var key = this._visit(ast.key, _Mode.Expression);

          var value = this._visit(ast.value, _Mode.Expression);

          return convertToStatementIfNeeded(mode, obj.key(key).set(value));
        }
      }, {
        key: "visitLiteralArray",
        value: function visitLiteralArray(ast, mode) {
          throw new Error("Illegal State: literal arrays should have been converted into functions");
        }
      }, {
        key: "visitLiteralMap",
        value: function visitLiteralMap(ast, mode) {
          throw new Error("Illegal State: literal maps should have been converted into functions");
        }
      }, {
        key: "visitLiteralPrimitive",
        value: function visitLiteralPrimitive(ast, mode) {
          // For literal values of null, undefined, true, or false allow type interference
          // to infer the type.
          var type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ? INFERRED_TYPE : undefined;
          return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));
        }
      }, {
        key: "_getLocal",
        value: function _getLocal(name) {
          return this._localResolver.getLocal(name);
        }
      }, {
        key: "visitMethodCall",
        value: function visitMethodCall(ast, mode) {
          if (ast.receiver instanceof ImplicitReceiver && ast.name == '$any') {
            var args = this.visitAll(ast.args, _Mode.Expression);

            if (args.length != 1) {
              throw new Error("Invalid call to $any, expected 1 argument but received ".concat(args.length || 'none'));
            }

            return args[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span));
          }

          var leftMostSafe = this.leftMostSafeNode(ast);

          if (leftMostSafe) {
            return this.convertSafeAccess(ast, leftMostSafe, mode);
          } else {
            var _args = this.visitAll(ast.args, _Mode.Expression);

            var prevUsesImplicitReceiver = this.usesImplicitReceiver;
            var result = null;

            var receiver = this._visit(ast.receiver, _Mode.Expression);

            if (receiver === this._implicitReceiver) {
              var varExpr = this._getLocal(ast.name);

              if (varExpr) {
                // Restore the previous "usesImplicitReceiver" state since the implicit
                // receiver has been replaced with a resolved local expression.
                this.usesImplicitReceiver = prevUsesImplicitReceiver;
                result = varExpr.callFn(_args);
              }

              this.addImplicitReceiverAccess(ast.name);
            }

            if (result == null) {
              result = receiver.callMethod(ast.name, _args, this.convertSourceSpan(ast.span));
            }

            return convertToStatementIfNeeded(mode, result);
          }
        }
      }, {
        key: "visitPrefixNot",
        value: function visitPrefixNot(ast, mode) {
          return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));
        }
      }, {
        key: "visitNonNullAssert",
        value: function visitNonNullAssert(ast, mode) {
          return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));
        }
      }, {
        key: "visitPropertyRead",
        value: function visitPropertyRead(ast, mode) {
          var leftMostSafe = this.leftMostSafeNode(ast);

          if (leftMostSafe) {
            return this.convertSafeAccess(ast, leftMostSafe, mode);
          } else {
            var result = null;
            var prevUsesImplicitReceiver = this.usesImplicitReceiver;

            var receiver = this._visit(ast.receiver, _Mode.Expression);

            if (receiver === this._implicitReceiver) {
              result = this._getLocal(ast.name);

              if (result) {
                // Restore the previous "usesImplicitReceiver" state since the implicit
                // receiver has been replaced with a resolved local expression.
                this.usesImplicitReceiver = prevUsesImplicitReceiver;
              }

              this.addImplicitReceiverAccess(ast.name);
            }

            if (result == null) {
              result = receiver.prop(ast.name);
            }

            return convertToStatementIfNeeded(mode, result);
          }
        }
      }, {
        key: "visitPropertyWrite",
        value: function visitPropertyWrite(ast, mode) {
          var receiver = this._visit(ast.receiver, _Mode.Expression);

          var prevUsesImplicitReceiver = this.usesImplicitReceiver;
          var varExpr = null;

          if (receiver === this._implicitReceiver) {
            var localExpr = this._getLocal(ast.name);

            if (localExpr) {
              if (localExpr instanceof ReadPropExpr) {
                // If the local variable is a property read expression, it's a reference
                // to a 'context.property' value and will be used as the target of the
                // write expression.
                varExpr = localExpr; // Restore the previous "usesImplicitReceiver" state since the implicit
                // receiver has been replaced with a resolved local expression.

                this.usesImplicitReceiver = prevUsesImplicitReceiver;
                this.addImplicitReceiverAccess(ast.name);
              } else {
                // Otherwise it's an error.
                var _receiver = ast.name;
                var value = ast.value instanceof PropertyRead ? ast.value.name : undefined;
                throw new Error("Cannot assign value \"".concat(value, "\" to template variable \"").concat(_receiver, "\". Template variables are read-only."));
              }
            }
          } // If no local expression could be produced, use the original receiver's
          // property as the target.


          if (varExpr === null) {
            varExpr = receiver.prop(ast.name);
          }

          return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));
        }
      }, {
        key: "visitSafePropertyRead",
        value: function visitSafePropertyRead(ast, mode) {
          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
      }, {
        key: "visitSafeMethodCall",
        value: function visitSafeMethodCall(ast, mode) {
          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
      }, {
        key: "visitAll",
        value: function visitAll(asts, mode) {
          var _this111 = this;

          return asts.map(function (ast) {
            return _this111._visit(ast, mode);
          });
        }
      }, {
        key: "visitQuote",
        value: function visitQuote(ast, mode) {
          throw new Error("Quotes are not supported for evaluation!\n        Statement: ".concat(ast.uninterpretedExpression, " located at ").concat(ast.location));
        }
      }, {
        key: "_visit",
        value: function _visit(ast, mode) {
          var result = this._resultMap.get(ast);

          if (result) return result;
          return (this._nodeMap.get(ast) || ast).visit(this, mode);
        }
      }, {
        key: "convertSafeAccess",
        value: function convertSafeAccess(ast, leftMostSafe, mode) {
          // If the expression contains a safe access node on the left it needs to be converted to
          // an expression that guards the access to the member by checking the receiver for blank. As
          // execution proceeds from left to right, the left most part of the expression must be guarded
          // first but, because member access is left associative, the right side of the expression is at
          // the top of the AST. The desired result requires lifting a copy of the left part of the
          // expression up to test it for blank before generating the unguarded version.
          // Consider, for example the following expression: a?.b.c?.d.e
          // This results in the ast:
          //         .
          //        / \
          //       ?.   e
          //      /  \
          //     .    d
          //    / \
          //   ?.  c
          //  /  \
          // a    b
          // The following tree should be generated:
          //
          //        /---- ? ----\
          //       /      |      \
          //     a   /--- ? ---\  null
          //        /     |     \
          //       .      .     null
          //      / \    / \
          //     .  c   .   e
          //    / \    / \
          //   a   b  .   d
          //         / \
          //        .   c
          //       / \
          //      a   b
          //
          // Notice that the first guard condition is the left hand of the left most safe access node
          // which comes in as leftMostSafe to this routine.
          var guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);

          var temporary = undefined;

          if (this.needsTemporary(leftMostSafe.receiver)) {
            // If the expression has method calls or pipes then we need to save the result into a
            // temporary variable to avoid calling stateful or impure code more than once.
            temporary = this.allocateTemporary(); // Preserve the result in the temporary variable

            guardedExpression = temporary.set(guardedExpression); // Ensure all further references to the guarded expression refer to the temporary instead.

            this._resultMap.set(leftMostSafe.receiver, temporary);
          }

          var condition = guardedExpression.isBlank(); // Convert the ast to an unguarded access to the receiver's member. The map will substitute
          // leftMostNode with its unguarded version in the call to `this.visit()`.

          if (leftMostSafe instanceof SafeMethodCall) {
            this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));
          } else {
            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.name));
          } // Recursively convert the node now without the guarded member access.


          var access = this._visit(ast, _Mode.Expression); // Remove the mapping. This is not strictly required as the converter only traverses each node
          // once but is safer if the conversion is changed to traverse the nodes more than once.


          this._nodeMap.delete(leftMostSafe); // If we allocated a temporary, release it.


          if (temporary) {
            this.releaseTemporary(temporary);
          } // Produce the conditional


          return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));
        } // Given an expression of the form a?.b.c?.d.e then the left most safe node is
        // the (a?.b). The . and ?. are left associative thus can be rewritten as:
        // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or
        // safe method call as this needs to be transformed initially to:
        //   a == null ? null : a.c.b.c?.d.e
        // then to:
        //   a == null ? null : a.b.c == null ? null : a.b.c.d.e

      }, {
        key: "leftMostSafeNode",
        value: function leftMostSafeNode(ast) {
          var _this112 = this;

          var visit = function visit(visitor, ast) {
            return (_this112._nodeMap.get(ast) || ast).visit(visitor);
          };

          return ast.visit({
            visitBinary: function visitBinary(ast) {
              return null;
            },
            visitChain: function visitChain(ast) {
              return null;
            },
            visitConditional: function visitConditional(ast) {
              return null;
            },
            visitFunctionCall: function visitFunctionCall(ast) {
              return null;
            },
            visitImplicitReceiver: function visitImplicitReceiver(ast) {
              return null;
            },
            visitInterpolation: function visitInterpolation(ast) {
              return null;
            },
            visitKeyedRead: function visitKeyedRead(ast) {
              return visit(this, ast.obj);
            },
            visitKeyedWrite: function visitKeyedWrite(ast) {
              return null;
            },
            visitLiteralArray: function visitLiteralArray(ast) {
              return null;
            },
            visitLiteralMap: function visitLiteralMap(ast) {
              return null;
            },
            visitLiteralPrimitive: function visitLiteralPrimitive(ast) {
              return null;
            },
            visitMethodCall: function visitMethodCall(ast) {
              return visit(this, ast.receiver);
            },
            visitPipe: function visitPipe(ast) {
              return null;
            },
            visitPrefixNot: function visitPrefixNot(ast) {
              return null;
            },
            visitNonNullAssert: function visitNonNullAssert(ast) {
              return null;
            },
            visitPropertyRead: function visitPropertyRead(ast) {
              return visit(this, ast.receiver);
            },
            visitPropertyWrite: function visitPropertyWrite(ast) {
              return null;
            },
            visitQuote: function visitQuote(ast) {
              return null;
            },
            visitSafeMethodCall: function visitSafeMethodCall(ast) {
              return visit(this, ast.receiver) || ast;
            },
            visitSafePropertyRead: function visitSafePropertyRead(ast) {
              return visit(this, ast.receiver) || ast;
            }
          });
        } // Returns true of the AST includes a method or a pipe indicating that, if the
        // expression is used as the target of a safe property or method access then
        // the expression should be stored into a temporary variable.

      }, {
        key: "needsTemporary",
        value: function needsTemporary(ast) {
          var _this113 = this;

          var visit = function visit(visitor, ast) {
            return ast && (_this113._nodeMap.get(ast) || ast).visit(visitor);
          };

          var visitSome = function visitSome(visitor, ast) {
            return ast.some(function (ast) {
              return visit(visitor, ast);
            });
          };

          return ast.visit({
            visitBinary: function visitBinary(ast) {
              return visit(this, ast.left) || visit(this, ast.right);
            },
            visitChain: function visitChain(ast) {
              return false;
            },
            visitConditional: function visitConditional(ast) {
              return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);
            },
            visitFunctionCall: function visitFunctionCall(ast) {
              return true;
            },
            visitImplicitReceiver: function visitImplicitReceiver(ast) {
              return false;
            },
            visitInterpolation: function visitInterpolation(ast) {
              return visitSome(this, ast.expressions);
            },
            visitKeyedRead: function visitKeyedRead(ast) {
              return false;
            },
            visitKeyedWrite: function visitKeyedWrite(ast) {
              return false;
            },
            visitLiteralArray: function visitLiteralArray(ast) {
              return true;
            },
            visitLiteralMap: function visitLiteralMap(ast) {
              return true;
            },
            visitLiteralPrimitive: function visitLiteralPrimitive(ast) {
              return false;
            },
            visitMethodCall: function visitMethodCall(ast) {
              return true;
            },
            visitPipe: function visitPipe(ast) {
              return true;
            },
            visitPrefixNot: function visitPrefixNot(ast) {
              return visit(this, ast.expression);
            },
            visitNonNullAssert: function visitNonNullAssert(ast) {
              return visit(this, ast.expression);
            },
            visitPropertyRead: function visitPropertyRead(ast) {
              return false;
            },
            visitPropertyWrite: function visitPropertyWrite(ast) {
              return false;
            },
            visitQuote: function visitQuote(ast) {
              return false;
            },
            visitSafeMethodCall: function visitSafeMethodCall(ast) {
              return true;
            },
            visitSafePropertyRead: function visitSafePropertyRead(ast) {
              return false;
            }
          });
        }
      }, {
        key: "allocateTemporary",
        value: function allocateTemporary() {
          var tempNumber = this._currentTemporary++;
          this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
          return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
        }
      }, {
        key: "releaseTemporary",
        value: function releaseTemporary(temporary) {
          this._currentTemporary--;

          if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
            throw new Error("Temporary ".concat(temporary.name, " released out of order"));
          }
        }
        /**
         * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.
         *
         * `ParseSpan` objects are relative to the start of the expression.
         * This method converts these to full `ParseSourceSpan` objects that
         * show where the span is within the overall source file.
         *
         * @param span the relative span to convert.
         * @returns a `ParseSourceSpan` for the given span or null if no
         * `baseSourceSpan` was provided to this class.
         */

      }, {
        key: "convertSourceSpan",
        value: function convertSourceSpan(span) {
          if (this.baseSourceSpan) {
            var start = this.baseSourceSpan.start.moveBy(span.start);
            var end = this.baseSourceSpan.start.moveBy(span.end);
            return new ParseSourceSpan(start, end);
          } else {
            return null;
          }
        }
        /** Adds the name of an AST to the list of implicit receiver accesses. */

      }, {
        key: "addImplicitReceiverAccess",
        value: function addImplicitReceiverAccess(name) {
          if (this.implicitReceiverAccesses) {
            this.implicitReceiverAccesses.add(name);
          }
        }
      }]);

      return _AstToIrVisitor;
    }();

    function flattenStatements(arg, output) {
      if (Array.isArray(arg)) {
        arg.forEach(function (entry) {
          return flattenStatements(entry, output);
        });
      } else {
        output.push(arg);
      }
    }

    var DefaultLocalResolver =
    /*#__PURE__*/
    function () {
      function DefaultLocalResolver() {
        _classCallCheck(this, DefaultLocalResolver);
      }

      _createClass(DefaultLocalResolver, [{
        key: "notifyImplicitReceiverUse",
        value: function notifyImplicitReceiverUse() {}
      }, {
        key: "getLocal",
        value: function getLocal(name) {
          if (name === EventHandlerVars.event.name) {
            return EventHandlerVars.event;
          }

          return null;
        }
      }]);

      return DefaultLocalResolver;
    }();

    function createCurrValueExpr(bindingId) {
      return variable("currVal_".concat(bindingId)); // fix syntax highlighting: `
    }

    function createPreventDefaultVar(bindingId) {
      return variable("pd_".concat(bindingId));
    }

    function convertStmtIntoExpression(stmt) {
      if (stmt instanceof ExpressionStatement) {
        return stmt.expr;
      } else if (stmt instanceof ReturnStatement) {
        return stmt.value;
      }

      return null;
    }

    var BuiltinFunctionCall =
    /*#__PURE__*/
    function (_FunctionCall) {
      _inherits(BuiltinFunctionCall, _FunctionCall);

      function BuiltinFunctionCall(span, sourceSpan, args, converter) {
        var _this114;

        _classCallCheck(this, BuiltinFunctionCall);

        _this114 = _possibleConstructorReturn(this, _getPrototypeOf(BuiltinFunctionCall).call(this, span, sourceSpan, null, args));
        _this114.args = args;
        _this114.converter = converter;
        return _this114;
      }

      return BuiltinFunctionCall;
    }(FunctionCall);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * This file is a port of shadowCSS from webcomponents.js to TypeScript.
     *
     * Please make sure to keep to edits in sync with the source file.
     *
     * Source:
     * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
     *
     * The original file level comment is reproduced below
     */

    /*
      This is a limited shim for ShadowDOM css styling.
      https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles
    
      The intention here is to support only the styling features which can be
      relatively simply implemented. The goal is to allow users to avoid the
      most obvious pitfalls and do so without compromising performance significantly.
      For ShadowDOM styling that's not covered here, a set of best practices
      can be provided that should allow users to accomplish more complex styling.
    
      The following is a list of specific ShadowDOM styling features and a brief
      discussion of the approach used to shim.
    
      Shimmed features:
    
      * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
      element using the :host rule. To shim this feature, the :host styles are
      reformatted and prefixed with a given scope name and promoted to a
      document level stylesheet.
      For example, given a scope name of .foo, a rule like this:
    
        :host {
            background: red;
          }
        }
    
      becomes:
    
        .foo {
          background: red;
        }
    
      * encapsulation: Styles defined within ShadowDOM, apply only to
      dom inside the ShadowDOM. Polymer uses one of two techniques to implement
      this feature.
    
      By default, rules are prefixed with the host element tag name
      as a descendant selector. This ensures styling does not leak out of the 'top'
      of the element's ShadowDOM. For example,
    
      div {
          font-weight: bold;
        }
    
      becomes:
    
      x-foo div {
          font-weight: bold;
        }
    
      becomes:
    
    
      Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
      selectors are scoped by adding an attribute selector suffix to each
      simple selector that contains the host element tag name. Each element
      in the element's ShadowDOM template is also given the scope attribute.
      Thus, these rules match only elements that have the scope attribute.
      For example, given a scope name of x-foo, a rule like this:
    
        div {
          font-weight: bold;
        }
    
      becomes:
    
        div[x-foo] {
          font-weight: bold;
        }
    
      Note that elements that are dynamically added to a scope must have the scope
      selector added to them manually.
    
      * upper/lower bound encapsulation: Styles which are defined outside a
      shadowRoot should not cross the ShadowDOM boundary and should not apply
      inside a shadowRoot.
    
      This styling behavior is not emulated. Some possible ways to do this that
      were rejected due to complexity and/or performance concerns include: (1) reset
      every possible property for every possible selector for a given scope name;
      (2) re-implement css in javascript.
    
      As an alternative, users should make sure to use selectors
      specific to the scope in which they are working.
    
      * ::distributed: This behavior is not emulated. It's often not necessary
      to style the contents of a specific insertion point and instead, descendants
      of the host element can be styled selectively. Users can also create an
      extra node around an insertion point and style that node's contents
      via descendent selectors. For example, with a shadowRoot like this:
    
        <style>
          ::content(div) {
            background: red;
          }
        </style>
        <content></content>
    
      could become:
    
        <style>
          / *@polyfill .content-container div * /
          ::content(div) {
            background: red;
          }
        </style>
        <div class="content-container">
          <content></content>
        </div>
    
      Note the use of @polyfill in the comment above a ShadowDOM specific style
      declaration. This is a directive to the styling shim to use the selector
      in comments in lieu of the next selector when running under polyfill.
    */


    var ShadowCss =
    /*#__PURE__*/
    function () {
      function ShadowCss() {
        _classCallCheck(this, ShadowCss);

        this.strictStyling = true;
      }
      /*
      * Shim some cssText with the given selector. Returns cssText that can
      * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
      *
      * When strictStyling is true:
      * - selector is the attribute added to all elements inside the host,
      * - hostSelector is the attribute added to the host itself.
      */


      _createClass(ShadowCss, [{
        key: "shimCssText",
        value: function shimCssText(cssText, selector) {
          var hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          var commentsWithHash = extractCommentsWithHash(cssText);
          cssText = stripComments(cssText);
          cssText = this._insertDirectives(cssText);

          var scopedCssText = this._scopeCssText(cssText, selector, hostSelector);

          return [scopedCssText].concat(_toConsumableArray(commentsWithHash)).join('\n');
        }
      }, {
        key: "_insertDirectives",
        value: function _insertDirectives(cssText) {
          cssText = this._insertPolyfillDirectivesInCssText(cssText);
          return this._insertPolyfillRulesInCssText(cssText);
        }
        /*
         * Process styles to convert native ShadowDOM rules that will trip
         * up the css parser; we rely on decorating the stylesheet with inert rules.
         *
         * For example, we convert this rule:
         *
         * polyfill-next-selector { content: ':host menu-item'; }
         * ::content menu-item {
         *
         * to this:
         *
         * scopeName menu-item {
         *
        **/

      }, {
        key: "_insertPolyfillDirectivesInCssText",
        value: function _insertPolyfillDirectivesInCssText(cssText) {
          // Difference with webcomponents.js: does not handle comments
          return cssText.replace(_cssContentNextSelectorRe, function () {
            return (arguments.length <= 2 ? undefined : arguments[2]) + '{';
          });
        }
        /*
         * Process styles to add rules which will only apply under the polyfill
         *
         * For example, we convert this rule:
         *
         * polyfill-rule {
         *   content: ':host menu-item';
         * ...
         * }
         *
         * to this:
         *
         * scopeName menu-item {...}
         *
        **/

      }, {
        key: "_insertPolyfillRulesInCssText",
        value: function _insertPolyfillRulesInCssText(cssText) {
          // Difference with webcomponents.js: does not handle comments
          return cssText.replace(_cssContentRuleRe, function () {
            for (var _len3 = arguments.length, m = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
              m[_key4] = arguments[_key4];
            }

            var rule = m[0].replace(m[1], '').replace(m[2], '');
            return m[4] + rule;
          });
        }
        /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
         *
         *  .foo {... }
         *
         *  and converts this to
         *
         *  scopeName .foo { ... }
        */

      }, {
        key: "_scopeCssText",
        value: function _scopeCssText(cssText, scopeSelector, hostSelector) {
          var unscopedRules = this._extractUnscopedRulesFromCssText(cssText); // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively


          cssText = this._insertPolyfillHostInCssText(cssText);
          cssText = this._convertColonHost(cssText);
          cssText = this._convertColonHostContext(cssText);
          cssText = this._convertShadowDOMSelectors(cssText);

          if (scopeSelector) {
            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
          }

          cssText = cssText + '\n' + unscopedRules;
          return cssText.trim();
        }
        /*
         * Process styles to add rules which will only apply under the polyfill
         * and do not process via CSSOM. (CSSOM is destructive to rules on rare
         * occasions, e.g. -webkit-calc on Safari.)
         * For example, we convert this rule:
         *
         * @polyfill-unscoped-rule {
         *   content: 'menu-item';
         * ... }
         *
         * to this:
         *
         * menu-item {...}
         *
        **/

      }, {
        key: "_extractUnscopedRulesFromCssText",
        value: function _extractUnscopedRulesFromCssText(cssText) {
          // Difference with webcomponents.js: does not handle comments
          var r = '';
          var m;
          _cssContentUnscopedRuleRe.lastIndex = 0;

          while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
            var rule = m[0].replace(m[2], '').replace(m[1], m[4]);
            r += rule + '\n\n';
          }

          return r;
        }
        /*
         * convert a rule like :host(.foo) > .bar { }
         *
         * to
         *
         * .foo<scopeName> > .bar
        */

      }, {
        key: "_convertColonHost",
        value: function _convertColonHost(cssText) {
          return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
        }
        /*
         * convert a rule like :host-context(.foo) > .bar { }
         *
         * to
         *
         * .foo<scopeName> > .bar, .foo scopeName > .bar { }
         *
         * and
         *
         * :host-context(.foo:host) .bar { ... }
         *
         * to
         *
         * .foo<scopeName> .bar { ... }
        */

      }, {
        key: "_convertColonHostContext",
        value: function _convertColonHostContext(cssText) {
          return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
        }
      }, {
        key: "_convertColonRule",
        value: function _convertColonRule(cssText, regExp, partReplacer) {
          // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
          return cssText.replace(regExp, function () {
            for (var _len4 = arguments.length, m = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
              m[_key5] = arguments[_key5];
            }

            if (m[2]) {
              var parts = m[2].split(',');
              var r = [];

              for (var i = 0; i < parts.length; i++) {
                var p = parts[i].trim();
                if (!p) break;
                r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
              }

              return r.join(',');
            } else {
              return _polyfillHostNoCombinator + m[3];
            }
          });
        }
      }, {
        key: "_colonHostContextPartReplacer",
        value: function _colonHostContextPartReplacer(host, part, suffix) {
          if (part.indexOf(_polyfillHost) > -1) {
            return this._colonHostPartReplacer(host, part, suffix);
          } else {
            return host + part + suffix + ', ' + part + ' ' + host + suffix;
          }
        }
      }, {
        key: "_colonHostPartReplacer",
        value: function _colonHostPartReplacer(host, part, suffix) {
          return host + part.replace(_polyfillHost, '') + suffix;
        }
        /*
         * Convert combinators like ::shadow and pseudo-elements like ::content
         * by replacing with space.
        */

      }, {
        key: "_convertShadowDOMSelectors",
        value: function _convertShadowDOMSelectors(cssText) {
          return _shadowDOMSelectorsRe.reduce(function (result, pattern) {
            return result.replace(pattern, ' ');
          }, cssText);
        } // change a selector like 'div' to 'name div'

      }, {
        key: "_scopeSelectors",
        value: function _scopeSelectors(cssText, scopeSelector, hostSelector) {
          var _this115 = this;

          return processRules(cssText, function (rule) {
            var selector = rule.selector;
            var content = rule.content;

            if (rule.selector[0] != '@') {
              selector = _this115._scopeSelector(rule.selector, scopeSelector, hostSelector, _this115.strictStyling);
            } else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') || rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
              content = _this115._scopeSelectors(rule.content, scopeSelector, hostSelector);
            }

            return new CssRule(selector, content);
          });
        }
      }, {
        key: "_scopeSelector",
        value: function _scopeSelector(selector, scopeSelector, hostSelector, strict) {
          var _this116 = this;

          return selector.split(',').map(function (part) {
            return part.trim().split(_shadowDeepSelectors);
          }).map(function (deepParts) {
            var _deepParts = _toArray(deepParts),
                shallowPart = _deepParts[0],
                otherParts = _deepParts.slice(1);

            var applyScope = function applyScope(shallowPart) {
              if (_this116._selectorNeedsScoping(shallowPart, scopeSelector)) {
                return strict ? _this116._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) : _this116._applySelectorScope(shallowPart, scopeSelector, hostSelector);
              } else {
                return shallowPart;
              }
            };

            return [applyScope(shallowPart)].concat(_toConsumableArray(otherParts)).join(' ');
          }).join(', ');
        }
      }, {
        key: "_selectorNeedsScoping",
        value: function _selectorNeedsScoping(selector, scopeSelector) {
          var re = this._makeScopeMatcher(scopeSelector);

          return !re.test(selector);
        }
      }, {
        key: "_makeScopeMatcher",
        value: function _makeScopeMatcher(scopeSelector) {
          var lre = /\[/g;
          var rre = /\]/g;
          scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
          return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
        }
      }, {
        key: "_applySelectorScope",
        value: function _applySelectorScope(selector, scopeSelector, hostSelector) {
          // Difference from webcomponents.js: scopeSelector could not be an array
          return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
        } // scope via name and [is=name]

      }, {
        key: "_applySimpleSelectorScope",
        value: function _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
          // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
          _polyfillHostRe.lastIndex = 0;

          if (_polyfillHostRe.test(selector)) {
            var replaceBy = this.strictStyling ? "[".concat(hostSelector, "]") : scopeSelector;
            return selector.replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {
              return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {
                return before + replaceBy + colon + after;
              });
            }).replace(_polyfillHostRe, replaceBy + ' ');
          }

          return scopeSelector + ' ' + selector;
        } // return a selector with [name] suffix on each simple selector
        // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */

      }, {
        key: "_applyStrictSelectorScope",
        value: function _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
          var _this117 = this;

          var isRe = /\[is=([^\]]*)\]/g;
          scopeSelector = scopeSelector.replace(isRe, function (_) {
            return arguments.length <= 1 ? undefined : arguments[1];
          });
          var attrName = '[' + scopeSelector + ']';

          var _scopeSelectorPart = function _scopeSelectorPart(p) {
            var scopedP = p.trim();

            if (!scopedP) {
              return '';
            }

            if (p.indexOf(_polyfillHostNoCombinator) > -1) {
              scopedP = _this117._applySimpleSelectorScope(p, scopeSelector, hostSelector);
            } else {
              // remove :host since it should be unnecessary
              var t = p.replace(_polyfillHostRe, '');

              if (t.length > 0) {
                var matches = t.match(/([^:]*)(:*)(.*)/);

                if (matches) {
                  scopedP = matches[1] + attrName + matches[2] + matches[3];
                }
              }
            }

            return scopedP;
          };

          var safeContent = new SafeSelector(selector);
          selector = safeContent.content();
          var scopedSelector = '';
          var startIndex = 0;
          var res;
          var sep = /( |>|\+|~(?!=))\s*/g; // If a selector appears before :host it should not be shimmed as it
          // matches on ancestor elements and not on elements in the host's shadow
          // `:host-context(div)` is transformed to
          // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`
          // the `div` is not part of the component in the 2nd selectors and should not be scoped.
          // Historically `component-tag:host` was matching the component so we also want to preserve
          // this behavior to avoid breaking legacy apps (it should not match).
          // The behavior should be:
          // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)
          // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a
          //   `:host-context(tag)`)

          var hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1; // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present

          var shouldScope = !hasHost;

          while ((res = sep.exec(selector)) !== null) {
            var separator = res[1];

            var _part = selector.slice(startIndex, res.index).trim();

            shouldScope = shouldScope || _part.indexOf(_polyfillHostNoCombinator) > -1;
            var scopedPart = shouldScope ? _scopeSelectorPart(_part) : _part;
            scopedSelector += "".concat(scopedPart, " ").concat(separator, " ");
            startIndex = sep.lastIndex;
          }

          var part = selector.substring(startIndex);
          shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
          scopedSelector += shouldScope ? _scopeSelectorPart(part) : part; // replace the placeholders with their original values

          return safeContent.restore(scopedSelector);
        }
      }, {
        key: "_insertPolyfillHostInCssText",
        value: function _insertPolyfillHostInCssText(selector) {
          return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);
        }
      }]);

      return ShadowCss;
    }();

    var SafeSelector =
    /*#__PURE__*/
    function () {
      function SafeSelector(selector) {
        var _this118 = this;

        _classCallCheck(this, SafeSelector);

        this.placeholders = [];
        this.index = 0; // Replaces attribute selectors with placeholders.
        // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.

        selector = selector.replace(/(\[[^\]]*\])/g, function (_, keep) {
          var replaceBy = "__ph-".concat(_this118.index, "__");

          _this118.placeholders.push(keep);

          _this118.index++;
          return replaceBy;
        }); // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
        // WS and "+" would otherwise be interpreted as selector separators.

        this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, function (_, pseudo, exp) {
          var replaceBy = "__ph-".concat(_this118.index, "__");

          _this118.placeholders.push(exp);

          _this118.index++;
          return pseudo + replaceBy;
        });
      }

      _createClass(SafeSelector, [{
        key: "restore",
        value: function restore(content) {
          var _this119 = this;

          return content.replace(/__ph-(\d+)__/g, function (ph, index) {
            return _this119.placeholders[+index];
          });
        }
      }, {
        key: "content",
        value: function content() {
          return this._content;
        }
      }]);

      return SafeSelector;
    }();

    var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
    var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    var _polyfillHost = '-shadowcsshost'; // note: :host-context pre-processed to -shadowcsshostcontext.

    var _polyfillHostContext = '-shadowcsscontext';

    var _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';

    var _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');

    var _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');

    var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';

    var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
    var _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, // Deprecated selectors
    /\/shadow-deep\//g, /\/shadow\//g]; // The deep combinator is deprecated in the CSS spec
    // Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.
    // see https://github.com/angular/angular/pull/17677

    var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
    var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
    var _polyfillHostRe = /-shadowcsshost/gim;
    var _colonHostRe = /:host/gim;
    var _colonHostContextRe = /:host-context/gim;
    var _commentRe = /\/\*\s*[\s\S]*?\*\//g;

    function stripComments(input) {
      return input.replace(_commentRe, '');
    }

    var _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;

    function extractCommentsWithHash(input) {
      return input.match(_commentWithHashRe) || [];
    }

    var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
    var _curlyRe = /([{}])/g;
    var OPEN_CURLY = '{';
    var CLOSE_CURLY = '}';
    var BLOCK_PLACEHOLDER = '%BLOCK%';

    var CssRule = function CssRule(selector, content) {
      _classCallCheck(this, CssRule);

      this.selector = selector;
      this.content = content;
    };

    function processRules(input, ruleCallback) {
      var inputWithEscapedBlocks = escapeBlocks(input);
      var nextBlockIndex = 0;
      return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {
        var selector = arguments.length <= 2 ? undefined : arguments[2];
        var content = '';
        var suffix = arguments.length <= 4 ? undefined : arguments[4];
        var contentPrefix = '';

        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
          content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
          suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
          contentPrefix = '{';
        }

        var rule = ruleCallback(new CssRule(selector, content));
        return "".concat(arguments.length <= 1 ? undefined : arguments[1]).concat(rule.selector).concat(arguments.length <= 3 ? undefined : arguments[3]).concat(contentPrefix).concat(rule.content).concat(suffix);
      });
    }

    var StringWithEscapedBlocks = function StringWithEscapedBlocks(escapedString, blocks) {
      _classCallCheck(this, StringWithEscapedBlocks);

      this.escapedString = escapedString;
      this.blocks = blocks;
    };

    function escapeBlocks(input) {
      var inputParts = input.split(_curlyRe);
      var resultParts = [];
      var escapedBlocks = [];
      var bracketCount = 0;
      var currentBlockParts = [];

      for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {
        var part = inputParts[partIndex];

        if (part == CLOSE_CURLY) {
          bracketCount--;
        }

        if (bracketCount > 0) {
          currentBlockParts.push(part);
        } else {
          if (currentBlockParts.length > 0) {
            escapedBlocks.push(currentBlockParts.join(''));
            resultParts.push(BLOCK_PLACEHOLDER);
            currentBlockParts = [];
          }

          resultParts.push(part);
        }

        if (part == OPEN_CURLY) {
          bracketCount++;
        }
      }

      if (currentBlockParts.length > 0) {
        escapedBlocks.push(currentBlockParts.join(''));
        resultParts.push(BLOCK_PLACEHOLDER);
      }

      return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var COMPONENT_VARIABLE = '%COMP%';
    var HOST_ATTR = "_nghost-".concat(COMPONENT_VARIABLE);
    var CONTENT_ATTR = "_ngcontent-".concat(COMPONENT_VARIABLE);

    var StylesCompileDependency = function StylesCompileDependency(name, moduleUrl, setValue) {
      _classCallCheck(this, StylesCompileDependency);

      this.name = name;
      this.moduleUrl = moduleUrl;
      this.setValue = setValue;
    };

    var CompiledStylesheet = function CompiledStylesheet(outputCtx, stylesVar, dependencies, isShimmed, meta) {
      _classCallCheck(this, CompiledStylesheet);

      this.outputCtx = outputCtx;
      this.stylesVar = stylesVar;
      this.dependencies = dependencies;
      this.isShimmed = isShimmed;
      this.meta = meta;
    };

    var StyleCompiler =
    /*#__PURE__*/
    function () {
      function StyleCompiler(_urlResolver) {
        _classCallCheck(this, StyleCompiler);

        this._urlResolver = _urlResolver;
        this._shadowCss = new ShadowCss();
      }

      _createClass(StyleCompiler, [{
        key: "compileComponent",
        value: function compileComponent(outputCtx, comp) {
          var template = comp.template;
          return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({
            styles: template.styles,
            styleUrls: template.styleUrls,
            moduleUrl: identifierModuleUrl(comp.type)
          }), this.needsStyleShim(comp), true);
        }
      }, {
        key: "compileStyles",
        value: function compileStyles(outputCtx, comp, stylesheet) {
          var shim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.needsStyleShim(comp);
          return this._compileStyles(outputCtx, comp, stylesheet, shim, false);
        }
      }, {
        key: "needsStyleShim",
        value: function needsStyleShim(comp) {
          return comp.template.encapsulation === ViewEncapsulation.Emulated;
        }
      }, {
        key: "_compileStyles",
        value: function _compileStyles(outputCtx, comp, stylesheet, shim, isComponentStylesheet) {
          var _this120 = this;

          var styleExpressions = stylesheet.styles.map(function (plainStyle) {
            return literal(_this120._shimIfNeeded(plainStyle, shim));
          });
          var dependencies = [];
          stylesheet.styleUrls.forEach(function (styleUrl) {
            var exprIndex = styleExpressions.length; // Note: This placeholder will be filled later.

            styleExpressions.push(null);
            dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, function (value) {
              return styleExpressions[exprIndex] = outputCtx.importExpr(value);
            }));
          }); // styles variable contains plain strings and arrays of other styles arrays (recursive),
          // so we set its type to dynamic.

          var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);
          var stmt = variable(stylesVar).set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const]))).toDeclStmt(null, isComponentStylesheet ? [StmtModifier.Final] : [StmtModifier.Final, StmtModifier.Exported]);
          outputCtx.statements.push(stmt);
          return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);
        }
      }, {
        key: "_shimIfNeeded",
        value: function _shimIfNeeded(style, shim) {
          return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
        }
      }]);

      return StyleCompiler;
    }();

    function getStylesVarName(component) {
      var result = "styles";

      if (component) {
        result += "_".concat(identifierName(component.type));
      }

      return result;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * A path is an ordered set of elements. Typically a path is to  a
     * particular offset in a source file. The head of the list is the top
     * most node. The tail is the node that contains the offset directly.
     *
     * For example, the expression `a + b + c` might have an ast that looks
     * like:
     *     +
     *    / \
     *   a   +
     *      / \
     *     b   c
     *
     * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,
     * 'c' at 9-10]` and the path the node at offset 1 would be
     * `['+' at 1-10, 'a' at 1-2]`.
     */


    var AstPath =
    /*#__PURE__*/
    function () {
      function AstPath(path) {
        var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

        _classCallCheck(this, AstPath);

        this.path = path;
        this.position = position;
      }

      _createClass(AstPath, [{
        key: "parentOf",
        value: function parentOf(node) {
          return node && this.path[this.path.indexOf(node) - 1];
        }
      }, {
        key: "childOf",
        value: function childOf(node) {
          return this.path[this.path.indexOf(node) + 1];
        }
      }, {
        key: "first",
        value: function first(ctor) {
          for (var i = this.path.length - 1; i >= 0; i--) {
            var item = this.path[i];
            if (item instanceof ctor) return item;
          }
        }
      }, {
        key: "push",
        value: function push(node) {
          this.path.push(node);
        }
      }, {
        key: "pop",
        value: function pop() {
          return this.path.pop();
        }
      }, {
        key: "empty",
        get: function get() {
          return !this.path || !this.path.length;
        }
      }, {
        key: "head",
        get: function get() {
          return this.path[0];
        }
      }, {
        key: "tail",
        get: function get() {
          return this.path[this.path.length - 1];
        }
      }]);

      return AstPath;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var NodeWithI18n = function NodeWithI18n(sourceSpan, i18n) {
      _classCallCheck(this, NodeWithI18n);

      this.sourceSpan = sourceSpan;
      this.i18n = i18n;
    };

    var Text$3 =
    /*#__PURE__*/
    function (_NodeWithI18n) {
      _inherits(Text$3, _NodeWithI18n);

      function Text$3(value, sourceSpan, i18n) {
        var _this121;

        _classCallCheck(this, Text$3);

        _this121 = _possibleConstructorReturn(this, _getPrototypeOf(Text$3).call(this, sourceSpan, i18n));
        _this121.value = value;
        return _this121;
      }

      _createClass(Text$3, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitText(this, context);
        }
      }]);

      return Text$3;
    }(NodeWithI18n);

    var Expansion =
    /*#__PURE__*/
    function (_NodeWithI18n2) {
      _inherits(Expansion, _NodeWithI18n2);

      function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {
        var _this122;

        _classCallCheck(this, Expansion);

        _this122 = _possibleConstructorReturn(this, _getPrototypeOf(Expansion).call(this, sourceSpan, i18n));
        _this122.switchValue = switchValue;
        _this122.type = type;
        _this122.cases = cases;
        _this122.switchValueSourceSpan = switchValueSourceSpan;
        return _this122;
      }

      _createClass(Expansion, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitExpansion(this, context);
        }
      }]);

      return Expansion;
    }(NodeWithI18n);

    var ExpansionCase =
    /*#__PURE__*/
    function () {
      function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
        _classCallCheck(this, ExpansionCase);

        this.value = value;
        this.expression = expression;
        this.sourceSpan = sourceSpan;
        this.valueSourceSpan = valueSourceSpan;
        this.expSourceSpan = expSourceSpan;
      }

      _createClass(ExpansionCase, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitExpansionCase(this, context);
        }
      }]);

      return ExpansionCase;
    }();

    var Attribute =
    /*#__PURE__*/
    function (_NodeWithI18n3) {
      _inherits(Attribute, _NodeWithI18n3);

      function Attribute(name, value, sourceSpan, valueSpan, i18n) {
        var _this123;

        _classCallCheck(this, Attribute);

        _this123 = _possibleConstructorReturn(this, _getPrototypeOf(Attribute).call(this, sourceSpan, i18n));
        _this123.name = name;
        _this123.value = value;
        _this123.valueSpan = valueSpan;
        return _this123;
      }

      _createClass(Attribute, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitAttribute(this, context);
        }
      }]);

      return Attribute;
    }(NodeWithI18n);

    var Element$1 =
    /*#__PURE__*/
    function (_NodeWithI18n4) {
      _inherits(Element$1, _NodeWithI18n4);

      function Element$1(name, attrs, children, sourceSpan) {
        var _this124;

        var startSourceSpan = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var endSourceSpan = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var i18n = arguments.length > 6 ? arguments[6] : undefined;

        _classCallCheck(this, Element$1);

        _this124 = _possibleConstructorReturn(this, _getPrototypeOf(Element$1).call(this, sourceSpan, i18n));
        _this124.name = name;
        _this124.attrs = attrs;
        _this124.children = children;
        _this124.startSourceSpan = startSourceSpan;
        _this124.endSourceSpan = endSourceSpan;
        return _this124;
      }

      _createClass(Element$1, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitElement(this, context);
        }
      }]);

      return Element$1;
    }(NodeWithI18n);

    var Comment =
    /*#__PURE__*/
    function () {
      function Comment(value, sourceSpan) {
        _classCallCheck(this, Comment);

        this.value = value;
        this.sourceSpan = sourceSpan;
      }

      _createClass(Comment, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitComment(this, context);
        }
      }]);

      return Comment;
    }();

    function visitAll$1(visitor, nodes) {
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var result = [];
      var visit = visitor.visit ? function (ast) {
        return visitor.visit(ast, context) || ast.visit(visitor, context);
      } : function (ast) {
        return ast.visit(visitor, context);
      };
      nodes.forEach(function (ast) {
        var astResult = visit(ast);

        if (astResult) {
          result.push(astResult);
        }
      });
      return result;
    }

    var RecursiveVisitor$1 =
    /*#__PURE__*/
    function () {
      function RecursiveVisitor$1() {
        _classCallCheck(this, RecursiveVisitor$1);
      }

      _createClass(RecursiveVisitor$1, [{
        key: "visitElement",
        value: function visitElement(ast, context) {
          this.visitChildren(context, function (visit) {
            visit(ast.attrs);
            visit(ast.children);
          });
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(ast, context) {}
      }, {
        key: "visitText",
        value: function visitText(ast, context) {}
      }, {
        key: "visitComment",
        value: function visitComment(ast, context) {}
      }, {
        key: "visitExpansion",
        value: function visitExpansion(ast, context) {
          return this.visitChildren(context, function (visit) {
            visit(ast.cases);
          });
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(ast, context) {}
      }, {
        key: "visitChildren",
        value: function visitChildren(context, cb) {
          var results = [];
          var t = this;

          function visit(children) {
            if (children) results.push(visitAll$1(t, children, context));
          }

          cb(visit);
          return Array.prototype.concat.apply([], results);
        }
      }]);

      return RecursiveVisitor$1;
    }();

    function spanOf(ast) {
      var start = ast.sourceSpan.start.offset;
      var end = ast.sourceSpan.end.offset;

      if (ast instanceof Element$1) {
        if (ast.endSourceSpan) {
          end = ast.endSourceSpan.end.offset;
        } else if (ast.children && ast.children.length) {
          end = spanOf(ast.children[ast.children.length - 1]).end;
        }
      }

      return {
        start: start,
        end: end
      };
    }

    function findNode(nodes, position) {
      var path = [];
      var visitor = new (
      /*#__PURE__*/
      function (_RecursiveVisitor$) {
        _inherits(_class, _RecursiveVisitor$);

        function _class() {
          _classCallCheck(this, _class);

          return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));
        }

        _createClass(_class, [{
          key: "visit",
          value: function visit(ast, context) {
            var span = spanOf(ast);

            if (span.start <= position && position < span.end) {
              path.push(ast);
            } else {
              // Returning a value here will result in the children being skipped.
              return true;
            }
          }
        }]);

        return _class;
      }(RecursiveVisitor$1))();
      visitAll$1(visitor, nodes);
      return new AstPath(path, position);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var TokenType;

    (function (TokenType) {
      TokenType[TokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
      TokenType[TokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
      TokenType[TokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
      TokenType[TokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
      TokenType[TokenType["TEXT"] = 4] = "TEXT";
      TokenType[TokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
      TokenType[TokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
      TokenType[TokenType["COMMENT_START"] = 7] = "COMMENT_START";
      TokenType[TokenType["COMMENT_END"] = 8] = "COMMENT_END";
      TokenType[TokenType["CDATA_START"] = 9] = "CDATA_START";
      TokenType[TokenType["CDATA_END"] = 10] = "CDATA_END";
      TokenType[TokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
      TokenType[TokenType["ATTR_QUOTE"] = 12] = "ATTR_QUOTE";
      TokenType[TokenType["ATTR_VALUE"] = 13] = "ATTR_VALUE";
      TokenType[TokenType["DOC_TYPE"] = 14] = "DOC_TYPE";
      TokenType[TokenType["EXPANSION_FORM_START"] = 15] = "EXPANSION_FORM_START";
      TokenType[TokenType["EXPANSION_CASE_VALUE"] = 16] = "EXPANSION_CASE_VALUE";
      TokenType[TokenType["EXPANSION_CASE_EXP_START"] = 17] = "EXPANSION_CASE_EXP_START";
      TokenType[TokenType["EXPANSION_CASE_EXP_END"] = 18] = "EXPANSION_CASE_EXP_END";
      TokenType[TokenType["EXPANSION_FORM_END"] = 19] = "EXPANSION_FORM_END";
      TokenType[TokenType["EOF"] = 20] = "EOF";
    })(TokenType || (TokenType = {}));

    var Token = function Token(type, parts, sourceSpan) {
      _classCallCheck(this, Token);

      this.type = type;
      this.parts = parts;
      this.sourceSpan = sourceSpan;
    };

    var TokenError =
    /*#__PURE__*/
    function (_ParseError) {
      _inherits(TokenError, _ParseError);

      function TokenError(errorMsg, tokenType, span) {
        var _this125;

        _classCallCheck(this, TokenError);

        _this125 = _possibleConstructorReturn(this, _getPrototypeOf(TokenError).call(this, span, errorMsg));
        _this125.tokenType = tokenType;
        return _this125;
      }

      return TokenError;
    }(ParseError);

    var TokenizeResult = function TokenizeResult(tokens, errors) {
      _classCallCheck(this, TokenizeResult);

      this.tokens = tokens;
      this.errors = errors;
    };

    function tokenize(source, url, getTagDefinition) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options).tokenize();
    }

    var _CR_OR_CRLF_REGEXP = /\r\n?/g;

    function _unexpectedCharacterErrorMsg(charCode) {
      var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
      return "Unexpected character \"".concat(char, "\"");
    }

    function _unknownEntityErrorMsg(entitySrc) {
      return "Unknown entity \"".concat(entitySrc, "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax");
    }

    var _ControlFlowError = function _ControlFlowError(error) {
      _classCallCheck(this, _ControlFlowError);

      this.error = error;
    }; // See http://www.w3.org/TR/html51/syntax.html#writing


    var _Tokenizer =
    /*#__PURE__*/
    function () {
      /**
       * @param _file The html source file being tokenized.
       * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.
       * @param options Configuration of the tokenization.
       */
      function _Tokenizer(_file, _getTagDefinition, options) {
        _classCallCheck(this, _Tokenizer);

        this._getTagDefinition = _getTagDefinition;
        this._currentTokenStart = null;
        this._currentTokenType = null;
        this._expansionCaseStack = [];
        this._inInterpolation = false;
        this.tokens = [];
        this.errors = [];
        this._tokenizeIcu = options.tokenizeExpansionForms || false;
        this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
        this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map(function (c) {
          return c.codePointAt(0) || 0;
        });
        var range = options.range || {
          endPos: _file.content.length,
          startPos: 0,
          startLine: 0,
          startCol: 0
        };
        this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);
        this._preserveLineEndings = options.preserveLineEndings || false;

        try {
          this._cursor.init();
        } catch (e) {
          this.handleError(e);
        }
      }

      _createClass(_Tokenizer, [{
        key: "_processCarriageReturns",
        value: function _processCarriageReturns(content) {
          if (this._preserveLineEndings) {
            return content;
          } // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream
          // In order to keep the original position in the source, we can not
          // pre-process it.
          // Instead CRs are processed right before instantiating the tokens.


          return content.replace(_CR_OR_CRLF_REGEXP, '\n');
        }
      }, {
        key: "tokenize",
        value: function tokenize() {
          while (this._cursor.peek() !== $EOF) {
            var start = this._cursor.clone();

            try {
              if (this._attemptCharCode($LT)) {
                if (this._attemptCharCode($BANG)) {
                  if (this._attemptCharCode($LBRACKET)) {
                    this._consumeCdata(start);
                  } else if (this._attemptCharCode($MINUS)) {
                    this._consumeComment(start);
                  } else {
                    this._consumeDocType(start);
                  }
                } else if (this._attemptCharCode($SLASH)) {
                  this._consumeTagClose(start);
                } else {
                  this._consumeTagOpen(start);
                }
              } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
                this._consumeText();
              }
            } catch (e) {
              this.handleError(e);
            }
          }

          this._beginToken(TokenType.EOF);

          this._endToken([]);

          return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);
        }
        /**
         * @returns whether an ICU token has been created
         * @internal
         */

      }, {
        key: "_tokenizeExpansionForm",
        value: function _tokenizeExpansionForm() {
          if (this.isExpansionFormStart()) {
            this._consumeExpansionFormStart();

            return true;
          }

          if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {
            this._consumeExpansionCaseStart();

            return true;
          }

          if (this._cursor.peek() === $RBRACE) {
            if (this._isInExpansionCase()) {
              this._consumeExpansionCaseEnd();

              return true;
            }

            if (this._isInExpansionForm()) {
              this._consumeExpansionFormEnd();

              return true;
            }
          }

          return false;
        }
      }, {
        key: "_beginToken",
        value: function _beginToken(type) {
          var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._cursor.clone();
          this._currentTokenStart = start;
          this._currentTokenType = type;
        }
      }, {
        key: "_endToken",
        value: function _endToken(parts, end) {
          if (this._currentTokenStart === null) {
            throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));
          }

          if (this._currentTokenType === null) {
            throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));
          }

          var token = new Token(this._currentTokenType, parts, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
          this.tokens.push(token);
          this._currentTokenStart = null;
          this._currentTokenType = null;
          return token;
        }
      }, {
        key: "_createError",
        value: function _createError(msg, span) {
          if (this._isInExpansionForm()) {
            msg += " (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)";
          }

          var error = new TokenError(msg, this._currentTokenType, span);
          this._currentTokenStart = null;
          this._currentTokenType = null;
          return new _ControlFlowError(error);
        }
      }, {
        key: "handleError",
        value: function handleError(e) {
          if (e instanceof CursorError) {
            e = this._createError(e.msg, this._cursor.getSpan(e.cursor));
          }

          if (e instanceof _ControlFlowError) {
            this.errors.push(e.error);
          } else {
            throw e;
          }
        }
      }, {
        key: "_attemptCharCode",
        value: function _attemptCharCode(charCode) {
          if (this._cursor.peek() === charCode) {
            this._cursor.advance();

            return true;
          }

          return false;
        }
      }, {
        key: "_attemptCharCodeCaseInsensitive",
        value: function _attemptCharCodeCaseInsensitive(charCode) {
          if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {
            this._cursor.advance();

            return true;
          }

          return false;
        }
      }, {
        key: "_requireCharCode",
        value: function _requireCharCode(charCode) {
          var location = this._cursor.clone();

          if (!this._attemptCharCode(charCode)) {
            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
          }
        }
      }, {
        key: "_attemptStr",
        value: function _attemptStr(chars) {
          var len = chars.length;

          if (this._cursor.charsLeft() < len) {
            return false;
          }

          var initialPosition = this._cursor.clone();

          for (var i = 0; i < len; i++) {
            if (!this._attemptCharCode(chars.charCodeAt(i))) {
              // If attempting to parse the string fails, we want to reset the parser
              // to where it was before the attempt
              this._cursor = initialPosition;
              return false;
            }
          }

          return true;
        }
      }, {
        key: "_attemptStrCaseInsensitive",
        value: function _attemptStrCaseInsensitive(chars) {
          for (var i = 0; i < chars.length; i++) {
            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
              return false;
            }
          }

          return true;
        }
      }, {
        key: "_requireStr",
        value: function _requireStr(chars) {
          var location = this._cursor.clone();

          if (!this._attemptStr(chars)) {
            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
          }
        }
      }, {
        key: "_attemptCharCodeUntilFn",
        value: function _attemptCharCodeUntilFn(predicate) {
          while (!predicate(this._cursor.peek())) {
            this._cursor.advance();
          }
        }
      }, {
        key: "_requireCharCodeUntilFn",
        value: function _requireCharCodeUntilFn(predicate, len) {
          var start = this._cursor.clone();

          this._attemptCharCodeUntilFn(predicate);

          if (this._cursor.diff(start) < len) {
            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
          }
        }
      }, {
        key: "_attemptUntilChar",
        value: function _attemptUntilChar(char) {
          while (this._cursor.peek() !== char) {
            this._cursor.advance();
          }
        }
      }, {
        key: "_readChar",
        value: function _readChar(decodeEntities) {
          if (decodeEntities && this._cursor.peek() === $AMPERSAND) {
            return this._decodeEntity();
          } else {
            // Don't rely upon reading directly from `_input` as the actual char value
            // may have been generated from an escape sequence.
            var char = String.fromCodePoint(this._cursor.peek());

            this._cursor.advance();

            return char;
          }
        }
      }, {
        key: "_decodeEntity",
        value: function _decodeEntity() {
          var start = this._cursor.clone();

          this._cursor.advance();

          if (this._attemptCharCode($HASH)) {
            var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);

            var codeStart = this._cursor.clone();

            this._attemptCharCodeUntilFn(isDigitEntityEnd);

            if (this._cursor.peek() != $SEMICOLON) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan());
            }

            var strNum = this._cursor.getChars(codeStart);

            this._cursor.advance();

            try {
              var charCode = parseInt(strNum, isHex ? 16 : 10);
              return String.fromCharCode(charCode);
            } catch (_a) {
              throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());
            }
          } else {
            var nameStart = this._cursor.clone();

            this._attemptCharCodeUntilFn(isNamedEntityEnd);

            if (this._cursor.peek() != $SEMICOLON) {
              this._cursor = nameStart;
              return '&';
            }

            var name = this._cursor.getChars(nameStart);

            this._cursor.advance();

            var char = NAMED_ENTITIES[name];

            if (!char) {
              throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));
            }

            return char;
          }
        }
      }, {
        key: "_consumeRawText",
        value: function _consumeRawText(decodeEntities, endMarkerPredicate) {
          this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);

          var parts = [];

          while (true) {
            var tagCloseStart = this._cursor.clone();

            var foundEndMarker = endMarkerPredicate();
            this._cursor = tagCloseStart;

            if (foundEndMarker) {
              break;
            }

            parts.push(this._readChar(decodeEntities));
          }

          return this._endToken([this._processCarriageReturns(parts.join(''))]);
        }
      }, {
        key: "_consumeComment",
        value: function _consumeComment(start) {
          var _this126 = this;

          this._beginToken(TokenType.COMMENT_START, start);

          this._requireCharCode($MINUS);

          this._endToken([]);

          this._consumeRawText(false, function () {
            return _this126._attemptStr('-->');
          });

          this._beginToken(TokenType.COMMENT_END);

          this._requireStr('-->');

          this._endToken([]);
        }
      }, {
        key: "_consumeCdata",
        value: function _consumeCdata(start) {
          var _this127 = this;

          this._beginToken(TokenType.CDATA_START, start);

          this._requireStr('CDATA[');

          this._endToken([]);

          this._consumeRawText(false, function () {
            return _this127._attemptStr(']]>');
          });

          this._beginToken(TokenType.CDATA_END);

          this._requireStr(']]>');

          this._endToken([]);
        }
      }, {
        key: "_consumeDocType",
        value: function _consumeDocType(start) {
          this._beginToken(TokenType.DOC_TYPE, start);

          var contentStart = this._cursor.clone();

          this._attemptUntilChar($GT);

          var content = this._cursor.getChars(contentStart);

          this._cursor.advance();

          this._endToken([content]);
        }
      }, {
        key: "_consumePrefixAndName",
        value: function _consumePrefixAndName() {
          var nameOrPrefixStart = this._cursor.clone();

          var prefix = '';

          while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {
            this._cursor.advance();
          }

          var nameStart;

          if (this._cursor.peek() === $COLON) {
            prefix = this._cursor.getChars(nameOrPrefixStart);

            this._cursor.advance();

            nameStart = this._cursor.clone();
          } else {
            nameStart = nameOrPrefixStart;
          }

          this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);

          var name = this._cursor.getChars(nameStart);

          return [prefix, name];
        }
      }, {
        key: "_consumeTagOpen",
        value: function _consumeTagOpen(start) {
          var tagName;
          var prefix;
          var openTagToken;
          var tokensBeforeTagOpen = this.tokens.length;

          var innerStart = this._cursor.clone();

          try {
            if (!isAsciiLetter(this._cursor.peek())) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
            }

            openTagToken = this._consumeTagOpenStart(start);
            prefix = openTagToken.parts[0];
            tagName = openTagToken.parts[1];

            this._attemptCharCodeUntilFn(isNotWhitespace);

            while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT) {
              this._consumeAttributeName();

              this._attemptCharCodeUntilFn(isNotWhitespace);

              if (this._attemptCharCode($EQ)) {
                this._attemptCharCodeUntilFn(isNotWhitespace);

                this._consumeAttributeValue();
              }

              this._attemptCharCodeUntilFn(isNotWhitespace);
            }

            this._consumeTagOpenEnd();
          } catch (e) {
            if (e instanceof _ControlFlowError) {
              // When the start tag is invalid (including invalid "attributes"), assume we want a "<"
              this._cursor = innerStart;

              if (openTagToken) {
                this.tokens.length = tokensBeforeTagOpen;
              } // Back to back text tokens are merged at the end


              this._beginToken(TokenType.TEXT, start);

              this._endToken(['<']);

              return;
            }

            throw e;
          }

          var contentTokenType = this._getTagDefinition(tagName).contentType;

          if (contentTokenType === TagContentType.RAW_TEXT) {
            this._consumeRawTextWithTagClose(prefix, tagName, false);
          } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
            this._consumeRawTextWithTagClose(prefix, tagName, true);
          }
        }
      }, {
        key: "_consumeRawTextWithTagClose",
        value: function _consumeRawTextWithTagClose(prefix, tagName, decodeEntities) {
          var _this128 = this;

          var textToken = this._consumeRawText(decodeEntities, function () {
            if (!_this128._attemptCharCode($LT)) return false;
            if (!_this128._attemptCharCode($SLASH)) return false;

            _this128._attemptCharCodeUntilFn(isNotWhitespace);

            if (!_this128._attemptStrCaseInsensitive(tagName)) return false;

            _this128._attemptCharCodeUntilFn(isNotWhitespace);

            return _this128._attemptCharCode($GT);
          });

          this._beginToken(TokenType.TAG_CLOSE);

          this._requireCharCodeUntilFn(function (code) {
            return code === $GT;
          }, 3);

          this._cursor.advance(); // Consume the `>`


          this._endToken([prefix, tagName]);
        }
      }, {
        key: "_consumeTagOpenStart",
        value: function _consumeTagOpenStart(start) {
          this._beginToken(TokenType.TAG_OPEN_START, start);

          var parts = this._consumePrefixAndName();

          return this._endToken(parts);
        }
      }, {
        key: "_consumeAttributeName",
        value: function _consumeAttributeName() {
          var attrNameStart = this._cursor.peek();

          if (attrNameStart === $SQ || attrNameStart === $DQ) {
            throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());
          }

          this._beginToken(TokenType.ATTR_NAME);

          var prefixAndName = this._consumePrefixAndName();

          this._endToken(prefixAndName);
        }
      }, {
        key: "_consumeAttributeValue",
        value: function _consumeAttributeValue() {
          var value;

          if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {
            this._beginToken(TokenType.ATTR_QUOTE);

            var quoteChar = this._cursor.peek();

            this._cursor.advance();

            this._endToken([String.fromCodePoint(quoteChar)]);

            this._beginToken(TokenType.ATTR_VALUE);

            var parts = [];

            while (this._cursor.peek() !== quoteChar) {
              parts.push(this._readChar(true));
            }

            value = parts.join('');

            this._endToken([this._processCarriageReturns(value)]);

            this._beginToken(TokenType.ATTR_QUOTE);

            this._cursor.advance();

            this._endToken([String.fromCodePoint(quoteChar)]);
          } else {
            this._beginToken(TokenType.ATTR_VALUE);

            var valueStart = this._cursor.clone();

            this._requireCharCodeUntilFn(isNameEnd, 1);

            value = this._cursor.getChars(valueStart);

            this._endToken([this._processCarriageReturns(value)]);
          }
        }
      }, {
        key: "_consumeTagOpenEnd",
        value: function _consumeTagOpenEnd() {
          var tokenType = this._attemptCharCode($SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;

          this._beginToken(tokenType);

          this._requireCharCode($GT);

          this._endToken([]);
        }
      }, {
        key: "_consumeTagClose",
        value: function _consumeTagClose(start) {
          this._beginToken(TokenType.TAG_CLOSE, start);

          this._attemptCharCodeUntilFn(isNotWhitespace);

          var prefixAndName = this._consumePrefixAndName();

          this._attemptCharCodeUntilFn(isNotWhitespace);

          this._requireCharCode($GT);

          this._endToken(prefixAndName);
        }
      }, {
        key: "_consumeExpansionFormStart",
        value: function _consumeExpansionFormStart() {
          this._beginToken(TokenType.EXPANSION_FORM_START);

          this._requireCharCode($LBRACE);

          this._endToken([]);

          this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);

          this._beginToken(TokenType.RAW_TEXT);

          var condition = this._readUntil($COMMA);

          this._endToken([condition]);

          this._requireCharCode($COMMA);

          this._attemptCharCodeUntilFn(isNotWhitespace);

          this._beginToken(TokenType.RAW_TEXT);

          var type = this._readUntil($COMMA);

          this._endToken([type]);

          this._requireCharCode($COMMA);

          this._attemptCharCodeUntilFn(isNotWhitespace);
        }
      }, {
        key: "_consumeExpansionCaseStart",
        value: function _consumeExpansionCaseStart() {
          this._beginToken(TokenType.EXPANSION_CASE_VALUE);

          var value = this._readUntil($LBRACE).trim();

          this._endToken([value]);

          this._attemptCharCodeUntilFn(isNotWhitespace);

          this._beginToken(TokenType.EXPANSION_CASE_EXP_START);

          this._requireCharCode($LBRACE);

          this._endToken([]);

          this._attemptCharCodeUntilFn(isNotWhitespace);

          this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);
        }
      }, {
        key: "_consumeExpansionCaseEnd",
        value: function _consumeExpansionCaseEnd() {
          this._beginToken(TokenType.EXPANSION_CASE_EXP_END);

          this._requireCharCode($RBRACE);

          this._endToken([]);

          this._attemptCharCodeUntilFn(isNotWhitespace);

          this._expansionCaseStack.pop();
        }
      }, {
        key: "_consumeExpansionFormEnd",
        value: function _consumeExpansionFormEnd() {
          this._beginToken(TokenType.EXPANSION_FORM_END);

          this._requireCharCode($RBRACE);

          this._endToken([]);

          this._expansionCaseStack.pop();
        }
      }, {
        key: "_consumeText",
        value: function _consumeText() {
          var start = this._cursor.clone();

          this._beginToken(TokenType.TEXT, start);

          var parts = [];

          do {
            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
              parts.push(this._interpolationConfig.start);
              this._inInterpolation = true;
            } else if (this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end)) {
              parts.push(this._interpolationConfig.end);
              this._inInterpolation = false;
            } else {
              parts.push(this._readChar(true));
            }
          } while (!this._isTextEnd());

          this._endToken([this._processCarriageReturns(parts.join(''))]);
        }
      }, {
        key: "_isTextEnd",
        value: function _isTextEnd() {
          if (this._cursor.peek() === $LT || this._cursor.peek() === $EOF) {
            return true;
          }

          if (this._tokenizeIcu && !this._inInterpolation) {
            if (this.isExpansionFormStart()) {
              // start of an expansion form
              return true;
            }

            if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {
              // end of and expansion case
              return true;
            }
          }

          return false;
        }
      }, {
        key: "_readUntil",
        value: function _readUntil(char) {
          var start = this._cursor.clone();

          this._attemptUntilChar(char);

          return this._cursor.getChars(start);
        }
      }, {
        key: "_isInExpansionCase",
        value: function _isInExpansionCase() {
          return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_CASE_EXP_START;
        }
      }, {
        key: "_isInExpansionForm",
        value: function _isInExpansionForm() {
          return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_FORM_START;
        }
      }, {
        key: "isExpansionFormStart",
        value: function isExpansionFormStart() {
          if (this._cursor.peek() !== $LBRACE) {
            return false;
          }

          if (this._interpolationConfig) {
            var start = this._cursor.clone();

            var isInterpolation = this._attemptStr(this._interpolationConfig.start);

            this._cursor = start;
            return !isInterpolation;
          }

          return true;
        }
      }]);

      return _Tokenizer;
    }();

    function isNotWhitespace(code) {
      return !isWhitespace(code) || code === $EOF;
    }

    function isNameEnd(code) {
      return isWhitespace(code) || code === $GT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ;
    }

    function isPrefixEnd(code) {
      return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);
    }

    function isDigitEntityEnd(code) {
      return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
    }

    function isNamedEntityEnd(code) {
      return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
    }

    function isExpansionCaseStart(peek) {
      return peek === $EQ || isAsciiLetter(peek) || isDigit(peek);
    }

    function compareCharCodeCaseInsensitive(code1, code2) {
      return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
    }

    function toUpperCaseCharCode(code) {
      return code >= $a && code <= $z ? code - $a + $A : code;
    }

    function mergeTextTokens(srcTokens) {
      var dstTokens = [];
      var lastDstToken = undefined;

      for (var i = 0; i < srcTokens.length; i++) {
        var token = srcTokens[i];

        if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {
          lastDstToken.parts[0] += token.parts[0];
          lastDstToken.sourceSpan.end = token.sourceSpan.end;
        } else {
          lastDstToken = token;
          dstTokens.push(lastDstToken);
        }
      }

      return dstTokens;
    }

    var PlainCharacterCursor =
    /*#__PURE__*/
    function () {
      function PlainCharacterCursor(fileOrCursor, range) {
        _classCallCheck(this, PlainCharacterCursor);

        if (fileOrCursor instanceof PlainCharacterCursor) {
          this.file = fileOrCursor.file;
          this.input = fileOrCursor.input;
          this.end = fileOrCursor.end;
          var state = fileOrCursor.state; // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.
          // In ES5 bundles the object spread operator is translated into the `__assign` helper, which
          // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is
          // called in tight loops, this difference matters.

          this.state = {
            peek: state.peek,
            offset: state.offset,
            line: state.line,
            column: state.column
          };
        } else {
          if (!range) {
            throw new Error('Programming error: the range argument must be provided with a file argument.');
          }

          this.file = fileOrCursor;
          this.input = fileOrCursor.content;
          this.end = range.endPos;
          this.state = {
            peek: -1,
            offset: range.startPos,
            line: range.startLine,
            column: range.startCol
          };
        }
      }

      _createClass(PlainCharacterCursor, [{
        key: "clone",
        value: function clone() {
          return new PlainCharacterCursor(this);
        }
      }, {
        key: "peek",
        value: function peek() {
          return this.state.peek;
        }
      }, {
        key: "charsLeft",
        value: function charsLeft() {
          return this.end - this.state.offset;
        }
      }, {
        key: "diff",
        value: function diff(other) {
          return this.state.offset - other.state.offset;
        }
      }, {
        key: "advance",
        value: function advance() {
          this.advanceState(this.state);
        }
      }, {
        key: "init",
        value: function init() {
          this.updatePeek(this.state);
        }
      }, {
        key: "getSpan",
        value: function getSpan(start, leadingTriviaCodePoints) {
          start = start || this;
          var cloned = false;

          if (leadingTriviaCodePoints) {
            while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
              if (!cloned) {
                start = start.clone();
                cloned = true;
              }

              start.advance();
            }
          }

          return new ParseSourceSpan(new ParseLocation(start.file, start.state.offset, start.state.line, start.state.column), new ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
        }
      }, {
        key: "getChars",
        value: function getChars(start) {
          return this.input.substring(start.state.offset, this.state.offset);
        }
      }, {
        key: "charAt",
        value: function charAt(pos) {
          return this.input.charCodeAt(pos);
        }
      }, {
        key: "advanceState",
        value: function advanceState(state) {
          if (state.offset >= this.end) {
            this.state = state;
            throw new CursorError('Unexpected character "EOF"', this);
          }

          var currentChar = this.charAt(state.offset);

          if (currentChar === $LF) {
            state.line++;
            state.column = 0;
          } else if (!isNewLine(currentChar)) {
            state.column++;
          }

          state.offset++;
          this.updatePeek(state);
        }
      }, {
        key: "updatePeek",
        value: function updatePeek(state) {
          state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);
        }
      }]);

      return PlainCharacterCursor;
    }();

    var EscapedCharacterCursor =
    /*#__PURE__*/
    function (_PlainCharacterCursor) {
      _inherits(EscapedCharacterCursor, _PlainCharacterCursor);

      function EscapedCharacterCursor(fileOrCursor, range) {
        var _this129;

        _classCallCheck(this, EscapedCharacterCursor);

        if (fileOrCursor instanceof EscapedCharacterCursor) {
          _this129 = _possibleConstructorReturn(this, _getPrototypeOf(EscapedCharacterCursor).call(this, fileOrCursor));
          _this129.internalState = Object.assign({}, fileOrCursor.internalState);
        } else {
          _this129 = _possibleConstructorReturn(this, _getPrototypeOf(EscapedCharacterCursor).call(this, fileOrCursor, range));
          _this129.internalState = _this129.state;
        }

        return _possibleConstructorReturn(_this129);
      }

      _createClass(EscapedCharacterCursor, [{
        key: "advance",
        value: function advance() {
          this.state = this.internalState;

          _get(_getPrototypeOf(EscapedCharacterCursor.prototype), "advance", this).call(this);

          this.processEscapeSequence();
        }
      }, {
        key: "init",
        value: function init() {
          _get(_getPrototypeOf(EscapedCharacterCursor.prototype), "init", this).call(this);

          this.processEscapeSequence();
        }
      }, {
        key: "clone",
        value: function clone() {
          return new EscapedCharacterCursor(this);
        }
      }, {
        key: "getChars",
        value: function getChars(start) {
          var cursor = start.clone();
          var chars = '';

          while (cursor.internalState.offset < this.internalState.offset) {
            chars += String.fromCodePoint(cursor.peek());
            cursor.advance();
          }

          return chars;
        }
        /**
         * Process the escape sequence that starts at the current position in the text.
         *
         * This method is called to ensure that `peek` has the unescaped value of escape sequences.
         */

      }, {
        key: "processEscapeSequence",
        value: function processEscapeSequence() {
          var _this130 = this;

          var peek = function peek() {
            return _this130.internalState.peek;
          };

          if (peek() === $BACKSLASH) {
            // We have hit an escape sequence so we need the internal state to become independent
            // of the external state.
            this.internalState = Object.assign({}, this.state); // Move past the backslash

            this.advanceState(this.internalState); // First check for standard control char sequences

            if (peek() === $n) {
              this.state.peek = $LF;
            } else if (peek() === $r) {
              this.state.peek = $CR;
            } else if (peek() === $v) {
              this.state.peek = $VTAB;
            } else if (peek() === $t) {
              this.state.peek = $TAB;
            } else if (peek() === $b) {
              this.state.peek = $BSPACE;
            } else if (peek() === $f) {
              this.state.peek = $FF;
            } // Now consider more complex sequences
            else if (peek() === $u) {
                // Unicode code-point sequence
                this.advanceState(this.internalState); // advance past the `u` char

                if (peek() === $LBRACE) {
                  // Variable length Unicode, e.g. `\x{123}`
                  this.advanceState(this.internalState); // advance past the `{` char
                  // Advance past the variable number of hex digits until we hit a `}` char

                  var digitStart = this.clone();
                  var length = 0;

                  while (peek() !== $RBRACE) {
                    this.advanceState(this.internalState);
                    length++;
                  }

                  this.state.peek = this.decodeHexDigits(digitStart, length);
                } else {
                  // Fixed length Unicode, e.g. `\u1234`
                  var _digitStart = this.clone();

                  this.advanceState(this.internalState);
                  this.advanceState(this.internalState);
                  this.advanceState(this.internalState);
                  this.state.peek = this.decodeHexDigits(_digitStart, 4);
                }
              } else if (peek() === $x) {
                // Hex char code, e.g. `\x2F`
                this.advanceState(this.internalState); // advance past the `x` char

                var _digitStart2 = this.clone();

                this.advanceState(this.internalState);
                this.state.peek = this.decodeHexDigits(_digitStart2, 2);
              } else if (isOctalDigit(peek())) {
                // Octal char code, e.g. `\012`,
                var octal = '';
                var _length = 0;
                var previous = this.clone();

                while (isOctalDigit(peek()) && _length < 3) {
                  previous = this.clone();
                  octal += String.fromCodePoint(peek());
                  this.advanceState(this.internalState);
                  _length++;
                }

                this.state.peek = parseInt(octal, 8); // Backup one char

                this.internalState = previous.internalState;
              } else if (isNewLine(this.internalState.peek)) {
                // Line continuation `\` followed by a new line
                this.advanceState(this.internalState); // advance over the newline

                this.state = this.internalState;
              } else {
                // If none of the `if` blocks were executed then we just have an escaped normal character.
                // In that case we just, effectively, skip the backslash from the character.
                this.state.peek = this.internalState.peek;
              }
          }
        }
      }, {
        key: "decodeHexDigits",
        value: function decodeHexDigits(start, length) {
          var hex = this.input.substr(start.internalState.offset, length);
          var charCode = parseInt(hex, 16);

          if (!isNaN(charCode)) {
            return charCode;
          } else {
            start.state = start.internalState;
            throw new CursorError('Invalid hexadecimal escape sequence', start);
          }
        }
      }]);

      return EscapedCharacterCursor;
    }(PlainCharacterCursor);

    var CursorError = function CursorError(msg, cursor) {
      _classCallCheck(this, CursorError);

      this.msg = msg;
      this.cursor = cursor;
    };
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var TreeError =
    /*#__PURE__*/
    function (_ParseError2) {
      _inherits(TreeError, _ParseError2);

      function TreeError(elementName, span, msg) {
        var _this131;

        _classCallCheck(this, TreeError);

        _this131 = _possibleConstructorReturn(this, _getPrototypeOf(TreeError).call(this, span, msg));
        _this131.elementName = elementName;
        return _this131;
      }

      _createClass(TreeError, null, [{
        key: "create",
        value: function create(elementName, span, msg) {
          return new TreeError(elementName, span, msg);
        }
      }]);

      return TreeError;
    }(ParseError);

    var ParseTreeResult = function ParseTreeResult(rootNodes, errors) {
      _classCallCheck(this, ParseTreeResult);

      this.rootNodes = rootNodes;
      this.errors = errors;
    };

    var Parser =
    /*#__PURE__*/
    function () {
      function Parser(getTagDefinition) {
        _classCallCheck(this, Parser);

        this.getTagDefinition = getTagDefinition;
      }

      _createClass(Parser, [{
        key: "parse",
        value: function parse(source, url, options) {
          var tokensAndErrors = tokenize(source, url, this.getTagDefinition, options);
          var treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();
          return new ParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));
        }
      }]);

      return Parser;
    }();

    var _TreeBuilder =
    /*#__PURE__*/
    function () {
      function _TreeBuilder(tokens, getTagDefinition) {
        _classCallCheck(this, _TreeBuilder);

        this.tokens = tokens;
        this.getTagDefinition = getTagDefinition;
        this._index = -1;
        this._rootNodes = [];
        this._errors = [];
        this._elementStack = [];

        this._advance();
      }

      _createClass(_TreeBuilder, [{
        key: "build",
        value: function build() {
          while (this._peek.type !== TokenType.EOF) {
            if (this._peek.type === TokenType.TAG_OPEN_START) {
              this._consumeStartTag(this._advance());
            } else if (this._peek.type === TokenType.TAG_CLOSE) {
              this._consumeEndTag(this._advance());
            } else if (this._peek.type === TokenType.CDATA_START) {
              this._closeVoidElement();

              this._consumeCdata(this._advance());
            } else if (this._peek.type === TokenType.COMMENT_START) {
              this._closeVoidElement();

              this._consumeComment(this._advance());
            } else if (this._peek.type === TokenType.TEXT || this._peek.type === TokenType.RAW_TEXT || this._peek.type === TokenType.ESCAPABLE_RAW_TEXT) {
              this._closeVoidElement();

              this._consumeText(this._advance());
            } else if (this._peek.type === TokenType.EXPANSION_FORM_START) {
              this._consumeExpansion(this._advance());
            } else {
              // Skip all other tokens...
              this._advance();
            }
          }

          return new ParseTreeResult(this._rootNodes, this._errors);
        }
      }, {
        key: "_advance",
        value: function _advance() {
          var prev = this._peek;

          if (this._index < this.tokens.length - 1) {
            // Note: there is always an EOF token at the end
            this._index++;
          }

          this._peek = this.tokens[this._index];
          return prev;
        }
      }, {
        key: "_advanceIf",
        value: function _advanceIf(type) {
          if (this._peek.type === type) {
            return this._advance();
          }

          return null;
        }
      }, {
        key: "_consumeCdata",
        value: function _consumeCdata(startToken) {
          this._consumeText(this._advance());

          this._advanceIf(TokenType.CDATA_END);
        }
      }, {
        key: "_consumeComment",
        value: function _consumeComment(token) {
          var text = this._advanceIf(TokenType.RAW_TEXT);

          this._advanceIf(TokenType.COMMENT_END);

          var value = text != null ? text.parts[0].trim() : null;

          this._addToParent(new Comment(value, token.sourceSpan));
        }
      }, {
        key: "_consumeExpansion",
        value: function _consumeExpansion(token) {
          var switchValue = this._advance();

          var type = this._advance();

          var cases = []; // read =

          while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {
            var expCase = this._parseExpansionCase();

            if (!expCase) return; // error

            cases.push(expCase);
          } // read the final }


          if (this._peek.type !== TokenType.EXPANSION_FORM_END) {
            this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));

            return;
          }

          var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);

          this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));

          this._advance();
        }
      }, {
        key: "_parseExpansionCase",
        value: function _parseExpansionCase() {
          var value = this._advance(); // read {


          if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {
            this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'."));

            return null;
          } // read until }


          var start = this._advance();

          var exp = this._collectExpansionExpTokens(start);

          if (!exp) return null;

          var end = this._advance();

          exp.push(new Token(TokenType.EOF, [], end.sourceSpan)); // parse everything in between { and }

          var parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();

          if (parsedExp.errors.length > 0) {
            this._errors = this._errors.concat(parsedExp.errors);
            return null;
          }

          var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
          var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
          return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
        }
      }, {
        key: "_collectExpansionExpTokens",
        value: function _collectExpansionExpTokens(start) {
          var exp = [];
          var expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];

          while (true) {
            if (this._peek.type === TokenType.EXPANSION_FORM_START || this._peek.type === TokenType.EXPANSION_CASE_EXP_START) {
              expansionFormStack.push(this._peek.type);
            }

            if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {
              if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {
                expansionFormStack.pop();
                if (expansionFormStack.length == 0) return exp;
              } else {
                this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));

                return null;
              }
            }

            if (this._peek.type === TokenType.EXPANSION_FORM_END) {
              if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {
                expansionFormStack.pop();
              } else {
                this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));

                return null;
              }
            }

            if (this._peek.type === TokenType.EOF) {
              this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));

              return null;
            }

            exp.push(this._advance());
          }
        }
      }, {
        key: "_consumeText",
        value: function _consumeText(token) {
          var text = token.parts[0];

          if (text.length > 0 && text[0] == '\n') {
            var parent = this._getParentElement();

            if (parent != null && parent.children.length == 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {
              text = text.substring(1);
            }
          }

          if (text.length > 0) {
            this._addToParent(new Text$3(text, token.sourceSpan));
          }
        }
      }, {
        key: "_closeVoidElement",
        value: function _closeVoidElement() {
          var el = this._getParentElement();

          if (el && this.getTagDefinition(el.name).isVoid) {
            this._elementStack.pop();
          }
        }
      }, {
        key: "_consumeStartTag",
        value: function _consumeStartTag(startTagToken) {
          var prefix = startTagToken.parts[0];
          var name = startTagToken.parts[1];
          var attrs = [];

          while (this._peek.type === TokenType.ATTR_NAME) {
            attrs.push(this._consumeAttr(this._advance()));
          }

          var fullName = this._getElementFullName(prefix, name, this._getParentElement());

          var selfClosing = false; // Note: There could have been a tokenizer error
          // so that we don't get a token for the end tag...

          if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {
            this._advance();

            selfClosing = true;
            var tagDef = this.getTagDefinition(fullName);

            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
              this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"".concat(startTagToken.parts[1], "\"")));
            }
          } else if (this._peek.type === TokenType.TAG_OPEN_END) {
            this._advance();

            selfClosing = false;
          }

          var end = this._peek.sourceSpan.start;
          var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
          var el = new Element$1(fullName, attrs, [], span, span, undefined);

          this._pushElement(el);

          if (selfClosing) {
            this._popElement(fullName);

            el.endSourceSpan = span;
          }
        }
      }, {
        key: "_pushElement",
        value: function _pushElement(el) {
          var parentEl = this._getParentElement();

          if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
            this._elementStack.pop();
          }

          this._addToParent(el);

          this._elementStack.push(el);
        }
      }, {
        key: "_consumeEndTag",
        value: function _consumeEndTag(endTagToken) {
          var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());

          if (this._getParentElement()) {
            this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
          }

          if (this.getTagDefinition(fullName).isVoid) {
            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"".concat(endTagToken.parts[1], "\"")));
          } else if (!this._popElement(fullName)) {
            var errMsg = "Unexpected closing tag \"".concat(fullName, "\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags");

            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
          }
        }
      }, {
        key: "_popElement",
        value: function _popElement(fullName) {
          for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
            var el = this._elementStack[stackIndex];

            if (el.name == fullName) {
              this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);

              return true;
            }

            if (!this.getTagDefinition(el.name).closedByParent) {
              return false;
            }
          }

          return false;
        }
      }, {
        key: "_consumeAttr",
        value: function _consumeAttr(attrName) {
          var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
          var end = attrName.sourceSpan.end;
          var value = '';
          var valueSpan = undefined;

          if (this._peek.type === TokenType.ATTR_QUOTE) {
            this._advance();
          }

          if (this._peek.type === TokenType.ATTR_VALUE) {
            var valueToken = this._advance();

            value = valueToken.parts[0];
            end = valueToken.sourceSpan.end;
            valueSpan = valueToken.sourceSpan;
          }

          if (this._peek.type === TokenType.ATTR_QUOTE) {
            var quoteToken = this._advance();

            end = quoteToken.sourceSpan.end;
          }

          return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);
        }
      }, {
        key: "_getParentElement",
        value: function _getParentElement() {
          return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
        }
        /**
         * Returns the parent in the DOM and the container.
         *
         * `<ng-container>` elements are skipped as they are not rendered as DOM element.
         */

      }, {
        key: "_getParentElementSkippingContainers",
        value: function _getParentElementSkippingContainers() {
          var container = null;

          for (var i = this._elementStack.length - 1; i >= 0; i--) {
            if (!isNgContainer(this._elementStack[i].name)) {
              return {
                parent: this._elementStack[i],
                container: container
              };
            }

            container = this._elementStack[i];
          }

          return {
            parent: null,
            container: container
          };
        }
      }, {
        key: "_addToParent",
        value: function _addToParent(node) {
          var parent = this._getParentElement();

          if (parent != null) {
            parent.children.push(node);
          } else {
            this._rootNodes.push(node);
          }
        }
        /**
         * Insert a node between the parent and the container.
         * When no container is given, the node is appended as a child of the parent.
         * Also updates the element stack accordingly.
         *
         * @internal
         */

      }, {
        key: "_insertBeforeContainer",
        value: function _insertBeforeContainer(parent, container, node) {
          if (!container) {
            this._addToParent(node);

            this._elementStack.push(node);
          } else {
            if (parent) {
              // replace the container with the new node in the children
              var index = parent.children.indexOf(container);
              parent.children[index] = node;
            } else {
              this._rootNodes.push(node);
            }

            node.children.push(container);

            this._elementStack.splice(this._elementStack.indexOf(container), 0, node);
          }
        }
      }, {
        key: "_getElementFullName",
        value: function _getElementFullName(prefix, localName, parentElement) {
          if (prefix === '') {
            prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';

            if (prefix === '' && parentElement != null) {
              prefix = getNsPrefix(parentElement.name);
            }
          }

          return mergeNsAndName(prefix, localName);
        }
      }]);

      return _TreeBuilder;
    }();

    function lastOnStack(stack, element) {
      return stack.length > 0 && stack[stack.length - 1] === element;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var HtmlParser =
    /*#__PURE__*/
    function (_Parser) {
      _inherits(HtmlParser, _Parser);

      function HtmlParser() {
        _classCallCheck(this, HtmlParser);

        return _possibleConstructorReturn(this, _getPrototypeOf(HtmlParser).call(this, getHtmlTagDefinition));
      }

      _createClass(HtmlParser, [{
        key: "parse",
        value: function parse(source, url, options) {
          return _get(_getPrototypeOf(HtmlParser.prototype), "parse", this).call(this, source, url, options);
        }
      }]);

      return HtmlParser;
    }(Parser);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';
    var SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']); // Equivalent to \s with \u00a0 (non-breaking space) excluded.
    // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp

    var WS_CHARS = " \f\n\r\t\x0B\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF";
    var NO_WS_REGEXP = new RegExp("[^".concat(WS_CHARS, "]"));
    var WS_REPLACE_REGEXP = new RegExp("[".concat(WS_CHARS, "]{2,}"), 'g');

    function hasPreserveWhitespacesAttr(attrs) {
      return attrs.some(function (attr) {
        return attr.name === PRESERVE_WS_ATTR_NAME;
      });
    }
    /**
     * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:
     * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32
     * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character
     * and later on replaced by a space. We are re-implementing the same idea here.
     */


    function replaceNgsp(value) {
      // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE
      return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');
    }
    /**
     * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:
     * - consider spaces, tabs and new lines as whitespace characters;
     * - drop text nodes consisting of whitespace characters only;
     * - for all other text nodes replace consecutive whitespace characters with one space;
     * - convert &ngsp; pseudo-entity to a single space;
     *
     * Removal and trimming of whitespaces have positive performance impact (less code to generate
     * while compiling templates, faster view creation). At the same time it can be "destructive"
     * in some cases (whitespaces can influence layout). Because of the potential of breaking layout
     * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for
     * whitespace removal. The default option for whitespace removal will be revisited in Angular 6
     * and might be changed to "on" by default.
     */


    var WhitespaceVisitor =
    /*#__PURE__*/
    function () {
      function WhitespaceVisitor() {
        _classCallCheck(this, WhitespaceVisitor);
      }

      _createClass(WhitespaceVisitor, [{
        key: "visitElement",
        value: function visitElement(element, context) {
          if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {
            // don't descent into elements where we need to preserve whitespaces
            // but still visit all attributes to eliminate one used as a market to preserve WS
            return new Element$1(element.name, visitAll$1(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
          }

          return new Element$1(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {
          return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
        }
      }, {
        key: "visitText",
        value: function visitText(text, context) {
          var isNotBlank = text.value.match(NO_WS_REGEXP);
          var hasExpansionSibling = context && (context.prev instanceof Expansion || context.next instanceof Expansion);

          if (isNotBlank || hasExpansionSibling) {
            return new Text$3(replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan, text.i18n);
          }

          return null;
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {
          return comment;
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(expansion, context) {
          return expansion;
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(expansionCase, context) {
          return expansionCase;
        }
      }]);

      return WhitespaceVisitor;
    }();

    function removeWhitespaces(htmlAstWithErrors) {
      return new ParseTreeResult(visitAll$1(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);
    }

    function visitAllWithSiblings(visitor, nodes) {
      var result = [];
      nodes.forEach(function (ast, i) {
        var context = {
          prev: nodes[i - 1],
          next: nodes[i + 1]
        };
        var astResult = ast.visit(visitor, context);

        if (astResult) {
          result.push(astResult);
        }
      });
      return result;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // http://cldr.unicode.org/index/cldr-spec/plural-rules


    var PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
    /**
     * Expands special forms into elements.
     *
     * For example,
     *
     * ```
     * { messages.length, plural,
     *   =0 {zero}
     *   =1 {one}
     *   other {more than one}
     * }
     * ```
     *
     * will be expanded into
     *
     * ```
     * <ng-container [ngPlural]="messages.length">
     *   <ng-template ngPluralCase="=0">zero</ng-template>
     *   <ng-template ngPluralCase="=1">one</ng-template>
     *   <ng-template ngPluralCase="other">more than one</ng-template>
     * </ng-container>
     * ```
     */

    function expandNodes(nodes) {
      var expander = new _Expander();
      return new ExpansionResult(visitAll$1(expander, nodes), expander.isExpanded, expander.errors);
    }

    var ExpansionResult = function ExpansionResult(nodes, expanded, errors) {
      _classCallCheck(this, ExpansionResult);

      this.nodes = nodes;
      this.expanded = expanded;
      this.errors = errors;
    };

    var ExpansionError =
    /*#__PURE__*/
    function (_ParseError3) {
      _inherits(ExpansionError, _ParseError3);

      function ExpansionError(span, errorMsg) {
        _classCallCheck(this, ExpansionError);

        return _possibleConstructorReturn(this, _getPrototypeOf(ExpansionError).call(this, span, errorMsg));
      }

      return ExpansionError;
    }(ParseError);
    /**
     * Expand expansion forms (plural, select) to directives
     *
     * @internal
     */


    var _Expander =
    /*#__PURE__*/
    function () {
      function _Expander() {
        _classCallCheck(this, _Expander);

        this.isExpanded = false;
        this.errors = [];
      }

      _createClass(_Expander, [{
        key: "visitElement",
        value: function visitElement(element, context) {
          return new Element$1(element.name, element.attrs, visitAll$1(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {
          return attribute;
        }
      }, {
        key: "visitText",
        value: function visitText(text, context) {
          return text;
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {
          return comment;
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(icu, context) {
          this.isExpanded = true;
          return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) : _expandDefaultForm(icu, this.errors);
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(icuCase, context) {
          throw new Error('Should not be reached');
        }
      }]);

      return _Expander;
    }(); // Plural forms are expanded to `NgPlural` and `NgPluralCase`s


    function _expandPluralForm(ast, errors) {
      var children = ast.cases.map(function (c) {
        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\d+$/)) {
          errors.push(new ExpansionError(c.valueSourceSpan, "Plural cases should be \"=<number>\" or one of ".concat(PLURAL_CASES.join(", "))));
        }

        var expansionResult = expandNodes(c.expression);
        errors.push.apply(errors, _toConsumableArray(expansionResult.errors));
        return new Element$1("ng-template", [new Attribute('ngPluralCase', "".concat(c.value), c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
      });
      var switchAttr = new Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);
      return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
    } // ICU messages (excluding plural form) are expanded to `NgSwitch`  and `NgSwitchCase`s


    function _expandDefaultForm(ast, errors) {
      var children = ast.cases.map(function (c) {
        var expansionResult = expandNodes(c.expression);
        errors.push.apply(errors, _toConsumableArray(expansionResult.errors));

        if (c.value === 'other') {
          // other is the default case when no values match
          return new Element$1("ng-template", [new Attribute('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
        }

        return new Element$1("ng-template", [new Attribute('ngSwitchCase', "".concat(c.value), c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
      });
      var switchAttr = new Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);
      return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * A segment of text within the template.
     */


    var TextAst =
    /*#__PURE__*/
    function () {
      function TextAst(value, ngContentIndex, sourceSpan) {
        _classCallCheck(this, TextAst);

        this.value = value;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
      }

      _createClass(TextAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitText(this, context);
        }
      }]);

      return TextAst;
    }();
    /**
     * A bound expression within the text of a template.
     */


    var BoundTextAst =
    /*#__PURE__*/
    function () {
      function BoundTextAst(value, ngContentIndex, sourceSpan) {
        _classCallCheck(this, BoundTextAst);

        this.value = value;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
      }

      _createClass(BoundTextAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitBoundText(this, context);
        }
      }]);

      return BoundTextAst;
    }();
    /**
     * A plain attribute on an element.
     */


    var AttrAst =
    /*#__PURE__*/
    function () {
      function AttrAst(name, value, sourceSpan) {
        _classCallCheck(this, AttrAst);

        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
      }

      _createClass(AttrAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitAttr(this, context);
        }
      }]);

      return AttrAst;
    }();

    var BoundPropertyMapping = (_BoundPropertyMapping = {}, _defineProperty(_BoundPropertyMapping, 4
    /* Animation */
    , 4), _defineProperty(_BoundPropertyMapping, 1
    /* Attribute */
    ,
    /* Animation */
    1), _defineProperty(_BoundPropertyMapping, 2
    /* Class */
    ,
    /* Attribute */
    2), _defineProperty(_BoundPropertyMapping, 0
    /* Property */
    ,
    /* Class */
    0), _defineProperty(_BoundPropertyMapping, 3
    /* Style */
    ,
    /* Property */
    3), _BoundPropertyMapping);
    /**
     * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
     * `[@trigger]="stateExp"`)
     */

    var BoundElementPropertyAst =
    /*#__PURE__*/
    function () {
      function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {
        _classCallCheck(this, BoundElementPropertyAst);

        this.name = name;
        this.type = type;
        this.securityContext = securityContext;
        this.value = value;
        this.unit = unit;
        this.sourceSpan = sourceSpan;
        this.isAnimation = this.type === 4
        /* Animation */
        ;
      }

      _createClass(BoundElementPropertyAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitElementProperty(this, context);
        }
      }], [{
        key: "fromBoundProperty",
        value: function fromBoundProperty(prop) {
          var type = BoundPropertyMapping[prop.type];
          return new BoundElementPropertyAst(prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);
        }
      }]);

      return BoundElementPropertyAst;
    }();
    /**
     * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
     * `(@trigger.phase)="callback($event)"`).
     */


    var BoundEventAst =
    /*#__PURE__*/
    function () {
      function BoundEventAst(name, target, phase, handler, sourceSpan, handlerSpan) {
        _classCallCheck(this, BoundEventAst);

        this.name = name;
        this.target = target;
        this.phase = phase;
        this.handler = handler;
        this.sourceSpan = sourceSpan;
        this.handlerSpan = handlerSpan;
        this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);
        this.isAnimation = !!this.phase;
      }

      _createClass(BoundEventAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitEvent(this, context);
        }
      }], [{
        key: "calcFullName",
        value: function calcFullName(name, target, phase) {
          if (target) {
            return "".concat(target, ":").concat(name);
          }

          if (phase) {
            return "@".concat(name, ".").concat(phase);
          }

          return name;
        }
      }, {
        key: "fromParsedEvent",
        value: function fromParsedEvent(event) {
          var target = event.type === 0
          /* Regular */
          ? event.targetOrPhase : null;
          var phase = event.type === 1
          /* Animation */
          ? event.targetOrPhase : null;
          return new BoundEventAst(event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);
        }
      }]);

      return BoundEventAst;
    }();
    /**
     * A reference declaration on an element (e.g. `let someName="expression"`).
     */


    var ReferenceAst =
    /*#__PURE__*/
    function () {
      function ReferenceAst(name, value, originalValue, sourceSpan) {
        _classCallCheck(this, ReferenceAst);

        this.name = name;
        this.value = value;
        this.originalValue = originalValue;
        this.sourceSpan = sourceSpan;
      }

      _createClass(ReferenceAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitReference(this, context);
        }
      }]);

      return ReferenceAst;
    }();
    /**
     * A variable declaration on a <ng-template> (e.g. `var-someName="someLocalName"`).
     */


    var VariableAst =
    /*#__PURE__*/
    function () {
      function VariableAst(name, value, sourceSpan) {
        _classCallCheck(this, VariableAst);

        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
      }

      _createClass(VariableAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitVariable(this, context);
        }
      }], [{
        key: "fromParsedVariable",
        value: function fromParsedVariable(v) {
          return new VariableAst(v.name, v.value, v.sourceSpan);
        }
      }]);

      return VariableAst;
    }();
    /**
     * An element declaration in a template.
     */


    var ElementAst =
    /*#__PURE__*/
    function () {
      function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {
        _classCallCheck(this, ElementAst);

        this.name = name;
        this.attrs = attrs;
        this.inputs = inputs;
        this.outputs = outputs;
        this.references = references;
        this.directives = directives;
        this.providers = providers;
        this.hasViewContainer = hasViewContainer;
        this.queryMatches = queryMatches;
        this.children = children;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
        this.endSourceSpan = endSourceSpan;
      }

      _createClass(ElementAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitElement(this, context);
        }
      }]);

      return ElementAst;
    }();
    /**
     * A `<ng-template>` element included in an Angular template.
     */


    var EmbeddedTemplateAst =
    /*#__PURE__*/
    function () {
      function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {
        _classCallCheck(this, EmbeddedTemplateAst);

        this.attrs = attrs;
        this.outputs = outputs;
        this.references = references;
        this.variables = variables;
        this.directives = directives;
        this.providers = providers;
        this.hasViewContainer = hasViewContainer;
        this.queryMatches = queryMatches;
        this.children = children;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
      }

      _createClass(EmbeddedTemplateAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitEmbeddedTemplate(this, context);
        }
      }]);

      return EmbeddedTemplateAst;
    }();
    /**
     * A directive property with a bound value (e.g. `*ngIf="condition").
     */


    var BoundDirectivePropertyAst =
    /*#__PURE__*/
    function () {
      function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
        _classCallCheck(this, BoundDirectivePropertyAst);

        this.directiveName = directiveName;
        this.templateName = templateName;
        this.value = value;
        this.sourceSpan = sourceSpan;
      }

      _createClass(BoundDirectivePropertyAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitDirectiveProperty(this, context);
        }
      }]);

      return BoundDirectivePropertyAst;
    }();
    /**
     * A directive declared on an element.
     */


    var DirectiveAst =
    /*#__PURE__*/
    function () {
      function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {
        _classCallCheck(this, DirectiveAst);

        this.directive = directive;
        this.inputs = inputs;
        this.hostProperties = hostProperties;
        this.hostEvents = hostEvents;
        this.contentQueryStartId = contentQueryStartId;
        this.sourceSpan = sourceSpan;
      }

      _createClass(DirectiveAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitDirective(this, context);
        }
      }]);

      return DirectiveAst;
    }();
    /**
     * A provider declared on an element
     */


    var ProviderAst =
    /*#__PURE__*/
    function () {
      function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan, isModule) {
        _classCallCheck(this, ProviderAst);

        this.token = token;
        this.multiProvider = multiProvider;
        this.eager = eager;
        this.providers = providers;
        this.providerType = providerType;
        this.lifecycleHooks = lifecycleHooks;
        this.sourceSpan = sourceSpan;
        this.isModule = isModule;
      }

      _createClass(ProviderAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          // No visit method in the visitor for now...
          return null;
        }
      }]);

      return ProviderAst;
    }();

    var ProviderAstType;

    (function (ProviderAstType) {
      ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
      ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
      ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
      ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
      ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
    })(ProviderAstType || (ProviderAstType = {}));
    /**
     * Position where content is to be projected (instance of `<ng-content>` in a template).
     */


    var NgContentAst =
    /*#__PURE__*/
    function () {
      function NgContentAst(index, ngContentIndex, sourceSpan) {
        _classCallCheck(this, NgContentAst);

        this.index = index;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
      }

      _createClass(NgContentAst, [{
        key: "visit",
        value: function visit(visitor, context) {
          return visitor.visitNgContent(this, context);
        }
      }]);

      return NgContentAst;
    }();
    /**
     * A visitor that accepts each node but doesn't do anything. It is intended to be used
     * as the base class for a visitor that is only interested in a subset of the node types.
     */


    var NullTemplateVisitor =
    /*#__PURE__*/
    function () {
      function NullTemplateVisitor() {
        _classCallCheck(this, NullTemplateVisitor);
      }

      _createClass(NullTemplateVisitor, [{
        key: "visitNgContent",
        value: function visitNgContent(ast, context) {}
      }, {
        key: "visitEmbeddedTemplate",
        value: function visitEmbeddedTemplate(ast, context) {}
      }, {
        key: "visitElement",
        value: function visitElement(ast, context) {}
      }, {
        key: "visitReference",
        value: function visitReference(ast, context) {}
      }, {
        key: "visitVariable",
        value: function visitVariable(ast, context) {}
      }, {
        key: "visitEvent",
        value: function visitEvent(ast, context) {}
      }, {
        key: "visitElementProperty",
        value: function visitElementProperty(ast, context) {}
      }, {
        key: "visitAttr",
        value: function visitAttr(ast, context) {}
      }, {
        key: "visitBoundText",
        value: function visitBoundText(ast, context) {}
      }, {
        key: "visitText",
        value: function visitText(ast, context) {}
      }, {
        key: "visitDirective",
        value: function visitDirective(ast, context) {}
      }, {
        key: "visitDirectiveProperty",
        value: function visitDirectiveProperty(ast, context) {}
      }]);

      return NullTemplateVisitor;
    }();
    /**
     * Base class that can be used to build a visitor that visits each node
     * in an template ast recursively.
     */


    var RecursiveTemplateAstVisitor =
    /*#__PURE__*/
    function (_NullTemplateVisitor) {
      _inherits(RecursiveTemplateAstVisitor, _NullTemplateVisitor);

      function RecursiveTemplateAstVisitor() {
        _classCallCheck(this, RecursiveTemplateAstVisitor);

        return _possibleConstructorReturn(this, _getPrototypeOf(RecursiveTemplateAstVisitor).call(this));
      } // Nodes with children


      _createClass(RecursiveTemplateAstVisitor, [{
        key: "visitEmbeddedTemplate",
        value: function visitEmbeddedTemplate(ast, context) {
          return this.visitChildren(context, function (visit) {
            visit(ast.attrs);
            visit(ast.references);
            visit(ast.variables);
            visit(ast.directives);
            visit(ast.providers);
            visit(ast.children);
          });
        }
      }, {
        key: "visitElement",
        value: function visitElement(ast, context) {
          return this.visitChildren(context, function (visit) {
            visit(ast.attrs);
            visit(ast.inputs);
            visit(ast.outputs);
            visit(ast.references);
            visit(ast.directives);
            visit(ast.providers);
            visit(ast.children);
          });
        }
      }, {
        key: "visitDirective",
        value: function visitDirective(ast, context) {
          return this.visitChildren(context, function (visit) {
            visit(ast.inputs);
            visit(ast.hostProperties);
            visit(ast.hostEvents);
          });
        }
      }, {
        key: "visitChildren",
        value: function visitChildren(context, cb) {
          var results = [];
          var t = this;

          function visit(children) {
            if (children && children.length) results.push(templateVisitAll(t, children, context));
          }

          cb(visit);
          return Array.prototype.concat.apply([], results);
        }
      }]);

      return RecursiveTemplateAstVisitor;
    }(NullTemplateVisitor);
    /**
     * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
     */


    function templateVisitAll(visitor, asts) {
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var result = [];
      var visit = visitor.visit ? function (ast) {
        return visitor.visit(ast, context) || ast.visit(visitor, context);
      } : function (ast) {
        return ast.visit(visitor, context);
      };
      asts.forEach(function (ast) {
        var astResult = visit(ast);

        if (astResult) {
          result.push(astResult);
        }
      });
      return result;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var ProviderError =
    /*#__PURE__*/
    function (_ParseError4) {
      _inherits(ProviderError, _ParseError4);

      function ProviderError(message, span) {
        _classCallCheck(this, ProviderError);

        return _possibleConstructorReturn(this, _getPrototypeOf(ProviderError).call(this, span, message));
      }

      return ProviderError;
    }(ParseError);

    var ProviderViewContext = function ProviderViewContext(reflector, component) {
      var _this132 = this;

      _classCallCheck(this, ProviderViewContext);

      this.reflector = reflector;
      this.component = component;
      this.errors = [];
      this.viewQueries = _getViewQueries(component);
      this.viewProviders = new Map();
      component.viewProviders.forEach(function (provider) {
        if (_this132.viewProviders.get(tokenReference(provider.token)) == null) {
          _this132.viewProviders.set(tokenReference(provider.token), true);
        }
      });
    };

    var ProviderElementContext =
    /*#__PURE__*/
    function () {
      function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {
        var _this133 = this;

        _classCallCheck(this, ProviderElementContext);

        this.viewContext = viewContext;
        this._parent = _parent;
        this._isViewRoot = _isViewRoot;
        this._directiveAsts = _directiveAsts;
        this._sourceSpan = _sourceSpan;
        this._transformedProviders = new Map();
        this._seenProviders = new Map();
        this._queriedTokens = new Map();
        this.transformedHasViewContainer = false;
        this._attrs = {};
        attrs.forEach(function (attrAst) {
          return _this133._attrs[attrAst.name] = attrAst.value;
        });

        var directivesMeta = _directiveAsts.map(function (directiveAst) {
          return directiveAst.directive;
        });

        this._allProviders = _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);
        this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);
        Array.from(this._allProviders.values()).forEach(function (provider) {
          _this133._addQueryReadsTo(provider.token, provider.token, _this133._queriedTokens);
        });

        if (isTemplate) {
          var templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);

          this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);
        }

        refs.forEach(function (refAst) {
          var defaultQueryValue = refAst.value || createTokenForExternalReference(_this133.viewContext.reflector, Identifiers.ElementRef);

          _this133._addQueryReadsTo({
            value: refAst.name
          }, defaultQueryValue, _this133._queriedTokens);
        });

        if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {
          this.transformedHasViewContainer = true;
        } // create the providers that we know are eager first


        Array.from(this._allProviders.values()).forEach(function (provider) {
          var eager = provider.eager || _this133._queriedTokens.get(tokenReference(provider.token));

          if (eager) {
            _this133._getOrCreateLocalProvider(provider.providerType, provider.token, true);
          }
        });
      }

      _createClass(ProviderElementContext, [{
        key: "afterElement",
        value: function afterElement() {
          var _this134 = this;

          // collect lazy providers
          Array.from(this._allProviders.values()).forEach(function (provider) {
            _this134._getOrCreateLocalProvider(provider.providerType, provider.token, false);
          });
        }
      }, {
        key: "_addQueryReadsTo",
        value: function _addQueryReadsTo(token, defaultValue, queryReadTokens) {
          this._getQueriesFor(token).forEach(function (query) {
            var queryValue = query.meta.read || defaultValue;
            var tokenRef = tokenReference(queryValue);
            var queryMatches = queryReadTokens.get(tokenRef);

            if (!queryMatches) {
              queryMatches = [];
              queryReadTokens.set(tokenRef, queryMatches);
            }

            queryMatches.push({
              queryId: query.queryId,
              value: queryValue
            });
          });
        }
      }, {
        key: "_getQueriesFor",
        value: function _getQueriesFor(token) {
          var result = [];
          var currentEl = this;
          var distance = 0;
          var queries;

          while (currentEl !== null) {
            queries = currentEl._contentQueries.get(tokenReference(token));

            if (queries) {
              result.push.apply(result, _toConsumableArray(queries.filter(function (query) {
                return query.meta.descendants || distance <= 1;
              })));
            }

            if (currentEl._directiveAsts.length > 0) {
              distance++;
            }

            currentEl = currentEl._parent;
          }

          queries = this.viewContext.viewQueries.get(tokenReference(token));

          if (queries) {
            result.push.apply(result, _toConsumableArray(queries));
          }

          return result;
        }
      }, {
        key: "_getOrCreateLocalProvider",
        value: function _getOrCreateLocalProvider(requestingProviderType, token, eager) {
          var _this135 = this;

          var resolvedProvider = this._allProviders.get(tokenReference(token));

          if (!resolvedProvider || (requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.PrivateService || (requestingProviderType === ProviderAstType.PrivateService || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.Builtin) {
            return null;
          }

          var transformedProviderAst = this._transformedProviders.get(tokenReference(token));

          if (transformedProviderAst) {
            return transformedProviderAst;
          }

          if (this._seenProviders.get(tokenReference(token)) != null) {
            this.viewContext.errors.push(new ProviderError("Cannot instantiate cyclic dependency! ".concat(tokenName(token)), this._sourceSpan));
            return null;
          }

          this._seenProviders.set(tokenReference(token), true);

          var transformedProviders = resolvedProvider.providers.map(function (provider) {
            var transformedUseValue = provider.useValue;
            var transformedUseExisting = provider.useExisting;
            var transformedDeps = undefined;

            if (provider.useExisting != null) {
              var existingDiDep = _this135._getDependency(resolvedProvider.providerType, {
                token: provider.useExisting
              }, eager);

              if (existingDiDep.token != null) {
                transformedUseExisting = existingDiDep.token;
              } else {
                transformedUseExisting = null;
                transformedUseValue = existingDiDep.value;
              }
            } else if (provider.useFactory) {
              var deps = provider.deps || provider.useFactory.diDeps;
              transformedDeps = deps.map(function (dep) {
                return _this135._getDependency(resolvedProvider.providerType, dep, eager);
              });
            } else if (provider.useClass) {
              var _deps = provider.deps || provider.useClass.diDeps;

              transformedDeps = _deps.map(function (dep) {
                return _this135._getDependency(resolvedProvider.providerType, dep, eager);
              });
            }

            return _transformProvider(provider, {
              useExisting: transformedUseExisting,
              useValue: transformedUseValue,
              deps: transformedDeps
            });
          });
          transformedProviderAst = _transformProviderAst(resolvedProvider, {
            eager: eager,
            providers: transformedProviders
          });

          this._transformedProviders.set(tokenReference(token), transformedProviderAst);

          return transformedProviderAst;
        }
      }, {
        key: "_getLocalDependency",
        value: function _getLocalDependency(requestingProviderType, dep) {
          var eager = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (dep.isAttribute) {
            var attrValue = this._attrs[dep.token.value];
            return {
              isValue: true,
              value: attrValue == null ? null : attrValue
            };
          }

          if (dep.token != null) {
            // access builtints
            if (requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.Component) {
              if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.ChangeDetectorRef) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {
                return dep;
              }

              if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {
                this.transformedHasViewContainer = true;
              }
            } // access the injector


            if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {
              return dep;
            } // access providers


            if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {
              return dep;
            }
          }

          return null;
        }
      }, {
        key: "_getDependency",
        value: function _getDependency(requestingProviderType, dep) {
          var eager = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var currElement = this;
          var currEager = eager;
          var result = null;

          if (!dep.isSkipSelf) {
            result = this._getLocalDependency(requestingProviderType, dep, eager);
          }

          if (dep.isSelf) {
            if (!result && dep.isOptional) {
              result = {
                isValue: true,
                value: null
              };
            }
          } else {
            // check parent elements
            while (!result && currElement._parent) {
              var prevElement = currElement;
              currElement = currElement._parent;

              if (prevElement._isViewRoot) {
                currEager = false;
              }

              result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);
            } // check @Host restriction


            if (!result) {
              if (!dep.isHost || this.viewContext.component.isHost || this.viewContext.component.type.reference === tokenReference(dep.token) || this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {
                result = dep;
              } else {
                result = dep.isOptional ? {
                  isValue: true,
                  value: null
                } : null;
              }
            }
          }

          if (!result) {
            this.viewContext.errors.push(new ProviderError("No provider for ".concat(tokenName(dep.token)), this._sourceSpan));
          }

          return result;
        }
      }, {
        key: "transformProviders",
        get: function get() {
          // Note: Maps keep their insertion order.
          var lazyProviders = [];
          var eagerProviders = [];

          this._transformedProviders.forEach(function (provider) {
            if (provider.eager) {
              eagerProviders.push(provider);
            } else {
              lazyProviders.push(provider);
            }
          });

          return lazyProviders.concat(eagerProviders);
        }
      }, {
        key: "transformedDirectiveAsts",
        get: function get() {
          var sortedProviderTypes = this.transformProviders.map(function (provider) {
            return provider.token.identifier;
          });

          var sortedDirectives = this._directiveAsts.slice();

          sortedDirectives.sort(function (dir1, dir2) {
            return sortedProviderTypes.indexOf(dir1.directive.type) - sortedProviderTypes.indexOf(dir2.directive.type);
          });
          return sortedDirectives;
        }
      }, {
        key: "queryMatches",
        get: function get() {
          var allMatches = [];

          this._queriedTokens.forEach(function (matches) {
            allMatches.push.apply(allMatches, _toConsumableArray(matches));
          });

          return allMatches;
        }
      }]);

      return ProviderElementContext;
    }();

    var NgModuleProviderAnalyzer =
    /*#__PURE__*/
    function () {
      function NgModuleProviderAnalyzer(reflector, ngModule, extraProviders, sourceSpan) {
        var _this136 = this;

        _classCallCheck(this, NgModuleProviderAnalyzer);

        this.reflector = reflector;
        this._transformedProviders = new Map();
        this._seenProviders = new Map();
        this._errors = [];
        this._allProviders = new Map();
        ngModule.transitiveModule.modules.forEach(function (ngModuleType) {
          var ngModuleProvider = {
            token: {
              identifier: ngModuleType
            },
            useClass: ngModuleType
          };

          _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this136._errors, _this136._allProviders,
          /* isModule */
          true);
        });

        _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) {
          return entry.provider;
        }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders,
        /* isModule */
        false);
      }

      _createClass(NgModuleProviderAnalyzer, [{
        key: "parse",
        value: function parse() {
          var _this137 = this;

          Array.from(this._allProviders.values()).forEach(function (provider) {
            _this137._getOrCreateLocalProvider(provider.token, provider.eager);
          });

          if (this._errors.length > 0) {
            var errorString = this._errors.join('\n');

            throw new Error("Provider parse errors:\n".concat(errorString));
          } // Note: Maps keep their insertion order.


          var lazyProviders = [];
          var eagerProviders = [];

          this._transformedProviders.forEach(function (provider) {
            if (provider.eager) {
              eagerProviders.push(provider);
            } else {
              lazyProviders.push(provider);
            }
          });

          return lazyProviders.concat(eagerProviders);
        }
      }, {
        key: "_getOrCreateLocalProvider",
        value: function _getOrCreateLocalProvider(token, eager) {
          var _this138 = this;

          var resolvedProvider = this._allProviders.get(tokenReference(token));

          if (!resolvedProvider) {
            return null;
          }

          var transformedProviderAst = this._transformedProviders.get(tokenReference(token));

          if (transformedProviderAst) {
            return transformedProviderAst;
          }

          if (this._seenProviders.get(tokenReference(token)) != null) {
            this._errors.push(new ProviderError("Cannot instantiate cyclic dependency! ".concat(tokenName(token)), resolvedProvider.sourceSpan));

            return null;
          }

          this._seenProviders.set(tokenReference(token), true);

          var transformedProviders = resolvedProvider.providers.map(function (provider) {
            var transformedUseValue = provider.useValue;
            var transformedUseExisting = provider.useExisting;
            var transformedDeps = undefined;

            if (provider.useExisting != null) {
              var existingDiDep = _this138._getDependency({
                token: provider.useExisting
              }, eager, resolvedProvider.sourceSpan);

              if (existingDiDep.token != null) {
                transformedUseExisting = existingDiDep.token;
              } else {
                transformedUseExisting = null;
                transformedUseValue = existingDiDep.value;
              }
            } else if (provider.useFactory) {
              var deps = provider.deps || provider.useFactory.diDeps;
              transformedDeps = deps.map(function (dep) {
                return _this138._getDependency(dep, eager, resolvedProvider.sourceSpan);
              });
            } else if (provider.useClass) {
              var _deps2 = provider.deps || provider.useClass.diDeps;

              transformedDeps = _deps2.map(function (dep) {
                return _this138._getDependency(dep, eager, resolvedProvider.sourceSpan);
              });
            }

            return _transformProvider(provider, {
              useExisting: transformedUseExisting,
              useValue: transformedUseValue,
              deps: transformedDeps
            });
          });
          transformedProviderAst = _transformProviderAst(resolvedProvider, {
            eager: eager,
            providers: transformedProviders
          });

          this._transformedProviders.set(tokenReference(token), transformedProviderAst);

          return transformedProviderAst;
        }
      }, {
        key: "_getDependency",
        value: function _getDependency(dep) {
          var eager = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var requestorSourceSpan = arguments.length > 2 ? arguments[2] : undefined;
          var foundLocal = false;

          if (!dep.isSkipSelf && dep.token != null) {
            // access the injector
            if (tokenReference(dep.token) === this.reflector.resolveExternalReference(Identifiers.Injector) || tokenReference(dep.token) === this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {
              foundLocal = true; // access providers
            } else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {
              foundLocal = true;
            }
          }

          return dep;
        }
      }]);

      return NgModuleProviderAnalyzer;
    }();

    function _transformProvider(provider, _ref11) {
      var useExisting = _ref11.useExisting,
          useValue = _ref11.useValue,
          deps = _ref11.deps;
      return {
        token: provider.token,
        useClass: provider.useClass,
        useExisting: useExisting,
        useFactory: provider.useFactory,
        useValue: useValue,
        deps: deps,
        multi: provider.multi
      };
    }

    function _transformProviderAst(provider, _ref12) {
      var eager = _ref12.eager,
          providers = _ref12.providers;
      return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);
    }

    function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
      var providersByToken = new Map();
      directives.forEach(function (directive) {
        var dirProvider = {
          token: {
            identifier: directive.type
          },
          useClass: directive.type
        };

        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken,
        /* isModule */
        false);
      }); // Note: directives need to be able to overwrite providers of a component!

      var directivesWithComponentFirst = directives.filter(function (dir) {
        return dir.isComponent;
      }).concat(directives.filter(function (dir) {
        return !dir.isComponent;
      }));
      directivesWithComponentFirst.forEach(function (directive) {
        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken,
        /* isModule */
        false);

        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken,
        /* isModule */
        false);
      });
      return providersByToken;
    }

    function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken, isModule) {
      providers.forEach(function (provider) {
        var resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));

        if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {
          targetErrors.push(new ProviderError("Mixing multi and non multi provider is not possible for token ".concat(tokenName(resolvedProvider.token)), sourceSpan));
        }

        if (!resolvedProvider) {
          var lifecycleHooks = provider.token.identifier && provider.token.identifier.lifecycleHooks ? provider.token.identifier.lifecycleHooks : [];
          var isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);
          resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan, isModule);
          targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);
        } else {
          if (!provider.multi) {
            resolvedProvider.providers.length = 0;
          }

          resolvedProvider.providers.push(provider);
        }
      });
    }

    function _getViewQueries(component) {
      // Note: queries start with id 1 so we can use the number in a Bloom filter!
      var viewQueryId = 1;
      var viewQueries = new Map();

      if (component.viewQueries) {
        component.viewQueries.forEach(function (query) {
          return _addQueryToTokenMap(viewQueries, {
            meta: query,
            queryId: viewQueryId++
          });
        });
      }

      return viewQueries;
    }

    function _getContentQueries(contentQueryStartId, directives) {
      var contentQueryId = contentQueryStartId;
      var contentQueries = new Map();
      directives.forEach(function (directive, directiveIndex) {
        if (directive.queries) {
          directive.queries.forEach(function (query) {
            return _addQueryToTokenMap(contentQueries, {
              meta: query,
              queryId: contentQueryId++
            });
          });
        }
      });
      return contentQueries;
    }

    function _addQueryToTokenMap(map, query) {
      query.meta.selectors.forEach(function (token) {
        var entry = map.get(tokenReference(token));

        if (!entry) {
          entry = [];
          map.set(tokenReference(token), entry);
        }

        entry.push(query);
      });
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var StyleWithImports = function StyleWithImports(style, styleUrls) {
      _classCallCheck(this, StyleWithImports);

      this.style = style;
      this.styleUrls = styleUrls;
    };

    function isStyleUrlResolvable(url) {
      if (url == null || url.length === 0 || url[0] == '/') return false;
      var schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
      return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
    }
    /**
     * Rewrites stylesheets by resolving and removing the @import urls that
     * are either relative or don't have a `package:` scheme
     */


    function extractStyleUrls(resolver, baseUrl, cssText) {
      var foundUrls = [];
      var modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '').replace(CSS_IMPORT_REGEXP, function () {
        var url = (arguments.length <= 1 ? undefined : arguments[1]) || (arguments.length <= 2 ? undefined : arguments[2]);

        if (!isStyleUrlResolvable(url)) {
          // Do not attempt to resolve non-package absolute URLs with URI
          // scheme
          return arguments.length <= 0 ? undefined : arguments[0];
        }

        foundUrls.push(resolver.resolve(baseUrl, url));
        return '';
      });
      return new StyleWithImports(modifiedCssText, foundUrls);
    }

    var CSS_IMPORT_REGEXP = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
    var CSS_STRIPPABLE_COMMENT_REGEXP = /\/\*(?!#\s*(?:sourceURL|sourceMappingURL)=)[\s\S]+?\*\//g;
    var URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    var PROPERTY_PARTS_SEPARATOR = '.';
    var ATTRIBUTE_PREFIX = 'attr';
    var CLASS_PREFIX = 'class';
    var STYLE_PREFIX = 'style';
    var ANIMATE_PROP_PREFIX = 'animate-';
    /**
     * Parses bindings in templates and in the directive host area.
     */

    var BindingParser =
    /*#__PURE__*/
    function () {
      function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {
        _classCallCheck(this, BindingParser);

        this._exprParser = _exprParser;
        this._interpolationConfig = _interpolationConfig;
        this._schemaRegistry = _schemaRegistry;
        this.errors = errors;
        this.pipesByName = null;
        this._usedPipes = new Map(); // When the `pipes` parameter is `null`, do not check for used pipes
        // This is used in IVY when we might not know the available pipes at compile time

        if (pipes) {
          var pipesByName = new Map();
          pipes.forEach(function (pipe) {
            return pipesByName.set(pipe.name, pipe);
          });
          this.pipesByName = pipesByName;
        }
      }

      _createClass(BindingParser, [{
        key: "getUsedPipes",
        value: function getUsedPipes() {
          return Array.from(this._usedPipes.values());
        }
      }, {
        key: "createBoundHostProperties",
        value: function createBoundHostProperties(dirMeta, sourceSpan) {
          var _this139 = this;

          if (dirMeta.hostProperties) {
            var boundProps = [];
            Object.keys(dirMeta.hostProperties).forEach(function (propName) {
              var expression = dirMeta.hostProperties[propName];

              if (typeof expression === 'string') {
                _this139.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], boundProps);
              } else {
                _this139._reportError("Value of the host property binding \"".concat(propName, "\" needs to be a string representing an expression but got \"").concat(expression, "\" (").concat(typeof expression, ")"), sourceSpan);
              }
            });
            return boundProps;
          }

          return null;
        }
      }, {
        key: "createDirectiveHostPropertyAsts",
        value: function createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {
          var _this140 = this;

          var boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);
          return boundProps && boundProps.map(function (prop) {
            return _this140.createBoundElementProperty(elementSelector, prop);
          });
        }
      }, {
        key: "createDirectiveHostEventAsts",
        value: function createDirectiveHostEventAsts(dirMeta, sourceSpan) {
          var _this141 = this;

          if (dirMeta.hostListeners) {
            var targetEvents = [];
            Object.keys(dirMeta.hostListeners).forEach(function (propName) {
              var expression = dirMeta.hostListeners[propName];

              if (typeof expression === 'string') {
                // TODO: pass a more accurate handlerSpan for this event.
                _this141.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents);
              } else {
                _this141._reportError("Value of the host listener \"".concat(propName, "\" needs to be a string representing an expression but got \"").concat(expression, "\" (").concat(typeof expression, ")"), sourceSpan);
              }
            });
            return targetEvents;
          }

          return null;
        }
      }, {
        key: "parseInterpolation",
        value: function parseInterpolation(value, sourceSpan) {
          var sourceInfo = sourceSpan.start.toString();

          try {
            var ast = this._exprParser.parseInterpolation(value, sourceInfo, sourceSpan.start.offset, this._interpolationConfig);

            if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);

            this._checkPipes(ast, sourceSpan);

            return ast;
          } catch (e) {
            this._reportError("".concat(e), sourceSpan);

            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, sourceSpan.start.offset);
          }
        }
        /**
         * Parses an inline template binding, e.g.
         *    <tag *tplKey="<tplValue>">
         * @param tplKey template binding name
         * @param tplValue template binding value
         * @param sourceSpan span of template binding relative to entire the template
         * @param absoluteValueOffset start of the tplValue relative to the entire template
         * @param targetMatchableAttrs potential attributes to match in the template
         * @param targetProps target property bindings in the template
         * @param targetVars target variables in the template
         */

      }, {
        key: "parseInlineTemplateBinding",
        value: function parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars) {
          var bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteValueOffset);

          for (var i = 0; i < bindings.length; i++) {
            var binding = bindings[i];

            if (binding.keyIsVar) {
              targetVars.push(new ParsedVariable(binding.key, binding.name, sourceSpan));
            } else if (binding.expression) {
              this._parsePropertyAst(binding.key, binding.expression, sourceSpan, undefined, targetMatchableAttrs, targetProps);
            } else {
              targetMatchableAttrs.push([binding.key, '']);
              this.parseLiteralAttr(binding.key, null, sourceSpan, absoluteValueOffset, undefined, targetMatchableAttrs, targetProps);
            }
          }
        }
        /**
         * Parses the bindings in an inline template binding, e.g.
         *    <tag *tplKey="let value1 = prop; let value2 = localVar">
         * @param tplKey template binding name
         * @param tplValue template binding value
         * @param sourceSpan span of template binding relative to entire the template
         * @param absoluteValueOffset start of the tplValue relative to the entire template
         */

      }, {
        key: "_parseTemplateBindings",
        value: function _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteValueOffset) {
          var _this142 = this;

          var sourceInfo = sourceSpan.start.toString();

          try {
            var bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteValueOffset);

            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);

            bindingsResult.templateBindings.forEach(function (binding) {
              if (binding.expression) {
                _this142._checkPipes(binding.expression, sourceSpan);
              }
            });
            bindingsResult.warnings.forEach(function (warning) {
              _this142._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
            });
            return bindingsResult.templateBindings;
          } catch (e) {
            this._reportError("".concat(e), sourceSpan);

            return [];
          }
        }
      }, {
        key: "parseLiteralAttr",
        value: function parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {
          if (isAnimationLabel(name)) {
            name = name.substring(1);

            if (value) {
              this._reportError("Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid." + " Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.", sourceSpan, ParseErrorLevel.ERROR);
            }

            this._parseAnimation(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);
          } else {
            targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, valueSpan));
          }
        }
      }, {
        key: "parsePropertyBinding",
        value: function parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {
          if (name.length === 0) {
            this._reportError("Property name is missing in binding", sourceSpan);
          }

          var isAnimationProp = false;

          if (name.startsWith(ANIMATE_PROP_PREFIX)) {
            isAnimationProp = true;
            name = name.substring(ANIMATE_PROP_PREFIX.length);
          } else if (isAnimationLabel(name)) {
            isAnimationProp = true;
            name = name.substring(1);
          }

          if (isAnimationProp) {
            this._parseAnimation(name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);
          } else {
            this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, valueSpan, targetMatchableAttrs, targetProps);
          }
        }
      }, {
        key: "parsePropertyInterpolation",
        value: function parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {
          var expr = this.parseInterpolation(value, valueSpan || sourceSpan);

          if (expr) {
            this._parsePropertyAst(name, expr, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);

            return true;
          }

          return false;
        }
      }, {
        key: "_parsePropertyAst",
        value: function _parsePropertyAst(name, ast, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {
          targetMatchableAttrs.push([name, ast.source]);
          targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, valueSpan));
        }
      }, {
        key: "_parseAnimation",
        value: function _parseAnimation(name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {
          if (name.length === 0) {
            this._reportError('Animation trigger is missing', sourceSpan);
          } // This will occur when a @trigger is not paired with an expression.
          // For animations it is valid to not have an expression since */void
          // states will be applied by angular when the element is attached/detached


          var ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);

          targetMatchableAttrs.push([name, ast.source]);
          targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, valueSpan));
        }
      }, {
        key: "_parseBinding",
        value: function _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {
          var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();

          try {
            var ast = isHostBinding ? this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) : this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);
            if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);

            this._checkPipes(ast, sourceSpan);

            return ast;
          } catch (e) {
            this._reportError("".concat(e), sourceSpan);

            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
          }
        }
      }, {
        key: "createBoundElementProperty",
        value: function createBoundElementProperty(elementSelector, boundProp) {
          var skipValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var mapPropertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

          if (boundProp.isAnimation) {
            return new BoundElementProperty(boundProp.name, 4
            /* Animation */
            , SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.valueSpan);
          }

          var unit = null;
          var bindingType = undefined;
          var boundPropertyName = null;
          var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
          var securityContexts = undefined; // Check for special cases (prefix style, attr, class)

          if (parts.length > 1) {
            if (parts[0] == ATTRIBUTE_PREFIX) {
              boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);

              if (!skipValidation) {
                this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
              }

              securityContexts = _calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
              var nsSeparatorIdx = boundPropertyName.indexOf(':');

              if (nsSeparatorIdx > -1) {
                var ns = boundPropertyName.substring(0, nsSeparatorIdx);
                var name = boundPropertyName.substring(nsSeparatorIdx + 1);
                boundPropertyName = mergeNsAndName(ns, name);
              }

              bindingType = 1
              /* Attribute */
              ;
            } else if (parts[0] == CLASS_PREFIX) {
              boundPropertyName = parts[1];
              bindingType = 2
              /* Class */
              ;
              securityContexts = [SecurityContext.NONE];
            } else if (parts[0] == STYLE_PREFIX) {
              unit = parts.length > 2 ? parts[2] : null;
              boundPropertyName = parts[1];
              bindingType = 3
              /* Style */
              ;
              securityContexts = [SecurityContext.STYLE];
            }
          } // If not a special case, use the full property name


          if (boundPropertyName === null) {
            var mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);

            boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;
            securityContexts = _calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);
            bindingType = 0
            /* Property */
            ;

            if (!skipValidation) {
              this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);
            }
          }

          return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.valueSpan);
        }
      }, {
        key: "parseEvent",
        value: function parseEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {
          if (name.length === 0) {
            this._reportError("Event name is missing in binding", sourceSpan);
          }

          if (isAnimationLabel(name)) {
            name = name.substr(1);

            this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents);
          } else {
            this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents);
          }
        }
      }, {
        key: "calcPossibleSecurityContexts",
        value: function calcPossibleSecurityContexts(selector, propName, isAttribute) {
          var prop = this._schemaRegistry.getMappedPropName(propName);

          return _calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);
        }
      }, {
        key: "_parseAnimationEvent",
        value: function _parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents) {
          var matches = splitAtPeriod(name, [name, '']);
          var eventName = matches[0];
          var phase = matches[1].toLowerCase();

          if (phase) {
            switch (phase) {
              case 'start':
              case 'done':
                var ast = this._parseAction(expression, handlerSpan);

                targetEvents.push(new ParsedEvent(eventName, phase, 1
                /* Animation */
                , ast, sourceSpan, handlerSpan));
                break;

              default:
                this._reportError("The provided animation output phase value \"".concat(phase, "\" for \"@").concat(eventName, "\" is not supported (use start or done)"), sourceSpan);

                break;
            }
          } else {
            this._reportError("The animation trigger output event (@".concat(eventName, ") is missing its phase value name (start or done are currently supported)"), sourceSpan);
          }
        }
      }, {
        key: "_parseRegularEvent",
        value: function _parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {
          // long format: 'target: eventName'
          var _splitAtColon3 = splitAtColon(name, [null, name]),
              _splitAtColon4 = _slicedToArray(_splitAtColon3, 2),
              target = _splitAtColon4[0],
              eventName = _splitAtColon4[1];

          var ast = this._parseAction(expression, handlerSpan);

          targetMatchableAttrs.push([name, ast.source]);
          targetEvents.push(new ParsedEvent(eventName, target, 0
          /* Regular */
          , ast, sourceSpan, handlerSpan)); // Don't detect directives for event names for now,
          // so don't add the event name to the matchableAttrs
        }
      }, {
        key: "_parseAction",
        value: function _parseAction(value, sourceSpan) {
          var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();
          var absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;

          try {
            var ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);

            if (ast) {
              this._reportExpressionParserErrors(ast.errors, sourceSpan);
            }

            if (!ast || ast.ast instanceof EmptyExpr) {
              this._reportError("Empty expressions are not allowed", sourceSpan);

              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }

            this._checkPipes(ast, sourceSpan);

            return ast;
          } catch (e) {
            this._reportError("".concat(e), sourceSpan);

            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
          }
        }
      }, {
        key: "_reportError",
        value: function _reportError(message, sourceSpan) {
          var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;
          this.errors.push(new ParseError(sourceSpan, message, level));
        }
      }, {
        key: "_reportExpressionParserErrors",
        value: function _reportExpressionParserErrors(errors, sourceSpan) {
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = errors[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var _error = _step6.value;

              this._reportError(_error.message, sourceSpan);
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        } // Make sure all the used pipes are known in `this.pipesByName`

      }, {
        key: "_checkPipes",
        value: function _checkPipes(ast, sourceSpan) {
          var _this143 = this;

          if (ast && this.pipesByName) {
            var collector = new PipeCollector();
            ast.visit(collector);
            collector.pipes.forEach(function (ast, pipeName) {
              var pipeMeta = _this143.pipesByName.get(pipeName);

              if (!pipeMeta) {
                _this143._reportError("The pipe '".concat(pipeName, "' could not be found"), new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));
              } else {
                _this143._usedPipes.set(pipeName, pipeMeta);
              }
            });
          }
        }
        /**
         * @param propName the name of the property / attribute
         * @param sourceSpan
         * @param isAttr true when binding to an attribute
         */

      }, {
        key: "_validatePropertyOrAttributeName",
        value: function _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {
          var report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);

          if (report.error) {
            this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);
          }
        }
      }, {
        key: "interpolationConfig",
        get: function get() {
          return this._interpolationConfig;
        }
      }]);

      return BindingParser;
    }();

    var PipeCollector =
    /*#__PURE__*/
    function (_RecursiveAstVisitor$) {
      _inherits(PipeCollector, _RecursiveAstVisitor$);

      function PipeCollector() {
        var _this144;

        _classCallCheck(this, PipeCollector);

        _this144 = _possibleConstructorReturn(this, _getPrototypeOf(PipeCollector).apply(this, arguments));
        _this144.pipes = new Map();
        return _this144;
      }

      _createClass(PipeCollector, [{
        key: "visitPipe",
        value: function visitPipe(ast, context) {
          this.pipes.set(ast.name, ast);
          ast.exp.visit(this);
          this.visitAll(ast.args, context);
          return null;
        }
      }]);

      return PipeCollector;
    }(RecursiveAstVisitor$1);

    function isAnimationLabel(name) {
      return name[0] == '@';
    }

    function _calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
      var ctxs = [];
      CssSelector.parse(selector).forEach(function (selector) {
        var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();
        var notElementNames = new Set(selector.notSelectors.filter(function (selector) {
          return selector.isElementSelector();
        }).map(function (selector) {
          return selector.element;
        }));
        var possibleElementNames = elementNames.filter(function (elementName) {
          return !notElementNames.has(elementName);
        });
        ctxs.push.apply(ctxs, _toConsumableArray(possibleElementNames.map(function (elementName) {
          return registry.securityContext(elementName, propName, isAttribute);
        })));
      });
      return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var NG_CONTENT_SELECT_ATTR = 'select';
    var LINK_ELEMENT = 'link';
    var LINK_STYLE_REL_ATTR = 'rel';
    var LINK_STYLE_HREF_ATTR = 'href';
    var LINK_STYLE_REL_VALUE = 'stylesheet';
    var STYLE_ELEMENT = 'style';
    var SCRIPT_ELEMENT = 'script';
    var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
    var NG_PROJECT_AS = 'ngProjectAs';

    function preparseElement(ast) {
      var selectAttr = null;
      var hrefAttr = null;
      var relAttr = null;
      var nonBindable = false;
      var projectAs = '';
      ast.attrs.forEach(function (attr) {
        var lcAttrName = attr.name.toLowerCase();

        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
          selectAttr = attr.value;
        } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
          hrefAttr = attr.value;
        } else if (lcAttrName == LINK_STYLE_REL_ATTR) {
          relAttr = attr.value;
        } else if (attr.name == NG_NON_BINDABLE_ATTR) {
          nonBindable = true;
        } else if (attr.name == NG_PROJECT_AS) {
          if (attr.value.length > 0) {
            projectAs = attr.value;
          }
        }
      });
      selectAttr = normalizeNgContentSelect(selectAttr);
      var nodeName = ast.name.toLowerCase();
      var type = PreparsedElementType.OTHER;

      if (isNgContent(nodeName)) {
        type = PreparsedElementType.NG_CONTENT;
      } else if (nodeName == STYLE_ELEMENT) {
        type = PreparsedElementType.STYLE;
      } else if (nodeName == SCRIPT_ELEMENT) {
        type = PreparsedElementType.SCRIPT;
      } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
        type = PreparsedElementType.STYLESHEET;
      }

      return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
    }

    var PreparsedElementType;

    (function (PreparsedElementType) {
      PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
      PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
      PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
      PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
      PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
    })(PreparsedElementType || (PreparsedElementType = {}));

    var PreparsedElement = function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
      _classCallCheck(this, PreparsedElement);

      this.type = type;
      this.selectAttr = selectAttr;
      this.hrefAttr = hrefAttr;
      this.nonBindable = nonBindable;
      this.projectAs = projectAs;
    };

    function normalizeNgContentSelect(selectAttr) {
      if (selectAttr === null || selectAttr.length === 0) {
        return '*';
      }

      return selectAttr;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/; // Group 1 = "bind-"

    var KW_BIND_IDX = 1; // Group 2 = "let-"

    var KW_LET_IDX = 2; // Group 3 = "ref-/#"

    var KW_REF_IDX = 3; // Group 4 = "on-"

    var KW_ON_IDX = 4; // Group 5 = "bindon-"

    var KW_BINDON_IDX = 5; // Group 6 = "@"

    var KW_AT_IDX = 6; // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"

    var IDENT_KW_IDX = 7; // Group 8 = identifier inside [()]

    var IDENT_BANANA_BOX_IDX = 8; // Group 9 = identifier inside []

    var IDENT_PROPERTY_IDX = 9; // Group 10 = identifier inside ()

    var IDENT_EVENT_IDX = 10;
    var TEMPLATE_ATTR_PREFIX = '*';
    var CLASS_ATTR = 'class';

    var _TEXT_CSS_SELECTOR;

    function TEXT_CSS_SELECTOR() {
      if (!_TEXT_CSS_SELECTOR) {
        _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
      }

      return _TEXT_CSS_SELECTOR;
    }

    var TemplateParseError =
    /*#__PURE__*/
    function (_ParseError5) {
      _inherits(TemplateParseError, _ParseError5);

      function TemplateParseError(message, span, level) {
        _classCallCheck(this, TemplateParseError);

        return _possibleConstructorReturn(this, _getPrototypeOf(TemplateParseError).call(this, span, message, level));
      }

      return TemplateParseError;
    }(ParseError);

    var TemplateParseResult = function TemplateParseResult(templateAst, usedPipes, errors) {
      _classCallCheck(this, TemplateParseResult);

      this.templateAst = templateAst;
      this.usedPipes = usedPipes;
      this.errors = errors;
    };

    var TemplateParser =
    /*#__PURE__*/
    function () {
      function TemplateParser(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
        _classCallCheck(this, TemplateParser);

        this._config = _config;
        this._reflector = _reflector;
        this._exprParser = _exprParser;
        this._schemaRegistry = _schemaRegistry;
        this._htmlParser = _htmlParser;
        this._console = _console;
        this.transforms = transforms;
      }

      _createClass(TemplateParser, [{
        key: "parse",
        value: function parse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {
          var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);
          var warnings = result.errors.filter(function (error) {
            return error.level === ParseErrorLevel.WARNING;
          });
          var errors = result.errors.filter(function (error) {
            return error.level === ParseErrorLevel.ERROR;
          });

          if (warnings.length > 0) {
            this._console.warn("Template parse warnings:\n".concat(warnings.join('\n')));
          }

          if (errors.length > 0) {
            var errorString = errors.join('\n');
            throw syntaxError("Template parse errors:\n".concat(errorString), errors);
          }

          return {
            template: result.templateAst,
            pipes: result.usedPipes
          };
        }
      }, {
        key: "tryParse",
        value: function tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {
          var htmlParseResult = typeof template === 'string' ? this._htmlParser.parse(template, templateUrl, {
            tokenizeExpansionForms: true,
            interpolationConfig: this.getInterpolationConfig(component)
          }) : template;

          if (!preserveWhitespaces) {
            htmlParseResult = removeWhitespaces(htmlParseResult);
          }

          return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);
        }
      }, {
        key: "tryParseHtml",
        value: function tryParseHtml(htmlAstWithErrors, component, directives, pipes, schemas) {
          var result;
          var errors = htmlAstWithErrors.errors;
          var usedPipes = [];

          if (htmlAstWithErrors.rootNodes.length > 0) {
            var uniqDirectives = removeSummaryDuplicates(directives);
            var uniqPipes = removeSummaryDuplicates(pipes);
            var providerViewContext = new ProviderViewContext(this._reflector, component);
            var interpolationConfig = undefined;

            if (component.template && component.template.interpolation) {
              interpolationConfig = {
                start: component.template.interpolation[0],
                end: component.template.interpolation[1]
              };
            }

            var bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);
            var parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);
            result = visitAll$1(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
            errors.push.apply(errors, _toConsumableArray(providerViewContext.errors));
            usedPipes.push.apply(usedPipes, _toConsumableArray(bindingParser.getUsedPipes()));
          } else {
            result = [];
          }

          this._assertNoReferenceDuplicationOnTemplate(result, errors);

          if (errors.length > 0) {
            return new TemplateParseResult(result, usedPipes, errors);
          }

          if (this.transforms) {
            this.transforms.forEach(function (transform) {
              result = templateVisitAll(transform, result);
            });
          }

          return new TemplateParseResult(result, usedPipes, errors);
        }
      }, {
        key: "expandHtml",
        value: function expandHtml(htmlAstWithErrors) {
          var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var errors = htmlAstWithErrors.errors;

          if (errors.length == 0 || forced) {
            // Transform ICU messages to angular directives
            var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);
            errors.push.apply(errors, _toConsumableArray(expandedHtmlAst.errors));
            htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);
          }

          return htmlAstWithErrors;
        }
      }, {
        key: "getInterpolationConfig",
        value: function getInterpolationConfig(component) {
          if (component.template) {
            return InterpolationConfig.fromArray(component.template.interpolation);
          }

          return undefined;
        }
        /** @internal */

      }, {
        key: "_assertNoReferenceDuplicationOnTemplate",
        value: function _assertNoReferenceDuplicationOnTemplate(result, errors) {
          var existingReferences = [];
          result.filter(function (element) {
            return !!element.references;
          }).forEach(function (element) {
            return element.references.forEach(function (reference) {
              var name = reference.name;

              if (existingReferences.indexOf(name) < 0) {
                existingReferences.push(name);
              } else {
                var _error2 = new TemplateParseError("Reference \"#".concat(name, "\" is defined several times"), reference.sourceSpan, ParseErrorLevel.ERROR);

                errors.push(_error2);
              }
            });
          });
        }
      }, {
        key: "expressionParser",
        get: function get() {
          return this._exprParser;
        }
      }]);

      return TemplateParser;
    }();

    var TemplateParseVisitor =
    /*#__PURE__*/
    function () {
      function TemplateParseVisitor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {
        var _this145 = this;

        _classCallCheck(this, TemplateParseVisitor);

        this.reflector = reflector;
        this.config = config;
        this.providerViewContext = providerViewContext;
        this._bindingParser = _bindingParser;
        this._schemaRegistry = _schemaRegistry;
        this._schemas = _schemas;
        this._targetErrors = _targetErrors;
        this.selectorMatcher = new SelectorMatcher();
        this.directivesIndex = new Map();
        this.ngContentCount = 0; // Note: queries start with id 1 so we can use the number in a Bloom filter!

        this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;
        directives.forEach(function (directive, index) {
          var selector = CssSelector.parse(directive.selector);

          _this145.selectorMatcher.addSelectables(selector, directive);

          _this145.directivesIndex.set(directive, index);
        });
      }

      _createClass(TemplateParseVisitor, [{
        key: "visitExpansion",
        value: function visitExpansion(expansion, context) {
          return null;
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(expansionCase, context) {
          return null;
        }
      }, {
        key: "visitText",
        value: function visitText(text, parent) {
          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());
          var valueNoNgsp = replaceNgsp(text.value);

          var expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);

          return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) : new TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {
          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {
          return null;
        }
      }, {
        key: "visitElement",
        value: function visitElement(element, parent) {
          var _this146 = this;

          var queryStartIndex = this.contentQueryStartId;
          var elName = element.name;
          var preparsedElement = preparseElement(element);

          if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE) {
            // Skipping <script> for security reasons
            // Skipping <style> as we already processed them
            // in the StyleCompiler
            return null;
          }

          if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {
            // Skipping stylesheets with either relative urls or package scheme as we already processed
            // them in the StyleCompiler
            return null;
          }

          var matchableAttrs = [];
          var elementOrDirectiveProps = [];
          var elementOrDirectiveRefs = [];
          var elementVars = [];
          var events = [];
          var templateElementOrDirectiveProps = [];
          var templateMatchableAttrs = [];
          var templateElementVars = [];
          var hasInlineTemplates = false;
          var attrs = [];
          var isTemplateElement = isNgTemplate(element.name);
          element.attrs.forEach(function (attr) {
            var parsedVariables = [];

            var hasBinding = _this146._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);

            elementVars.push.apply(elementVars, _toConsumableArray(parsedVariables.map(function (v) {
              return VariableAst.fromParsedVariable(v);
            })));
            var templateValue;
            var templateKey;

            var normalizedName = _this146._normalizeAttributeName(attr.name);

            if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {
              templateValue = attr.value;
              templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);
            }

            var hasTemplateBinding = templateValue != null;

            if (hasTemplateBinding) {
              if (hasInlineTemplates) {
                _this146._reportError("Can't have multiple template bindings on one element. Use only one attribute prefixed with *", attr.sourceSpan);
              }

              hasInlineTemplates = true;
              var _parsedVariables = [];
              var absoluteOffset = (attr.valueSpan || attr.sourceSpan).start.offset;

              _this146._bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attr.sourceSpan, absoluteOffset, templateMatchableAttrs, templateElementOrDirectiveProps, _parsedVariables);

              templateElementVars.push.apply(templateElementVars, _toConsumableArray(_parsedVariables.map(function (v) {
                return VariableAst.fromParsedVariable(v);
              })));
            }

            if (!hasBinding && !hasTemplateBinding) {
              // don't include the bindings as attributes as well in the AST
              attrs.push(_this146.visitAttribute(attr, null));
              matchableAttrs.push([attr.name, attr.value]);
            }
          });
          var elementCssSelector = createElementCssSelector(elName, matchableAttrs);

          var _this$_parseDirective = this._parseDirectives(this.selectorMatcher, elementCssSelector),
              directiveMetas = _this$_parseDirective.directives,
              matchElement = _this$_parseDirective.matchElement;

          var references = [];
          var boundDirectivePropNames = new Set();

          var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);

          var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);

          var isViewRoot = parent.isTemplateElement || hasInlineTemplates;
          var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);
          var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
          providerContext.afterElement(); // Override the actual selector when the `ngProjectAs` attribute is provided

          var projectionSelector = preparsedElement.projectAs != '' ? CssSelector.parse(preparsedElement.projectAs)[0] : elementCssSelector;
          var ngContentIndex = parent.findNgContentIndex(projectionSelector);
          var parsedElement;

          if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
            // `<ng-content>` element
            if (element.children && !element.children.every(_isEmptyTextNode)) {
              this._reportError("<ng-content> element cannot have content.", element.sourceSpan);
            }

            parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
          } else if (isTemplateElement) {
            // `<ng-template>` element
            this._assertAllEventsPublishedByDirectives(directiveAsts, events);

            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);

            parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
          } else {
            // element other than `<ng-content>` and `<ng-template>`
            this._assertElementExists(matchElement, element);

            this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);

            var _ngContentIndex = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);

            parsedElement = new ElementAst(elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : _ngContentIndex, element.sourceSpan, element.endSourceSpan || null);
          }

          if (hasInlineTemplates) {
            // The element as a *-attribute
            var templateQueryStartIndex = this.contentQueryStartId;
            var templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);

            var _this$_parseDirective2 = this._parseDirectives(this.selectorMatcher, templateSelector),
                directives = _this$_parseDirective2.directives;

            var templateBoundDirectivePropNames = new Set();

            var templateDirectiveAsts = this._createDirectiveAsts(true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);

            var templateElementProps = this._createElementPropertyAsts(elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);

            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);

            var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);
            templateProviderContext.afterElement();
            parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);
          }

          return parsedElement;
        }
      }, {
        key: "_parseAttr",
        value: function _parseAttr(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {
          var name = this._normalizeAttributeName(attr.name);

          var value = attr.value;
          var srcSpan = attr.sourceSpan;
          var absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;
          var boundEvents = [];
          var bindParts = name.match(BIND_NAME_REGEXP);
          var hasBinding = false;

          if (bindParts !== null) {
            hasBinding = true;

            if (bindParts[KW_BIND_IDX] != null) {
              this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
            } else if (bindParts[KW_LET_IDX]) {
              if (isTemplateElement) {
                var identifier = bindParts[IDENT_KW_IDX];

                this._parseVariable(identifier, value, srcSpan, targetVars);
              } else {
                this._reportError("\"let-\" is only supported on ng-template elements.", srcSpan);
              }
            } else if (bindParts[KW_REF_IDX]) {
              var _identifier = bindParts[IDENT_KW_IDX];

              this._parseReference(_identifier, value, srcSpan, targetRefs);
            } else if (bindParts[KW_ON_IDX]) {
              this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);
            } else if (bindParts[KW_BINDON_IDX]) {
              this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);

              this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);
            } else if (bindParts[KW_AT_IDX]) {
              this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
            } else if (bindParts[IDENT_BANANA_BOX_IDX]) {
              this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);

              this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);
            } else if (bindParts[IDENT_PROPERTY_IDX]) {
              this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
            } else if (bindParts[IDENT_EVENT_IDX]) {
              this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);
            }
          } else {
            hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);
          }

          if (!hasBinding) {
            this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
          }

          targetEvents.push.apply(targetEvents, _toConsumableArray(boundEvents.map(function (e) {
            return BoundEventAst.fromParsedEvent(e);
          })));
          return hasBinding;
        }
      }, {
        key: "_normalizeAttributeName",
        value: function _normalizeAttributeName(attrName) {
          return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
        }
      }, {
        key: "_parseVariable",
        value: function _parseVariable(identifier, value, sourceSpan, targetVars) {
          if (identifier.indexOf('-') > -1) {
            this._reportError("\"-\" is not allowed in variable names", sourceSpan);
          } else if (identifier.length === 0) {
            this._reportError("Variable does not have a name", sourceSpan);
          }

          targetVars.push(new VariableAst(identifier, value, sourceSpan));
        }
      }, {
        key: "_parseReference",
        value: function _parseReference(identifier, value, sourceSpan, targetRefs) {
          if (identifier.indexOf('-') > -1) {
            this._reportError("\"-\" is not allowed in reference names", sourceSpan);
          } else if (identifier.length === 0) {
            this._reportError("Reference does not have a name", sourceSpan);
          }

          targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
        }
      }, {
        key: "_parseAssignmentEvent",
        value: function _parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents) {
          this._bindingParser.parseEvent("".concat(name, "Change"), "".concat(expression, "=$event"), sourceSpan, valueSpan, targetMatchableAttrs, targetEvents);
        }
      }, {
        key: "_parseDirectives",
        value: function _parseDirectives(selectorMatcher, elementCssSelector) {
          var _this147 = this;

          // Need to sort the directives so that we get consistent results throughout,
          // as selectorMatcher uses Maps inside.
          // Also deduplicate directives as they might match more than one time!
          var directives = newArray(this.directivesIndex.size); // Whether any directive selector matches on the element name

          var matchElement = false;
          selectorMatcher.match(elementCssSelector, function (selector, directive) {
            directives[_this147.directivesIndex.get(directive)] = directive;
            matchElement = matchElement || selector.hasElementSelector();
          });
          return {
            directives: directives.filter(function (dir) {
              return !!dir;
            }),
            matchElement: matchElement
          };
        }
      }, {
        key: "_createDirectiveAsts",
        value: function _createDirectiveAsts(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {
          var _this148 = this;

          var matchedReferences = new Set();
          var component = null;
          var directiveAsts = directives.map(function (directive) {
            var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, "Directive ".concat(identifierName(directive.type)));

            if (directive.isComponent) {
              component = directive;
            }

            var directiveProperties = [];

            var boundProperties = _this148._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);

            var hostProperties = boundProperties.map(function (prop) {
              return BoundElementPropertyAst.fromBoundProperty(prop);
            }); // Note: We need to check the host properties here as well,
            // as we don't know the element name in the DirectiveWrapperCompiler yet.

            hostProperties = _this148._checkPropertiesInSchema(elementName, hostProperties);

            var parsedEvents = _this148._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);

            _this148._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);

            elementOrDirectiveRefs.forEach(function (elOrDirRef) {
              if (elOrDirRef.value.length === 0 && directive.isComponent || elOrDirRef.isReferenceToDirective(directive)) {
                targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value, elOrDirRef.sourceSpan));
                matchedReferences.add(elOrDirRef.name);
              }
            });
            var hostEvents = parsedEvents.map(function (e) {
              return BoundEventAst.fromParsedEvent(e);
            });
            var contentQueryStartId = _this148.contentQueryStartId;
            _this148.contentQueryStartId += directive.queries.length;
            return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);
          });
          elementOrDirectiveRefs.forEach(function (elOrDirRef) {
            if (elOrDirRef.value.length > 0) {
              if (!matchedReferences.has(elOrDirRef.name)) {
                _this148._reportError("There is no directive with \"exportAs\" set to \"".concat(elOrDirRef.value, "\""), elOrDirRef.sourceSpan);
              }
            } else if (!component) {
              var refToken = null;

              if (isTemplateElement) {
                refToken = createTokenForExternalReference(_this148.reflector, Identifiers.TemplateRef);
              }

              targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));
            }
          });
          return directiveAsts;
        }
      }, {
        key: "_createDirectivePropertyAsts",
        value: function _createDirectivePropertyAsts(directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {
          if (directiveProperties) {
            var boundPropsByName = new Map();
            boundProps.forEach(function (boundProp) {
              var prevValue = boundPropsByName.get(boundProp.name);

              if (!prevValue || prevValue.isLiteral) {
                // give [a]="b" a higher precedence than a="b" on the same element
                boundPropsByName.set(boundProp.name, boundProp);
              }
            });
            Object.keys(directiveProperties).forEach(function (dirProp) {
              var elProp = directiveProperties[dirProp];
              var boundProp = boundPropsByName.get(elProp); // Bindings are optional, so this binding only needs to be set up if an expression is given.

              if (boundProp) {
                targetBoundDirectivePropNames.add(boundProp.name);

                if (!isEmptyExpression(boundProp.expression)) {
                  targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
                }
              }
            });
          }
        }
      }, {
        key: "_createElementPropertyAsts",
        value: function _createElementPropertyAsts(elementName, props, boundDirectivePropNames) {
          var _this149 = this;

          var boundElementProps = [];
          props.forEach(function (prop) {
            if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {
              var boundProp = _this149._bindingParser.createBoundElementProperty(elementName, prop);

              boundElementProps.push(BoundElementPropertyAst.fromBoundProperty(boundProp));
            }
          });
          return this._checkPropertiesInSchema(elementName, boundElementProps);
        }
      }, {
        key: "_findComponentDirectives",
        value: function _findComponentDirectives(directives) {
          return directives.filter(function (directive) {
            return directive.directive.isComponent;
          });
        }
      }, {
        key: "_findComponentDirectiveNames",
        value: function _findComponentDirectiveNames(directives) {
          return this._findComponentDirectives(directives).map(function (directive) {
            return identifierName(directive.directive.type);
          });
        }
      }, {
        key: "_assertOnlyOneComponent",
        value: function _assertOnlyOneComponent(directives, sourceSpan) {
          var componentTypeNames = this._findComponentDirectiveNames(directives);

          if (componentTypeNames.length > 1) {
            this._reportError("More than one component matched on this element.\n" + "Make sure that only one component's selector can match a given element.\n" + "Conflicting components: ".concat(componentTypeNames.join(',')), sourceSpan);
          }
        }
        /**
         * Make sure that non-angular tags conform to the schemas.
         *
         * Note: An element is considered an angular tag when at least one directive selector matches the
         * tag name.
         *
         * @param matchElement Whether any directive has matched on the tag name
         * @param element the html element
         */

      }, {
        key: "_assertElementExists",
        value: function _assertElementExists(matchElement, element) {
          var elName = element.name.replace(/^:xhtml:/, '');

          if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {
            var errorMsg = "'".concat(elName, "' is not a known element:\n");
            errorMsg += "1. If '".concat(elName, "' is an Angular component, then verify that it is part of this module.\n");

            if (elName.indexOf('-') > -1) {
              errorMsg += "2. If '".concat(elName, "' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.");
            } else {
              errorMsg += "2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.";
            }

            this._reportError(errorMsg, element.sourceSpan);
          }
        }
      }, {
        key: "_assertNoComponentsNorElementBindingsOnTemplate",
        value: function _assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, sourceSpan) {
          var _this150 = this;

          var componentTypeNames = this._findComponentDirectiveNames(directives);

          if (componentTypeNames.length > 0) {
            this._reportError("Components on an embedded template: ".concat(componentTypeNames.join(',')), sourceSpan);
          }

          elementProps.forEach(function (prop) {
            _this150._reportError("Property binding ".concat(prop.name, " not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\"."), sourceSpan);
          });
        }
      }, {
        key: "_assertAllEventsPublishedByDirectives",
        value: function _assertAllEventsPublishedByDirectives(directives, events) {
          var _this151 = this;

          var allDirectiveEvents = new Set();
          directives.forEach(function (directive) {
            Object.keys(directive.directive.outputs).forEach(function (k) {
              var eventName = directive.directive.outputs[k];
              allDirectiveEvents.add(eventName);
            });
          });
          events.forEach(function (event) {
            if (event.target != null || !allDirectiveEvents.has(event.name)) {
              _this151._reportError("Event binding ".concat(event.fullName, " not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"@NgModule.declarations\"."), event.sourceSpan);
            }
          });
        }
      }, {
        key: "_checkPropertiesInSchema",
        value: function _checkPropertiesInSchema(elementName, boundProps) {
          var _this152 = this;

          // Note: We can't filter out empty expressions before this method,
          // as we still want to validate them!
          return boundProps.filter(function (boundProp) {
            if (boundProp.type === 0
            /* Property */
            && !_this152._schemaRegistry.hasProperty(elementName, boundProp.name, _this152._schemas)) {
              var errorMsg = "Can't bind to '".concat(boundProp.name, "' since it isn't a known property of '").concat(elementName, "'.");

              if (elementName.startsWith('ng-')) {
                errorMsg += "\n1. If '".concat(boundProp.name, "' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.") + "\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.";
              } else if (elementName.indexOf('-') > -1) {
                errorMsg += "\n1. If '".concat(elementName, "' is an Angular component and it has '").concat(boundProp.name, "' input, then verify that it is part of this module.") + "\n2. If '".concat(elementName, "' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.") + "\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.";
              }

              _this152._reportError(errorMsg, boundProp.sourceSpan);
            }

            return !isEmptyExpression(boundProp.value);
          });
        }
      }, {
        key: "_reportError",
        value: function _reportError(message, sourceSpan) {
          var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;

          this._targetErrors.push(new ParseError(sourceSpan, message, level));
        }
      }]);

      return TemplateParseVisitor;
    }();

    var NonBindableVisitor =
    /*#__PURE__*/
    function () {
      function NonBindableVisitor() {
        _classCallCheck(this, NonBindableVisitor);
      }

      _createClass(NonBindableVisitor, [{
        key: "visitElement",
        value: function visitElement(ast, parent) {
          var preparsedElement = preparseElement(ast);

          if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
            // Skipping <script> for security reasons
            // Skipping <style> and stylesheets as we already processed them
            // in the StyleCompiler
            return null;
          }

          var attrNameAndValues = ast.attrs.map(function (attr) {
            return [attr.name, attr.value];
          });
          var selector = createElementCssSelector(ast.name, attrNameAndValues);
          var ngContentIndex = parent.findNgContentIndex(selector);
          var children = visitAll$1(this, ast.children, EMPTY_ELEMENT_CONTEXT);
          return new ElementAst(ast.name, visitAll$1(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {
          return null;
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {
          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
        }
      }, {
        key: "visitText",
        value: function visitText(text, parent) {
          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());
          return new TextAst(text.value, ngContentIndex, text.sourceSpan);
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(expansion, context) {
          return expansion;
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(expansionCase, context) {
          return expansionCase;
        }
      }]);

      return NonBindableVisitor;
    }();
    /**
     * A reference to an element or directive in a template. E.g., the reference in this template:
     *
     * <div #myMenu="coolMenu">
     *
     * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}
     */


    var ElementOrDirectiveRef =
    /*#__PURE__*/
    function () {
      function ElementOrDirectiveRef(name, value, sourceSpan) {
        _classCallCheck(this, ElementOrDirectiveRef);

        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
      }
      /** Gets whether this is a reference to the given directive. */


      _createClass(ElementOrDirectiveRef, [{
        key: "isReferenceToDirective",
        value: function isReferenceToDirective(directive) {
          return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;
        }
      }]);

      return ElementOrDirectiveRef;
    }();
    /** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */


    function splitExportAs(exportAs) {
      return exportAs ? exportAs.split(',').map(function (e) {
        return e.trim();
      }) : [];
    }

    function splitClasses(classAttrValue) {
      return classAttrValue.trim().split(/\s+/g);
    }

    var ElementContext =
    /*#__PURE__*/
    function () {
      function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
        _classCallCheck(this, ElementContext);

        this.isTemplateElement = isTemplateElement;
        this._ngContentIndexMatcher = _ngContentIndexMatcher;
        this._wildcardNgContentIndex = _wildcardNgContentIndex;
        this.providerContext = providerContext;
      }

      _createClass(ElementContext, [{
        key: "findNgContentIndex",
        value: function findNgContentIndex(selector) {
          var ngContentIndices = [];

          this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) {
            ngContentIndices.push(ngContentIndex);
          });

          ngContentIndices.sort();

          if (this._wildcardNgContentIndex != null) {
            ngContentIndices.push(this._wildcardNgContentIndex);
          }

          return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
        }
      }], [{
        key: "create",
        value: function create(isTemplateElement, directives, providerContext) {
          var matcher = new SelectorMatcher();
          var wildcardNgContentIndex = null;
          var component = directives.find(function (directive) {
            return directive.directive.isComponent;
          });

          if (component) {
            var ngContentSelectors = component.directive.template.ngContentSelectors;

            for (var i = 0; i < ngContentSelectors.length; i++) {
              var selector = ngContentSelectors[i];

              if (selector === '*') {
                wildcardNgContentIndex = i;
              } else {
                matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
              }
            }
          }

          return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
        }
      }]);

      return ElementContext;
    }();

    function createElementCssSelector(elementName, attributes) {
      var cssSelector = new CssSelector();
      var elNameNoNs = splitNsName(elementName)[1];
      cssSelector.setElement(elNameNoNs);

      for (var i = 0; i < attributes.length; i++) {
        var attrName = attributes[i][0];
        var attrNameNoNs = splitNsName(attrName)[1];
        var attrValue = attributes[i][1];
        cssSelector.addAttribute(attrNameNoNs, attrValue);

        if (attrName.toLowerCase() == CLASS_ATTR) {
          var classes = splitClasses(attrValue);
          classes.forEach(function (className) {
            return cssSelector.addClassName(className);
          });
        }
      }

      return cssSelector;
    }

    var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
    var NON_BINDABLE_VISITOR = new NonBindableVisitor();

    function _isEmptyTextNode(node) {
      return node instanceof Text$3 && node.value.trim().length == 0;
    }

    function removeSummaryDuplicates(items) {
      var map = new Map();
      items.forEach(function (item) {
        if (!map.get(item.type.reference)) {
          map.set(item.type.reference, item);
        }
      });
      return Array.from(map.values());
    }

    function isEmptyExpression(ast) {
      if (ast instanceof ASTWithSource) {
        ast = ast.ast;
      }

      return ast instanceof EmptyExpr;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Parses string representation of a style and converts it into object literal.
     *
     * @param value string representation of style as used in the `style` attribute in HTML.
     *   Example: `color: red; height: auto`.
     * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',
     * 'auto']`
     */


    function parse(value) {
      // we use a string array here instead of a string map
      // because a string-map is not guaranteed to retain the
      // order of the entries whereas a string array can be
      // constructed in a [key, value, key, value] format.
      var styles = [];
      var i = 0;
      var parenDepth = 0;
      var quote = 0
      /* QuoteNone */
      ;
      var valueStart = 0;
      var propStart = 0;
      var currentProp = null;
      var valueHasQuotes = false;

      while (i < value.length) {
        var token = value.charCodeAt(i++);

        switch (token) {
          case 40
          /* OpenParen */
          :
            parenDepth++;
            break;

          case 41
          /* CloseParen */
          :
            parenDepth--;
            break;

          case 39
          /* QuoteSingle */
          :
            // valueStart needs to be there since prop values don't
            // have quotes in CSS
            valueHasQuotes = valueHasQuotes || valueStart > 0;

            if (quote === 0
            /* QuoteNone */
            ) {
                quote = 39
                /* QuoteSingle */
                ;
              } else if (quote === 39
            /* QuoteSingle */
            && value.charCodeAt(i - 1) !== 92
            /* BackSlash */
            ) {
                quote = 0
                /* QuoteNone */
                ;
              }

            break;

          case 34
          /* QuoteDouble */
          :
            // same logic as above
            valueHasQuotes = valueHasQuotes || valueStart > 0;

            if (quote === 0
            /* QuoteNone */
            ) {
                quote = 34
                /* QuoteDouble */
                ;
              } else if (quote === 34
            /* QuoteDouble */
            && value.charCodeAt(i - 1) !== 92
            /* BackSlash */
            ) {
                quote = 0
                /* QuoteNone */
                ;
              }

            break;

          case 58
          /* Colon */
          :
            if (!currentProp && parenDepth === 0 && quote === 0
            /* QuoteNone */
            ) {
                currentProp = hyphenate(value.substring(propStart, i - 1).trim());
                valueStart = i;
              }

            break;

          case 59
          /* Semicolon */
          :
            if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0
            /* QuoteNone */
            ) {
                var styleVal = value.substring(valueStart, i - 1).trim();
                styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
                propStart = i;
                valueStart = 0;
                currentProp = null;
                valueHasQuotes = false;
              }

            break;
        }
      }

      if (currentProp && valueStart) {
        var _styleVal = value.substr(valueStart).trim();

        styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(_styleVal) : _styleVal);
      }

      return styles;
    }

    function stripUnnecessaryQuotes(value) {
      var qS = value.charCodeAt(0);
      var qE = value.charCodeAt(value.length - 1);

      if (qS == qE && (qS == 39
      /* QuoteSingle */
      || qS == 34
      /* QuoteDouble */
      )) {
        var tempValue = value.substring(1, value.length - 1); // special case to avoid using a multi-quoted string that was just chomped
        // (e.g. `font-family: "Verdana", "sans-serif"`)

        if (tempValue.indexOf('\'') == -1 && tempValue.indexOf('"') == -1) {
          value = tempValue;
        }
      }

      return value;
    }

    function hyphenate(value) {
      return value.replace(/[a-z][A-Z]/g, function (v) {
        return v.charAt(0) + '-' + v.charAt(1);
      }).toLowerCase();
    }

    var IMPORTANT_FLAG = '!important';
    /**
     * Minimum amount of binding slots required in the runtime for style/class bindings.
     *
     * Styling in Angular uses up two slots in the runtime LView/TData data structures to
     * record binding data, property information and metadata.
     *
     * When a binding is registered it will place the following information in the `LView`:
     *
     * slot 1) binding value
     * slot 2) cached value (all other values collected before it in string form)
     *
     * When a binding is registered it will place the following information in the `TData`:
     *
     * slot 1) prop name
     * slot 2) binding index that points to the previous style/class binding (and some extra config
     * values)
     *
     * Let's imagine we have a binding that looks like so:
     *
     * ```
     * <div [style.width]="x" [style.height]="y">
     * ```
     *
     * Our `LView` and `TData` data-structures look like so:
     *
     * ```typescript
     * LView = [
     *   // ...
     *   x, // value of x
     *   "width: x",
     *
     *   y, // value of y
     *   "width: x; height: y",
     *   // ...
     * ];
     *
     * TData = [
     *   // ...
     *   "width", // binding slot 20
     *   0,
     *
     *   "height",
     *   20,
     *   // ...
     * ];
     * ```
     *
     * */

    var MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;
    /**
     * Produces creation/update instructions for all styling bindings (class and style)
     *
     * It also produces the creation instruction to register all initial styling values
     * (which are all the static class="..." and style="..." attribute values that exist
     * on an element within a template).
     *
     * The builder class below handles producing instructions for the following cases:
     *
     * - Static style/class attributes (style="..." and class="...")
     * - Dynamic style/class map bindings ([style]="map" and [class]="map|string")
     * - Dynamic style/class property bindings ([style.prop]="exp" and [class.name]="exp")
     *
     * Due to the complex relationship of all of these cases, the instructions generated
     * for these attributes/properties/bindings must be done so in the correct order. The
     * order which these must be generated is as follows:
     *
     * if (createMode) {
     *   styling(...)
     * }
     * if (updateMode) {
     *   styleMap(...)
     *   classMap(...)
     *   styleProp(...)
     *   classProp(...)
     * }
     *
     * The creation/update methods within the builder class produce these instructions.
     */

    var StylingBuilder =
    /*#__PURE__*/
    function () {
      function StylingBuilder(_directiveExpr) {
        _classCallCheck(this, StylingBuilder);

        this._directiveExpr = _directiveExpr;
        /** Whether or not there are any static styling values present */

        this._hasInitialValues = false;
        /**
         *  Whether or not there are any styling bindings present
         *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)
         */

        this.hasBindings = false;
        this.hasBindingsWithPipes = false;
        /** the input for [class] (if it exists) */

        this._classMapInput = null;
        /** the input for [style] (if it exists) */

        this._styleMapInput = null;
        /** an array of each [style.prop] input */

        this._singleStyleInputs = null;
        /** an array of each [class.name] input */

        this._singleClassInputs = null;
        this._lastStylingInput = null;
        this._firstStylingInput = null; // maps are used instead of hash maps because a Map will
        // retain the ordering of the keys

        /**
         * Represents the location of each style binding in the template
         * (e.g. `<div [style.width]="w" [style.height]="h">` implies
         * that `width=0` and `height=1`)
         */

        this._stylesIndex = new Map();
        /**
         * Represents the location of each class binding in the template
         * (e.g. `<div [class.big]="b" [class.hidden]="h">` implies
         * that `big=0` and `hidden=1`)
         */

        this._classesIndex = new Map();
        this._initialStyleValues = [];
        this._initialClassValues = [];
      }
      /**
       * Registers a given input to the styling builder to be later used when producing AOT code.
       *
       * The code below will only accept the input if it is somehow tied to styling (whether it be
       * style/class bindings or static style/class attributes).
       */


      _createClass(StylingBuilder, [{
        key: "registerBoundInput",
        value: function registerBoundInput(input) {
          // [attr.style] or [attr.class] are skipped in the code below,
          // they should not be treated as styling-based bindings since
          // they are intended to be written directly to the attr and
          // will therefore skip all style/class resolution that is present
          // with style="", [style]="" and [style.prop]="", class="",
          // [class.prop]="". [class]="" assignments
          var binding = null;
          var name = input.name;

          switch (input.type) {
            case 0
            /* Property */
            :
              binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);
              break;

            case 3
            /* Style */
            :
              binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);
              break;

            case 2
            /* Class */
            :
              binding = this.registerClassInput(name, false, input.value, input.sourceSpan);
              break;
          }

          return binding ? true : false;
        }
      }, {
        key: "registerInputBasedOnName",
        value: function registerInputBasedOnName(name, expression, sourceSpan) {
          var binding = null;
          var prefix = name.substring(0, 6);
          var isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';
          var isClass = !isStyle && (name === 'class' || name === 'className' || prefix === 'class.' || prefix === 'class!');

          if (isStyle || isClass) {
            var isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no

            var property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1

            if (isStyle) {
              binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);
            } else {
              binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);
            }
          }

          return binding;
        }
      }, {
        key: "registerStyleInput",
        value: function registerStyleInput(name, isMapBased, value, sourceSpan, unit) {
          if (isEmptyExpression(value)) {
            return null;
          }

          name = normalizePropName(name);

          var _parseProperty = parseProperty(name),
              property = _parseProperty.property,
              hasOverrideFlag = _parseProperty.hasOverrideFlag,
              bindingUnit = _parseProperty.unit;

          var entry = {
            name: property,
            sanitize: property ? isStyleSanitizable(property) : true,
            unit: unit || bindingUnit,
            value: value,
            sourceSpan: sourceSpan,
            hasOverrideFlag: hasOverrideFlag
          };

          if (isMapBased) {
            this._styleMapInput = entry;
          } else {
            (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);
            registerIntoMap(this._stylesIndex, property);
          }

          this._lastStylingInput = entry;
          this._firstStylingInput = this._firstStylingInput || entry;

          this._checkForPipes(value);

          this.hasBindings = true;
          return entry;
        }
      }, {
        key: "registerClassInput",
        value: function registerClassInput(name, isMapBased, value, sourceSpan) {
          if (isEmptyExpression(value)) {
            return null;
          }

          var _parseProperty2 = parseProperty(name),
              property = _parseProperty2.property,
              hasOverrideFlag = _parseProperty2.hasOverrideFlag;

          var entry = {
            name: property,
            value: value,
            sourceSpan: sourceSpan,
            sanitize: false,
            hasOverrideFlag: hasOverrideFlag,
            unit: null
          };

          if (isMapBased) {
            if (this._classMapInput) {
              throw new Error('[class] and [className] bindings cannot be used on the same element simultaneously');
            }

            this._classMapInput = entry;
          } else {
            (this._singleClassInputs = this._singleClassInputs || []).push(entry);
            registerIntoMap(this._classesIndex, property);
          }

          this._lastStylingInput = entry;
          this._firstStylingInput = this._firstStylingInput || entry;

          this._checkForPipes(value);

          this.hasBindings = true;
          return entry;
        }
      }, {
        key: "_checkForPipes",
        value: function _checkForPipes(value) {
          if (value instanceof ASTWithSource && value.ast instanceof BindingPipe) {
            this.hasBindingsWithPipes = true;
          }
        }
        /**
         * Registers the element's static style string value to the builder.
         *
         * @param value the style string (e.g. `width:100px; height:200px;`)
         */

      }, {
        key: "registerStyleAttr",
        value: function registerStyleAttr(value) {
          this._initialStyleValues = parse(value);
          this._hasInitialValues = true;
        }
        /**
         * Registers the element's static class string value to the builder.
         *
         * @param value the className string (e.g. `disabled gold zoom`)
         */

      }, {
        key: "registerClassAttr",
        value: function registerClassAttr(value) {
          this._initialClassValues = value.trim().split(/\s+/g);
          this._hasInitialValues = true;
        }
        /**
         * Appends all styling-related expressions to the provided attrs array.
         *
         * @param attrs an existing array where each of the styling expressions
         * will be inserted into.
         */

      }, {
        key: "populateInitialStylingAttrs",
        value: function populateInitialStylingAttrs(attrs) {
          // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]
          if (this._initialClassValues.length) {
            attrs.push(literal(1
            /* Classes */
            ));

            for (var i = 0; i < this._initialClassValues.length; i++) {
              attrs.push(literal(this._initialClassValues[i]));
            }
          } // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]


          if (this._initialStyleValues.length) {
            attrs.push(literal(2
            /* Styles */
            ));

            for (var _i6 = 0; _i6 < this._initialStyleValues.length; _i6 += 2) {
              attrs.push(literal(this._initialStyleValues[_i6]), literal(this._initialStyleValues[_i6 + 1]));
            }
          }
        }
        /**
         * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.
         *
         * The instruction generation code below is used for producing the AOT statement code which is
         * responsible for registering initial styles (within a directive hostBindings' creation block),
         * as well as any of the provided attribute values, to the directive host element.
         */

      }, {
        key: "assignHostAttrs",
        value: function assignHostAttrs(attrs, definitionMap) {
          if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {
            this.populateInitialStylingAttrs(attrs);
            definitionMap.set('hostAttrs', literalArr(attrs));
          }
        }
        /**
         * Builds an instruction with all the expressions and parameters for `classMap`.
         *
         * The instruction data will contain all expressions for `classMap` to function
         * which includes the `[class]` expression params.
         */

      }, {
        key: "buildClassMapInstruction",
        value: function buildClassMapInstruction(valueConverter) {
          if (this._classMapInput) {
            return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);
          }

          return null;
        }
        /**
         * Builds an instruction with all the expressions and parameters for `styleMap`.
         *
         * The instruction data will contain all expressions for `styleMap` to function
         * which includes the `[style]` expression params.
         */

      }, {
        key: "buildStyleMapInstruction",
        value: function buildStyleMapInstruction(valueConverter) {
          if (this._styleMapInput) {
            return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);
          }

          return null;
        }
      }, {
        key: "_buildMapBasedInstruction",
        value: function _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {
          // each styling binding value is stored in the LView
          // map-based bindings allocate two slots: one for the
          // previous binding value and another for the previous
          // className or style attribute value.
          var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED; // these values must be outside of the update block so that they can
          // be evaluated (the AST visit call) during creation time so that any
          // pipes can be picked up in time before the template is built

          var mapValue = stylingInput.value.visit(valueConverter);
          var reference;

          if (mapValue instanceof Interpolation) {
            totalBindingSlotsRequired += mapValue.expressions.length;
            reference = isClassBased ? getClassMapInterpolationExpression(mapValue) : getStyleMapInterpolationExpression(mapValue);
          } else {
            reference = isClassBased ? Identifiers$1.classMap : Identifiers$1.styleMap;
          }

          return {
            reference: reference,
            calls: [{
              supportsInterpolation: true,
              sourceSpan: stylingInput.sourceSpan,
              allocateBindingSlots: totalBindingSlotsRequired,
              params: function params(convertFn) {
                var convertResult = convertFn(mapValue);
                var params = Array.isArray(convertResult) ? convertResult : [convertResult];
                return params;
              }
            }]
          };
        }
      }, {
        key: "_buildSingleInputs",
        value: function _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {
          var instructions = [];
          inputs.forEach(function (input) {
            var previousInstruction = instructions[instructions.length - 1];
            var value = input.value.visit(valueConverter);
            var referenceForCall = reference; // each styling binding value is stored in the LView
            // but there are two values stored for each binding:
            //   1) the value itself
            //   2) an intermediate value (concatenation of style up to this point).
            //      We need to store the intermediate value so that we don't allocate
            //      the strings on each CD.

            var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;

            if (value instanceof Interpolation) {
              totalBindingSlotsRequired += value.expressions.length;

              if (getInterpolationExpressionFn) {
                referenceForCall = getInterpolationExpressionFn(value);
              }
            }

            var call = {
              sourceSpan: input.sourceSpan,
              allocateBindingSlots: totalBindingSlotsRequired,
              supportsInterpolation: !!getInterpolationExpressionFn,
              params: function params(convertFn) {
                // params => stylingProp(propName, value, suffix|sanitizer)
                var params = [];
                params.push(literal(input.name));
                var convertResult = convertFn(value);

                if (Array.isArray(convertResult)) {
                  params.push.apply(params, _toConsumableArray(convertResult));
                } else {
                  params.push(convertResult);
                } // [style.prop] bindings may use suffix values (e.g. px, em, etc...) and they
                // can also use a sanitizer. Sanitization occurs for url-based entries. Having
                // the suffix value and a sanitizer together into the instruction doesn't make
                // any sense (url-based entries cannot be sanitized).


                if (!isClassBased) {
                  if (input.unit) {
                    params.push(literal(input.unit));
                  } else if (input.sanitize) {
                    params.push(importExpr(Identifiers$1.defaultStyleSanitizer));
                  }
                }

                return params;
              }
            }; // If we ended up generating a call to the same instruction as the previous styling property
            // we can chain the calls together safely to save some bytes, otherwise we have to generate
            // a separate instruction call. This is primarily a concern with interpolation instructions
            // where we may start off with one `reference`, but end up using another based on the
            // number of interpolations.

            if (previousInstruction && previousInstruction.reference === referenceForCall) {
              previousInstruction.calls.push(call);
            } else {
              instructions.push({
                reference: referenceForCall,
                calls: [call]
              });
            }
          });
          return instructions;
        }
      }, {
        key: "_buildClassInputs",
        value: function _buildClassInputs(valueConverter) {
          if (this._singleClassInputs) {
            return this._buildSingleInputs(Identifiers$1.classProp, this._singleClassInputs, valueConverter, null, true);
          }

          return [];
        }
      }, {
        key: "_buildStyleInputs",
        value: function _buildStyleInputs(valueConverter) {
          if (this._singleStyleInputs) {
            return this._buildSingleInputs(Identifiers$1.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);
          }

          return [];
        }
        /**
         * Constructs all instructions which contain the expressions that will be placed
         * into the update block of a template function or a directive hostBindings function.
         */

      }, {
        key: "buildUpdateLevelInstructions",
        value: function buildUpdateLevelInstructions(valueConverter) {
          var instructions = [];

          if (this.hasBindings) {
            var styleMapInstruction = this.buildStyleMapInstruction(valueConverter);

            if (styleMapInstruction) {
              instructions.push(styleMapInstruction);
            }

            var classMapInstruction = this.buildClassMapInstruction(valueConverter);

            if (classMapInstruction) {
              instructions.push(classMapInstruction);
            }

            instructions.push.apply(instructions, _toConsumableArray(this._buildStyleInputs(valueConverter)));
            instructions.push.apply(instructions, _toConsumableArray(this._buildClassInputs(valueConverter)));
          }

          return instructions;
        }
      }]);

      return StylingBuilder;
    }();

    function registerIntoMap(map, key) {
      if (!map.has(key)) {
        map.set(key, map.size);
      }
    }

    function isStyleSanitizable(prop) {
      // Note that browsers support both the dash case and
      // camel case property names when setting through JS.
      return prop === 'background-image' || prop === 'backgroundImage' || prop === 'background' || prop === 'border-image' || prop === 'borderImage' || prop === 'border-image-source' || prop === 'borderImageSource' || prop === 'filter' || prop === 'list-style' || prop === 'listStyle' || prop === 'list-style-image' || prop === 'listStyleImage' || prop === 'clip-path' || prop === 'clipPath';
    }
    /**
     * Simple helper function to either provide the constant literal that will house the value
     * here or a null value if the provided values are empty.
     */


    function getConstantLiteralFromArray(constantPool, values) {
      return values.length ? constantPool.getConstLiteral(literalArr(values), true) : NULL_EXPR;
    }

    function parseProperty(name) {
      var hasOverrideFlag = false;
      var overrideIndex = name.indexOf(IMPORTANT_FLAG);

      if (overrideIndex !== -1) {
        name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';
        hasOverrideFlag = true;
      }

      var unit = '';
      var property = name;
      var unitIndex = name.lastIndexOf('.');

      if (unitIndex > 0) {
        unit = name.substr(unitIndex + 1);
        property = name.substring(0, unitIndex);
      }

      return {
        property: property,
        unit: unit,
        hasOverrideFlag: hasOverrideFlag
      };
    }
    /**
     * Gets the instruction to generate for an interpolated class map.
     * @param interpolation An Interpolation AST
     */


    function getClassMapInterpolationExpression(interpolation) {
      switch (getInterpolationArgsLength(interpolation)) {
        case 1:
          return Identifiers$1.classMap;

        case 3:
          return Identifiers$1.classMapInterpolate1;

        case 5:
          return Identifiers$1.classMapInterpolate2;

        case 7:
          return Identifiers$1.classMapInterpolate3;

        case 9:
          return Identifiers$1.classMapInterpolate4;

        case 11:
          return Identifiers$1.classMapInterpolate5;

        case 13:
          return Identifiers$1.classMapInterpolate6;

        case 15:
          return Identifiers$1.classMapInterpolate7;

        case 17:
          return Identifiers$1.classMapInterpolate8;

        default:
          return Identifiers$1.classMapInterpolateV;
      }
    }
    /**
     * Gets the instruction to generate for an interpolated style map.
     * @param interpolation An Interpolation AST
     */


    function getStyleMapInterpolationExpression(interpolation) {
      switch (getInterpolationArgsLength(interpolation)) {
        case 1:
          return Identifiers$1.styleMap;

        case 3:
          return Identifiers$1.styleMapInterpolate1;

        case 5:
          return Identifiers$1.styleMapInterpolate2;

        case 7:
          return Identifiers$1.styleMapInterpolate3;

        case 9:
          return Identifiers$1.styleMapInterpolate4;

        case 11:
          return Identifiers$1.styleMapInterpolate5;

        case 13:
          return Identifiers$1.styleMapInterpolate6;

        case 15:
          return Identifiers$1.styleMapInterpolate7;

        case 17:
          return Identifiers$1.styleMapInterpolate8;

        default:
          return Identifiers$1.styleMapInterpolateV;
      }
    }
    /**
     * Gets the instruction to generate for an interpolated style prop.
     * @param interpolation An Interpolation AST
     */


    function getStylePropInterpolationExpression(interpolation) {
      switch (getInterpolationArgsLength(interpolation)) {
        case 1:
          return Identifiers$1.styleProp;

        case 3:
          return Identifiers$1.stylePropInterpolate1;

        case 5:
          return Identifiers$1.stylePropInterpolate2;

        case 7:
          return Identifiers$1.stylePropInterpolate3;

        case 9:
          return Identifiers$1.stylePropInterpolate4;

        case 11:
          return Identifiers$1.stylePropInterpolate5;

        case 13:
          return Identifiers$1.stylePropInterpolate6;

        case 15:
          return Identifiers$1.stylePropInterpolate7;

        case 17:
          return Identifiers$1.stylePropInterpolate8;

        default:
          return Identifiers$1.stylePropInterpolateV;
      }
    }

    function normalizePropName(prop) {
      return hyphenate(prop);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var TokenType$1;

    (function (TokenType) {
      TokenType[TokenType["Character"] = 0] = "Character";
      TokenType[TokenType["Identifier"] = 1] = "Identifier";
      TokenType[TokenType["Keyword"] = 2] = "Keyword";
      TokenType[TokenType["String"] = 3] = "String";
      TokenType[TokenType["Operator"] = 4] = "Operator";
      TokenType[TokenType["Number"] = 5] = "Number";
      TokenType[TokenType["Error"] = 6] = "Error";
    })(TokenType$1 || (TokenType$1 = {}));

    var KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];

    var Lexer =
    /*#__PURE__*/
    function () {
      function Lexer() {
        _classCallCheck(this, Lexer);
      }

      _createClass(Lexer, [{
        key: "tokenize",
        value: function tokenize(text) {
          var scanner = new _Scanner(text);
          var tokens = [];
          var token = scanner.scanToken();

          while (token != null) {
            tokens.push(token);
            token = scanner.scanToken();
          }

          return tokens;
        }
      }]);

      return Lexer;
    }();

    var Token$1 =
    /*#__PURE__*/
    function () {
      function Token$1(index, end, type, numValue, strValue) {
        _classCallCheck(this, Token$1);

        this.index = index;
        this.end = end;
        this.type = type;
        this.numValue = numValue;
        this.strValue = strValue;
      }

      _createClass(Token$1, [{
        key: "isCharacter",
        value: function isCharacter(code) {
          return this.type == TokenType$1.Character && this.numValue == code;
        }
      }, {
        key: "isNumber",
        value: function isNumber() {
          return this.type == TokenType$1.Number;
        }
      }, {
        key: "isString",
        value: function isString() {
          return this.type == TokenType$1.String;
        }
      }, {
        key: "isOperator",
        value: function isOperator(operator) {
          return this.type == TokenType$1.Operator && this.strValue == operator;
        }
      }, {
        key: "isIdentifier",
        value: function isIdentifier() {
          return this.type == TokenType$1.Identifier;
        }
      }, {
        key: "isKeyword",
        value: function isKeyword() {
          return this.type == TokenType$1.Keyword;
        }
      }, {
        key: "isKeywordLet",
        value: function isKeywordLet() {
          return this.type == TokenType$1.Keyword && this.strValue == 'let';
        }
      }, {
        key: "isKeywordAs",
        value: function isKeywordAs() {
          return this.type == TokenType$1.Keyword && this.strValue == 'as';
        }
      }, {
        key: "isKeywordNull",
        value: function isKeywordNull() {
          return this.type == TokenType$1.Keyword && this.strValue == 'null';
        }
      }, {
        key: "isKeywordUndefined",
        value: function isKeywordUndefined() {
          return this.type == TokenType$1.Keyword && this.strValue == 'undefined';
        }
      }, {
        key: "isKeywordTrue",
        value: function isKeywordTrue() {
          return this.type == TokenType$1.Keyword && this.strValue == 'true';
        }
      }, {
        key: "isKeywordFalse",
        value: function isKeywordFalse() {
          return this.type == TokenType$1.Keyword && this.strValue == 'false';
        }
      }, {
        key: "isKeywordThis",
        value: function isKeywordThis() {
          return this.type == TokenType$1.Keyword && this.strValue == 'this';
        }
      }, {
        key: "isError",
        value: function isError() {
          return this.type == TokenType$1.Error;
        }
      }, {
        key: "toNumber",
        value: function toNumber() {
          return this.type == TokenType$1.Number ? this.numValue : -1;
        }
      }, {
        key: "toString",
        value: function toString() {
          switch (this.type) {
            case TokenType$1.Character:
            case TokenType$1.Identifier:
            case TokenType$1.Keyword:
            case TokenType$1.Operator:
            case TokenType$1.String:
            case TokenType$1.Error:
              return this.strValue;

            case TokenType$1.Number:
              return this.numValue.toString();

            default:
              return null;
          }
        }
      }]);

      return Token$1;
    }();

    function newCharacterToken(index, end, code) {
      return new Token$1(index, end, TokenType$1.Character, code, String.fromCharCode(code));
    }

    function newIdentifierToken(index, end, text) {
      return new Token$1(index, end, TokenType$1.Identifier, 0, text);
    }

    function newKeywordToken(index, end, text) {
      return new Token$1(index, end, TokenType$1.Keyword, 0, text);
    }

    function newOperatorToken(index, end, text) {
      return new Token$1(index, end, TokenType$1.Operator, 0, text);
    }

    function newStringToken(index, end, text) {
      return new Token$1(index, end, TokenType$1.String, 0, text);
    }

    function newNumberToken(index, end, n) {
      return new Token$1(index, end, TokenType$1.Number, n, '');
    }

    function newErrorToken(index, end, message) {
      return new Token$1(index, end, TokenType$1.Error, 0, message);
    }

    var EOF = new Token$1(-1, -1, TokenType$1.Character, 0, '');

    var _Scanner =
    /*#__PURE__*/
    function () {
      function _Scanner(input) {
        _classCallCheck(this, _Scanner);

        this.input = input;
        this.peek = 0;
        this.index = -1;
        this.length = input.length;
        this.advance();
      }

      _createClass(_Scanner, [{
        key: "advance",
        value: function advance() {
          this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
        }
      }, {
        key: "scanToken",
        value: function scanToken() {
          var input = this.input,
              length = this.length;
          var peek = this.peek,
              index = this.index; // Skip whitespace.

          while (peek <= $SPACE) {
            if (++index >= length) {
              peek = $EOF;
              break;
            } else {
              peek = input.charCodeAt(index);
            }
          }

          this.peek = peek;
          this.index = index;

          if (index >= length) {
            return null;
          } // Handle identifiers and numbers.


          if (isIdentifierStart(peek)) return this.scanIdentifier();
          if (isDigit(peek)) return this.scanNumber(index);
          var start = index;

          switch (peek) {
            case $PERIOD:
              this.advance();
              return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);

            case $LPAREN:
            case $RPAREN:
            case $LBRACE:
            case $RBRACE:
            case $LBRACKET:
            case $RBRACKET:
            case $COMMA:
            case $COLON:
            case $SEMICOLON:
              return this.scanCharacter(start, peek);

            case $SQ:
            case $DQ:
              return this.scanString();

            case $HASH:
            case $PLUS:
            case $MINUS:
            case $STAR:
            case $SLASH:
            case $PERCENT:
            case $CARET:
              return this.scanOperator(start, String.fromCharCode(peek));

            case $QUESTION:
              return this.scanComplexOperator(start, '?', $PERIOD, '.');

            case $LT:
            case $GT:
              return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');

            case $BANG:
            case $EQ:
              return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');

            case $AMPERSAND:
              return this.scanComplexOperator(start, '&', $AMPERSAND, '&');

            case $BAR:
              return this.scanComplexOperator(start, '|', $BAR, '|');

            case $NBSP:
              while (isWhitespace(this.peek)) {
                this.advance();
              }

              return this.scanToken();
          }

          this.advance();
          return this.error("Unexpected character [".concat(String.fromCharCode(peek), "]"), 0);
        }
      }, {
        key: "scanCharacter",
        value: function scanCharacter(start, code) {
          this.advance();
          return newCharacterToken(start, this.index, code);
        }
      }, {
        key: "scanOperator",
        value: function scanOperator(start, str) {
          this.advance();
          return newOperatorToken(start, this.index, str);
        }
        /**
         * Tokenize a 2/3 char long operator
         *
         * @param start start index in the expression
         * @param one first symbol (always part of the operator)
         * @param twoCode code point for the second symbol
         * @param two second symbol (part of the operator when the second code point matches)
         * @param threeCode code point for the third symbol
         * @param three third symbol (part of the operator when provided and matches source expression)
         */

      }, {
        key: "scanComplexOperator",
        value: function scanComplexOperator(start, one, twoCode, two, threeCode, three) {
          this.advance();
          var str = one;

          if (this.peek == twoCode) {
            this.advance();
            str += two;
          }

          if (threeCode != null && this.peek == threeCode) {
            this.advance();
            str += three;
          }

          return newOperatorToken(start, this.index, str);
        }
      }, {
        key: "scanIdentifier",
        value: function scanIdentifier() {
          var start = this.index;
          this.advance();

          while (isIdentifierPart(this.peek)) {
            this.advance();
          }

          var str = this.input.substring(start, this.index);
          return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);
        }
      }, {
        key: "scanNumber",
        value: function scanNumber(start) {
          var simple = this.index === start;
          this.advance(); // Skip initial digit.

          while (true) {
            if (isDigit(this.peek)) {// Do nothing.
            } else if (this.peek == $PERIOD) {
              simple = false;
            } else if (isExponentStart(this.peek)) {
              this.advance();
              if (isExponentSign(this.peek)) this.advance();
              if (!isDigit(this.peek)) return this.error('Invalid exponent', -1);
              simple = false;
            } else {
              break;
            }

            this.advance();
          }

          var str = this.input.substring(start, this.index);
          var value = simple ? parseIntAutoRadix(str) : parseFloat(str);
          return newNumberToken(start, this.index, value);
        }
      }, {
        key: "scanString",
        value: function scanString() {
          var start = this.index;
          var quote = this.peek;
          this.advance(); // Skip initial quote.

          var buffer = '';
          var marker = this.index;
          var input = this.input;

          while (this.peek != quote) {
            if (this.peek == $BACKSLASH) {
              buffer += input.substring(marker, this.index);
              this.advance();
              var unescapedCode = void 0; // Workaround for TS2.1-introduced type strictness

              this.peek = this.peek;

              if (this.peek == $u) {
                // 4 character hex code for unicode character.
                var hex = input.substring(this.index + 1, this.index + 5);

                if (/^[0-9a-f]+$/i.test(hex)) {
                  unescapedCode = parseInt(hex, 16);
                } else {
                  return this.error("Invalid unicode escape [\\u".concat(hex, "]"), 0);
                }

                for (var i = 0; i < 5; i++) {
                  this.advance();
                }
              } else {
                unescapedCode = unescape(this.peek);
                this.advance();
              }

              buffer += String.fromCharCode(unescapedCode);
              marker = this.index;
            } else if (this.peek == $EOF) {
              return this.error('Unterminated quote', 0);
            } else {
              this.advance();
            }
          }

          var last = input.substring(marker, this.index);
          this.advance(); // Skip terminating quote.

          return newStringToken(start, this.index, buffer + last);
        }
      }, {
        key: "error",
        value: function error(message, offset) {
          var position = this.index + offset;
          return newErrorToken(position, this.index, "Lexer Error: ".concat(message, " at column ").concat(position, " in expression [").concat(this.input, "]"));
        }
      }]);

      return _Scanner;
    }();

    function isIdentifierStart(code) {
      return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;
    }

    function isIdentifier(input) {
      if (input.length == 0) return false;
      var scanner = new _Scanner(input);
      if (!isIdentifierStart(scanner.peek)) return false;
      scanner.advance();

      while (scanner.peek !== $EOF) {
        if (!isIdentifierPart(scanner.peek)) return false;
        scanner.advance();
      }

      return true;
    }

    function isIdentifierPart(code) {
      return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;
    }

    function isExponentStart(code) {
      return code == $e || code == $E;
    }

    function isExponentSign(code) {
      return code == $MINUS || code == $PLUS;
    }

    function isQuote(code) {
      return code === $SQ || code === $DQ || code === $BT;
    }

    function unescape(code) {
      switch (code) {
        case $n:
          return $LF;

        case $f:
          return $FF;

        case $r:
          return $CR;

        case $t:
          return $TAB;

        case $v:
          return $VTAB;

        default:
          return code;
      }
    }

    function parseIntAutoRadix(text) {
      var result = parseInt(text);

      if (isNaN(result)) {
        throw new Error('Invalid integer literal when parsing ' + text);
      }

      return result;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var SplitInterpolation = function SplitInterpolation(strings, expressions, offsets) {
      _classCallCheck(this, SplitInterpolation);

      this.strings = strings;
      this.expressions = expressions;
      this.offsets = offsets;
    };

    var TemplateBindingParseResult = function TemplateBindingParseResult(templateBindings, warnings, errors) {
      _classCallCheck(this, TemplateBindingParseResult);

      this.templateBindings = templateBindings;
      this.warnings = warnings;
      this.errors = errors;
    };

    var defaultInterpolateRegExp = _createInterpolateRegExp(DEFAULT_INTERPOLATION_CONFIG);

    function _getInterpolateRegExp(config) {
      if (config === DEFAULT_INTERPOLATION_CONFIG) {
        return defaultInterpolateRegExp;
      } else {
        return _createInterpolateRegExp(config);
      }
    }

    function _createInterpolateRegExp(config) {
      var pattern = escapeRegExp(config.start) + '([\\s\\S]*?)' + escapeRegExp(config.end);
      return new RegExp(pattern, 'g');
    }

    var Parser$1 =
    /*#__PURE__*/
    function () {
      function Parser$1(_lexer) {
        _classCallCheck(this, Parser$1);

        this._lexer = _lexer;
        this.errors = [];
        this.simpleExpressionChecker = SimpleExpressionChecker;
      }

      _createClass(Parser$1, [{
        key: "parseAction",
        value: function parseAction(input, location, absoluteOffset) {
          var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;

          this._checkNoInterpolation(input, location, interpolationConfig);

          var sourceToLex = this._stripComments(input);

          var tokens = this._lexer.tokenize(this._stripComments(input));

          var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length).parseChain();
          return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
      }, {
        key: "parseBinding",
        value: function parseBinding(input, location, absoluteOffset) {
          var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;

          var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);

          return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
      }, {
        key: "checkSimpleExpression",
        value: function checkSimpleExpression(ast) {
          var checker = new this.simpleExpressionChecker();
          ast.visit(checker);
          return checker.errors;
        }
      }, {
        key: "parseSimpleBinding",
        value: function parseSimpleBinding(input, location, absoluteOffset) {
          var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;

          var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);

          var errors = this.checkSimpleExpression(ast);

          if (errors.length > 0) {
            this._reportError("Host binding expression cannot contain ".concat(errors.join(' ')), input, location);
          }

          return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
      }, {
        key: "_reportError",
        value: function _reportError(message, input, errLocation, ctxLocation) {
          this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
        }
      }, {
        key: "_parseBindingAst",
        value: function _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {
          // Quotes expressions use 3rd-party expression language. We don't want to use
          // our lexer or parser for that, so we check for that ahead of time.
          var quote = this._parseQuote(input, location, absoluteOffset);

          if (quote != null) {
            return quote;
          }

          this._checkNoInterpolation(input, location, interpolationConfig);

          var sourceToLex = this._stripComments(input);

          var tokens = this._lexer.tokenize(sourceToLex);

          return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length).parseChain();
        }
      }, {
        key: "_parseQuote",
        value: function _parseQuote(input, location, absoluteOffset) {
          if (input == null) return null;
          var prefixSeparatorIndex = input.indexOf(':');
          if (prefixSeparatorIndex == -1) return null;
          var prefix = input.substring(0, prefixSeparatorIndex).trim();
          if (!isIdentifier(prefix)) return null;
          var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
          var span = new ParseSpan(0, input.length);
          return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);
        }
      }, {
        key: "parseTemplateBindings",
        value: function parseTemplateBindings(tplKey, tplValue, location, absoluteOffset) {
          var tokens = this._lexer.tokenize(tplValue);

          return new _ParseAST(tplValue, location, absoluteOffset, tokens, tplValue.length, false, this.errors, 0).parseTemplateBindings(tplKey);
        }
      }, {
        key: "parseInterpolation",
        value: function parseInterpolation(input, location, absoluteOffset) {
          var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;
          var split = this.splitInterpolation(input, location, interpolationConfig);
          if (split == null) return null;
          var expressions = [];

          for (var i = 0; i < split.expressions.length; ++i) {
            var expressionText = split.expressions[i];

            var sourceToLex = this._stripComments(expressionText);

            var tokens = this._lexer.tokenize(sourceToLex);

            var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length)).parseChain();
            expressions.push(ast);
          }

          var span = new ParseSpan(0, input == null ? 0 : input.length);
          return new ASTWithSource(new Interpolation(span, span.toAbsolute(absoluteOffset), split.strings, expressions), input, location, absoluteOffset, this.errors);
        }
      }, {
        key: "splitInterpolation",
        value: function splitInterpolation(input, location) {
          var interpolationConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_INTERPOLATION_CONFIG;

          var regexp = _getInterpolateRegExp(interpolationConfig);

          var parts = input.split(regexp);

          if (parts.length <= 1) {
            return null;
          }

          var strings = [];
          var expressions = [];
          var offsets = [];
          var offset = 0;

          for (var i = 0; i < parts.length; i++) {
            var part = parts[i];

            if (i % 2 === 0) {
              // fixed string
              strings.push(part);
              offset += part.length;
            } else if (part.trim().length > 0) {
              offset += interpolationConfig.start.length;
              expressions.push(part);
              offsets.push(offset);
              offset += part.length + interpolationConfig.end.length;
            } else {
              this._reportError('Blank expressions are not allowed in interpolated strings', input, "at column ".concat(this._findInterpolationErrorColumn(parts, i, interpolationConfig), " in"), location);

              expressions.push('$implicit');
              offsets.push(offset);
            }
          }

          return new SplitInterpolation(strings, expressions, offsets);
        }
      }, {
        key: "wrapLiteralPrimitive",
        value: function wrapLiteralPrimitive(input, location, absoluteOffset) {
          var span = new ParseSpan(0, input == null ? 0 : input.length);
          return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);
        }
      }, {
        key: "_stripComments",
        value: function _stripComments(input) {
          var i = this._commentStart(input);

          return i != null ? input.substring(0, i).trim() : input;
        }
      }, {
        key: "_commentStart",
        value: function _commentStart(input) {
          var outerQuote = null;

          for (var i = 0; i < input.length - 1; i++) {
            var char = input.charCodeAt(i);
            var nextChar = input.charCodeAt(i + 1);
            if (char === $SLASH && nextChar == $SLASH && outerQuote == null) return i;

            if (outerQuote === char) {
              outerQuote = null;
            } else if (outerQuote == null && isQuote(char)) {
              outerQuote = char;
            }
          }

          return null;
        }
      }, {
        key: "_checkNoInterpolation",
        value: function _checkNoInterpolation(input, location, interpolationConfig) {
          var regexp = _getInterpolateRegExp(interpolationConfig);

          var parts = input.split(regexp);

          if (parts.length > 1) {
            this._reportError("Got interpolation (".concat(interpolationConfig.start).concat(interpolationConfig.end, ") where expression was expected"), input, "at column ".concat(this._findInterpolationErrorColumn(parts, 1, interpolationConfig), " in"), location);
          }
        }
      }, {
        key: "_findInterpolationErrorColumn",
        value: function _findInterpolationErrorColumn(parts, partInErrIdx, interpolationConfig) {
          var errLocation = '';

          for (var j = 0; j < partInErrIdx; j++) {
            errLocation += j % 2 === 0 ? parts[j] : "".concat(interpolationConfig.start).concat(parts[j]).concat(interpolationConfig.end);
          }

          return errLocation.length;
        }
      }]);

      return Parser$1;
    }();

    var IvyParser =
    /*#__PURE__*/
    function (_Parser$) {
      _inherits(IvyParser, _Parser$);

      function IvyParser() {
        var _this153;

        _classCallCheck(this, IvyParser);

        _this153 = _possibleConstructorReturn(this, _getPrototypeOf(IvyParser).apply(this, arguments));
        _this153.simpleExpressionChecker = IvySimpleExpressionChecker; //

        return _this153;
      }

      return IvyParser;
    }(Parser$1);

    var _ParseAST =
    /*#__PURE__*/
    function () {
      function _ParseAST(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {
        _classCallCheck(this, _ParseAST);

        this.input = input;
        this.location = location;
        this.absoluteOffset = absoluteOffset;
        this.tokens = tokens;
        this.inputLength = inputLength;
        this.parseAction = parseAction;
        this.errors = errors;
        this.offset = offset;
        this.rparensExpected = 0;
        this.rbracketsExpected = 0;
        this.rbracesExpected = 0; // Cache of expression start and input indeces to the absolute source span they map to, used to
        // prevent creating superfluous source spans in `sourceSpan`.
        // A serial of the expression start and input index is used for mapping because both are stateful
        // and may change for subsequent expressions visited by the parser.

        this.sourceSpanCache = new Map();
        this.index = 0;
      }

      _createClass(_ParseAST, [{
        key: "peek",
        value: function peek(offset) {
          var i = this.index + offset;
          return i < this.tokens.length ? this.tokens[i] : EOF;
        }
      }, {
        key: "span",
        value: function span(start) {
          return new ParseSpan(start, this.inputIndex);
        }
      }, {
        key: "sourceSpan",
        value: function sourceSpan(start) {
          var serial = "".concat(start, "@").concat(this.inputIndex);

          if (!this.sourceSpanCache.has(serial)) {
            this.sourceSpanCache.set(serial, this.span(start).toAbsolute(this.absoluteOffset));
          }

          return this.sourceSpanCache.get(serial);
        }
      }, {
        key: "advance",
        value: function advance() {
          this.index++;
        }
      }, {
        key: "optionalCharacter",
        value: function optionalCharacter(code) {
          if (this.next.isCharacter(code)) {
            this.advance();
            return true;
          } else {
            return false;
          }
        }
      }, {
        key: "peekKeywordLet",
        value: function peekKeywordLet() {
          return this.next.isKeywordLet();
        }
      }, {
        key: "peekKeywordAs",
        value: function peekKeywordAs() {
          return this.next.isKeywordAs();
        }
      }, {
        key: "expectCharacter",
        value: function expectCharacter(code) {
          if (this.optionalCharacter(code)) return;
          this.error("Missing expected ".concat(String.fromCharCode(code)));
        }
      }, {
        key: "optionalOperator",
        value: function optionalOperator(op) {
          if (this.next.isOperator(op)) {
            this.advance();
            return true;
          } else {
            return false;
          }
        }
      }, {
        key: "expectOperator",
        value: function expectOperator(operator) {
          if (this.optionalOperator(operator)) return;
          this.error("Missing expected operator ".concat(operator));
        }
      }, {
        key: "expectIdentifierOrKeyword",
        value: function expectIdentifierOrKeyword() {
          var n = this.next;

          if (!n.isIdentifier() && !n.isKeyword()) {
            this.error("Unexpected token ".concat(n, ", expected identifier or keyword"));
            return '';
          }

          this.advance();
          return n.toString();
        }
      }, {
        key: "expectIdentifierOrKeywordOrString",
        value: function expectIdentifierOrKeywordOrString() {
          var n = this.next;

          if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
            this.error("Unexpected token ".concat(n, ", expected identifier, keyword, or string"));
            return '';
          }

          this.advance();
          return n.toString();
        }
      }, {
        key: "parseChain",
        value: function parseChain() {
          var exprs = [];
          var start = this.inputIndex;

          while (this.index < this.tokens.length) {
            var expr = this.parsePipe();
            exprs.push(expr);

            if (this.optionalCharacter($SEMICOLON)) {
              if (!this.parseAction) {
                this.error('Binding expression cannot contain chained expression');
              }

              while (this.optionalCharacter($SEMICOLON)) {} // read all semicolons

            } else if (this.index < this.tokens.length) {
              this.error("Unexpected token '".concat(this.next, "'"));
            }
          }

          if (exprs.length == 0) return new EmptyExpr(this.span(start), this.sourceSpan(start));
          if (exprs.length == 1) return exprs[0];
          return new Chain(this.span(start), this.sourceSpan(start), exprs);
        }
      }, {
        key: "parsePipe",
        value: function parsePipe() {
          var result = this.parseExpression();

          if (this.optionalOperator('|')) {
            if (this.parseAction) {
              this.error('Cannot have a pipe in an action expression');
            }

            do {
              var nameStart = this.inputIndex;
              var name = this.expectIdentifierOrKeyword();
              var nameSpan = this.sourceSpan(nameStart);
              var args = [];

              while (this.optionalCharacter($COLON)) {
                args.push(this.parseExpression());
              }

              var start = result.span.start;
              result = new BindingPipe(this.span(start), this.sourceSpan(start), result, name, args, nameSpan);
            } while (this.optionalOperator('|'));
          }

          return result;
        }
      }, {
        key: "parseExpression",
        value: function parseExpression() {
          return this.parseConditional();
        }
      }, {
        key: "parseConditional",
        value: function parseConditional() {
          var start = this.inputIndex;
          var result = this.parseLogicalOr();

          if (this.optionalOperator('?')) {
            var yes = this.parsePipe();
            var no;

            if (!this.optionalCharacter($COLON)) {
              var end = this.inputIndex;
              var expression = this.input.substring(start, end);
              this.error("Conditional expression ".concat(expression, " requires all 3 expressions"));
              no = new EmptyExpr(this.span(start), this.sourceSpan(start));
            } else {
              no = this.parsePipe();
            }

            return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);
          } else {
            return result;
          }
        }
      }, {
        key: "parseLogicalOr",
        value: function parseLogicalOr() {
          // '||'
          var result = this.parseLogicalAnd();

          while (this.optionalOperator('||')) {
            var right = this.parseLogicalAnd();
            var start = result.span.start;
            result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);
          }

          return result;
        }
      }, {
        key: "parseLogicalAnd",
        value: function parseLogicalAnd() {
          // '&&'
          var result = this.parseEquality();

          while (this.optionalOperator('&&')) {
            var right = this.parseEquality();
            var start = result.span.start;
            result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);
          }

          return result;
        }
      }, {
        key: "parseEquality",
        value: function parseEquality() {
          // '==','!=','===','!=='
          var result = this.parseRelational();

          while (this.next.type == TokenType$1.Operator) {
            var operator = this.next.strValue;

            switch (operator) {
              case '==':
              case '===':
              case '!=':
              case '!==':
                this.advance();
                var right = this.parseRelational();
                var start = result.span.start;
                result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                continue;
            }

            break;
          }

          return result;
        }
      }, {
        key: "parseRelational",
        value: function parseRelational() {
          // '<', '>', '<=', '>='
          var result = this.parseAdditive();

          while (this.next.type == TokenType$1.Operator) {
            var operator = this.next.strValue;

            switch (operator) {
              case '<':
              case '>':
              case '<=':
              case '>=':
                this.advance();
                var right = this.parseAdditive();
                var start = result.span.start;
                result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                continue;
            }

            break;
          }

          return result;
        }
      }, {
        key: "parseAdditive",
        value: function parseAdditive() {
          // '+', '-'
          var result = this.parseMultiplicative();

          while (this.next.type == TokenType$1.Operator) {
            var operator = this.next.strValue;

            switch (operator) {
              case '+':
              case '-':
                this.advance();
                var right = this.parseMultiplicative();
                var start = result.span.start;
                result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                continue;
            }

            break;
          }

          return result;
        }
      }, {
        key: "parseMultiplicative",
        value: function parseMultiplicative() {
          // '*', '%', '/'
          var result = this.parsePrefix();

          while (this.next.type == TokenType$1.Operator) {
            var operator = this.next.strValue;

            switch (operator) {
              case '*':
              case '%':
              case '/':
                this.advance();
                var right = this.parsePrefix();
                var start = result.span.start;
                result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                continue;
            }

            break;
          }

          return result;
        }
      }, {
        key: "parsePrefix",
        value: function parsePrefix() {
          if (this.next.type == TokenType$1.Operator) {
            var start = this.inputIndex;
            var operator = this.next.strValue;
            var literalSpan = new ParseSpan(start, start);
            var literalSourceSpan = literalSpan.toAbsolute(this.absoluteOffset);
            var result;

            switch (operator) {
              case '+':
                this.advance();
                result = this.parsePrefix();
                return new Binary(this.span(start), this.sourceSpan(start), '-', result, new LiteralPrimitive(literalSpan, literalSourceSpan, 0));

              case '-':
                this.advance();
                result = this.parsePrefix();
                return new Binary(this.span(start), this.sourceSpan(start), operator, new LiteralPrimitive(literalSpan, literalSourceSpan, 0), result);

              case '!':
                this.advance();
                result = this.parsePrefix();
                return new PrefixNot(this.span(start), this.sourceSpan(start), result);
            }
          }

          return this.parseCallChain();
        }
      }, {
        key: "parseCallChain",
        value: function parseCallChain() {
          var result = this.parsePrimary();
          var resultStart = result.span.start;

          while (true) {
            if (this.optionalCharacter($PERIOD)) {
              result = this.parseAccessMemberOrMethodCall(result, false);
            } else if (this.optionalOperator('?.')) {
              result = this.parseAccessMemberOrMethodCall(result, true);
            } else if (this.optionalCharacter($LBRACKET)) {
              this.rbracketsExpected++;
              var key = this.parsePipe();
              this.rbracketsExpected--;
              this.expectCharacter($RBRACKET);

              if (this.optionalOperator('=')) {
                var value = this.parseConditional();
                result = new KeyedWrite(this.span(resultStart), this.sourceSpan(resultStart), result, key, value);
              } else {
                result = new KeyedRead(this.span(resultStart), this.sourceSpan(resultStart), result, key);
              }
            } else if (this.optionalCharacter($LPAREN)) {
              this.rparensExpected++;
              var args = this.parseCallArguments();
              this.rparensExpected--;
              this.expectCharacter($RPAREN);
              result = new FunctionCall(this.span(resultStart), this.sourceSpan(resultStart), result, args);
            } else if (this.optionalOperator('!')) {
              result = new NonNullAssert(this.span(resultStart), this.sourceSpan(resultStart), result);
            } else {
              return result;
            }
          }
        }
      }, {
        key: "parsePrimary",
        value: function parsePrimary() {
          var start = this.inputIndex;

          if (this.optionalCharacter($LPAREN)) {
            this.rparensExpected++;
            var result = this.parsePipe();
            this.rparensExpected--;
            this.expectCharacter($RPAREN);
            return result;
          } else if (this.next.isKeywordNull()) {
            this.advance();
            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);
          } else if (this.next.isKeywordUndefined()) {
            this.advance();
            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);
          } else if (this.next.isKeywordTrue()) {
            this.advance();
            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);
          } else if (this.next.isKeywordFalse()) {
            this.advance();
            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);
          } else if (this.next.isKeywordThis()) {
            this.advance();
            return new ImplicitReceiver(this.span(start), this.sourceSpan(start));
          } else if (this.optionalCharacter($LBRACKET)) {
            this.rbracketsExpected++;
            var elements = this.parseExpressionList($RBRACKET);
            this.rbracketsExpected--;
            this.expectCharacter($RBRACKET);
            return new LiteralArray(this.span(start), this.sourceSpan(start), elements);
          } else if (this.next.isCharacter($LBRACE)) {
            return this.parseLiteralMap();
          } else if (this.next.isIdentifier()) {
            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), false);
          } else if (this.next.isNumber()) {
            var value = this.next.toNumber();
            this.advance();
            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);
          } else if (this.next.isString()) {
            var literalValue = this.next.toString();
            this.advance();
            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);
          } else if (this.index >= this.tokens.length) {
            this.error("Unexpected end of expression: ".concat(this.input));
            return new EmptyExpr(this.span(start), this.sourceSpan(start));
          } else {
            this.error("Unexpected token ".concat(this.next));
            return new EmptyExpr(this.span(start), this.sourceSpan(start));
          }
        }
      }, {
        key: "parseExpressionList",
        value: function parseExpressionList(terminator) {
          var result = [];

          if (!this.next.isCharacter(terminator)) {
            do {
              result.push(this.parsePipe());
            } while (this.optionalCharacter($COMMA));
          }

          return result;
        }
      }, {
        key: "parseLiteralMap",
        value: function parseLiteralMap() {
          var keys = [];
          var values = [];
          var start = this.inputIndex;
          this.expectCharacter($LBRACE);

          if (!this.optionalCharacter($RBRACE)) {
            this.rbracesExpected++;

            do {
              var quoted = this.next.isString();
              var key = this.expectIdentifierOrKeywordOrString();
              keys.push({
                key: key,
                quoted: quoted
              });
              this.expectCharacter($COLON);
              values.push(this.parsePipe());
            } while (this.optionalCharacter($COMMA));

            this.rbracesExpected--;
            this.expectCharacter($RBRACE);
          }

          return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);
        }
      }, {
        key: "parseAccessMemberOrMethodCall",
        value: function parseAccessMemberOrMethodCall(receiver) {
          var isSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var start = receiver.span.start;
          var id = this.expectIdentifierOrKeyword();

          if (this.optionalCharacter($LPAREN)) {
            this.rparensExpected++;
            var args = this.parseCallArguments();
            this.expectCharacter($RPAREN);
            this.rparensExpected--;
            var span = this.span(start);
            var sourceSpan = this.sourceSpan(start);
            return isSafe ? new SafeMethodCall(span, sourceSpan, receiver, id, args) : new MethodCall(span, sourceSpan, receiver, id, args);
          } else {
            if (isSafe) {
              if (this.optionalOperator('=')) {
                this.error('The \'?.\' operator cannot be used in the assignment');
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
              } else {
                return new SafePropertyRead(this.span(start), this.sourceSpan(start), receiver, id);
              }
            } else {
              if (this.optionalOperator('=')) {
                if (!this.parseAction) {
                  this.error('Bindings cannot contain assignments');
                  return new EmptyExpr(this.span(start), this.sourceSpan(start));
                }

                var value = this.parseConditional();
                return new PropertyWrite(this.span(start), this.sourceSpan(start), receiver, id, value);
              } else {
                var _span = this.span(start);

                return new PropertyRead(this.span(start), this.sourceSpan(start), receiver, id);
              }
            }
          }
        }
      }, {
        key: "parseCallArguments",
        value: function parseCallArguments() {
          if (this.next.isCharacter($RPAREN)) return [];
          var positionals = [];

          do {
            positionals.push(this.parsePipe());
          } while (this.optionalCharacter($COMMA));

          return positionals;
        }
        /**
         * An identifier, a keyword, a string with an optional `-` in between.
         */

      }, {
        key: "expectTemplateBindingKey",
        value: function expectTemplateBindingKey() {
          var result = '';
          var operatorFound = false;

          do {
            result += this.expectIdentifierOrKeywordOrString();
            operatorFound = this.optionalOperator('-');

            if (operatorFound) {
              result += '-';
            }
          } while (operatorFound);

          return result.toString();
        } // Parses the AST for `<some-tag *tplKey=AST>`

      }, {
        key: "parseTemplateBindings",
        value: function parseTemplateBindings(tplKey) {
          var firstBinding = true;
          var bindings = [];
          var warnings = [];

          do {
            var start = this.inputIndex;
            var rawKey = void 0;
            var key = void 0;
            var isVar = false;

            if (firstBinding) {
              rawKey = key = tplKey;
              firstBinding = false;
            } else {
              isVar = this.peekKeywordLet();
              if (isVar) this.advance();
              rawKey = this.expectTemplateBindingKey();
              key = isVar ? rawKey : tplKey + rawKey[0].toUpperCase() + rawKey.substring(1);
              this.optionalCharacter($COLON);
            }

            var name = null;
            var expression = null;

            if (isVar) {
              if (this.optionalOperator('=')) {
                name = this.expectTemplateBindingKey();
              } else {
                name = '\$implicit';
              }
            } else if (this.peekKeywordAs()) {
              this.advance(); // consume `as`

              name = rawKey;
              key = this.expectTemplateBindingKey(); // read local var name

              isVar = true;
            } else if (this.next !== EOF && !this.peekKeywordLet()) {
              var _start = this.inputIndex;
              var ast = this.parsePipe();
              var source = this.input.substring(_start - this.offset, this.inputIndex - this.offset);
              expression = new ASTWithSource(ast, source, this.location, this.absoluteOffset + _start, this.errors);
            }

            bindings.push(new TemplateBinding(this.span(start), this.sourceSpan(start), key, isVar, name, expression));

            if (this.peekKeywordAs() && !isVar) {
              var letStart = this.inputIndex;
              this.advance(); // consume `as`

              var letName = this.expectTemplateBindingKey(); // read local var name

              bindings.push(new TemplateBinding(this.span(letStart), this.sourceSpan(letStart), letName, true, key, null));
            }

            if (!this.optionalCharacter($SEMICOLON)) {
              this.optionalCharacter($COMMA);
            }
          } while (this.index < this.tokens.length);

          return new TemplateBindingParseResult(bindings, warnings, this.errors);
        }
      }, {
        key: "error",
        value: function error(message) {
          var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
          this.skip();
        }
      }, {
        key: "locationText",
        value: function locationText() {
          var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          if (index == null) index = this.index;
          return index < this.tokens.length ? "at column ".concat(this.tokens[index].index + 1, " in") : "at the end of the expression";
        } // Error recovery should skip tokens until it encounters a recovery point. skip() treats
        // the end of input and a ';' as unconditionally a recovery point. It also treats ')',
        // '}' and ']' as conditional recovery points if one of calling productions is expecting
        // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing
        // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because
        // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols
        // must be conditional as they must be skipped if none of the calling productions are not
        // expecting the closing token else we will never make progress in the case of an
        // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because
        // parseChain() is always the root production and it expects a ';'.
        // If a production expects one of these token it increments the corresponding nesting count,
        // and then decrements it just prior to checking if the token is in the input.

      }, {
        key: "skip",
        value: function skip() {
          var n = this.next;

          while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {
            if (this.next.isError()) {
              this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
            }

            this.advance();
            n = this.next;
          }
        }
      }, {
        key: "next",
        get: function get() {
          return this.peek(0);
        }
      }, {
        key: "inputIndex",
        get: function get() {
          return this.index < this.tokens.length ? this.next.index + this.offset : this.inputLength + this.offset;
        }
      }]);

      return _ParseAST;
    }();

    var SimpleExpressionChecker =
    /*#__PURE__*/
    function () {
      function SimpleExpressionChecker() {
        _classCallCheck(this, SimpleExpressionChecker);

        this.errors = [];
      }

      _createClass(SimpleExpressionChecker, [{
        key: "visitImplicitReceiver",
        value: function visitImplicitReceiver(ast, context) {}
      }, {
        key: "visitInterpolation",
        value: function visitInterpolation(ast, context) {}
      }, {
        key: "visitLiteralPrimitive",
        value: function visitLiteralPrimitive(ast, context) {}
      }, {
        key: "visitPropertyRead",
        value: function visitPropertyRead(ast, context) {}
      }, {
        key: "visitPropertyWrite",
        value: function visitPropertyWrite(ast, context) {}
      }, {
        key: "visitSafePropertyRead",
        value: function visitSafePropertyRead(ast, context) {}
      }, {
        key: "visitMethodCall",
        value: function visitMethodCall(ast, context) {}
      }, {
        key: "visitSafeMethodCall",
        value: function visitSafeMethodCall(ast, context) {}
      }, {
        key: "visitFunctionCall",
        value: function visitFunctionCall(ast, context) {}
      }, {
        key: "visitLiteralArray",
        value: function visitLiteralArray(ast, context) {
          this.visitAll(ast.expressions);
        }
      }, {
        key: "visitLiteralMap",
        value: function visitLiteralMap(ast, context) {
          this.visitAll(ast.values);
        }
      }, {
        key: "visitBinary",
        value: function visitBinary(ast, context) {}
      }, {
        key: "visitPrefixNot",
        value: function visitPrefixNot(ast, context) {}
      }, {
        key: "visitNonNullAssert",
        value: function visitNonNullAssert(ast, context) {}
      }, {
        key: "visitConditional",
        value: function visitConditional(ast, context) {}
      }, {
        key: "visitPipe",
        value: function visitPipe(ast, context) {
          this.errors.push('pipes');
        }
      }, {
        key: "visitKeyedRead",
        value: function visitKeyedRead(ast, context) {}
      }, {
        key: "visitKeyedWrite",
        value: function visitKeyedWrite(ast, context) {}
      }, {
        key: "visitAll",
        value: function visitAll(asts) {
          var _this154 = this;

          return asts.map(function (node) {
            return node.visit(_this154);
          });
        }
      }, {
        key: "visitChain",
        value: function visitChain(ast, context) {}
      }, {
        key: "visitQuote",
        value: function visitQuote(ast, context) {}
      }]);

      return SimpleExpressionChecker;
    }();
    /**
     * This class extends SimpleExpressionChecker used in View Engine and performs more strict checks to
     * make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is
     * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at
     * compile time. In order to preserve View Engine behavior, more strict checks are introduced for
     * Ivy mode only.
     */


    var IvySimpleExpressionChecker =
    /*#__PURE__*/
    function (_SimpleExpressionChec) {
      _inherits(IvySimpleExpressionChecker, _SimpleExpressionChec);

      function IvySimpleExpressionChecker() {
        _classCallCheck(this, IvySimpleExpressionChecker);

        return _possibleConstructorReturn(this, _getPrototypeOf(IvySimpleExpressionChecker).apply(this, arguments));
      }

      _createClass(IvySimpleExpressionChecker, [{
        key: "visitBinary",
        value: function visitBinary(ast, context) {
          ast.left.visit(this);
          ast.right.visit(this);
        }
      }, {
        key: "visitPrefixNot",
        value: function visitPrefixNot(ast, context) {
          ast.expression.visit(this);
        }
      }]);

      return IvySimpleExpressionChecker;
    }(SimpleExpressionChecker);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // =================================================================================================
    // =================================================================================================
    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
    // =================================================================================================
    // =================================================================================================
    //
    //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
    //                               Reach out to mprobst for details.
    //
    // =================================================================================================

    /** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */


    var _SECURITY_SCHEMA;

    function SECURITY_SCHEMA() {
      if (!_SECURITY_SCHEMA) {
        _SECURITY_SCHEMA = {}; // Case is insignificant below, all element and attribute names are lower-cased for lookup.

        registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);
        registerContext(SecurityContext.STYLE, ['*|style']); // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.

        registerContext(SecurityContext.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src']);
        registerContext(SecurityContext.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src']);
      }

      return _SECURITY_SCHEMA;
    }

    function registerContext(ctx, specs) {
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = specs[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var spec = _step7.value;
          _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var ElementSchemaRegistry = function ElementSchemaRegistry() {
      _classCallCheck(this, ElementSchemaRegistry);
    };
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var BOOLEAN = 'boolean';
    var NUMBER = 'number';
    var STRING = 'string';
    var OBJECT = 'object';
    /**
     * This array represents the DOM schema. It encodes inheritance, properties, and events.
     *
     * ## Overview
     *
     * Each line represents one kind of element. The `element_inheritance` and properties are joined
     * using `element_inheritance|properties` syntax.
     *
     * ## Element Inheritance
     *
     * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
     * Here the individual elements are separated by `,` (commas). Every element in the list
     * has identical properties.
     *
     * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
     * specified then `""` (blank) element is assumed.
     *
     * NOTE: The blank element inherits from root `[Element]` element, the super element of all
     * elements.
     *
     * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
     *
     * ## Properties
     *
     * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
     * by a special character designating its type:
     *
     * - (no prefix): property is a string.
     * - `*`: property represents an event.
     * - `!`: property is a boolean.
     * - `#`: property is a number.
     * - `%`: property is an object.
     *
     * ## Query
     *
     * The class creates an internal squas representation which allows to easily answer the query of
     * if a given property exist on a given element.
     *
     * NOTE: We don't yet support querying for types or events.
     * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
     *       see dom_element_schema_registry_spec.ts
     */
    // =================================================================================================
    // =================================================================================================
    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
    // =================================================================================================
    // =================================================================================================
    //
    //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
    //
    // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
    // dom_security_schema.ts. Reach out to mprobst & rjamet for details.
    //
    // =================================================================================================

    var SCHEMA = ['[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +
    /* added manually to avoid breaking changes */
    ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume', ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type', 'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'shadow^[HTMLElement]|', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|media,sizes,src,srcset,type', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|#height,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|'];
    var _ATTR_TO_PROP = {
      'class': 'className',
      'for': 'htmlFor',
      'formaction': 'formAction',
      'innerHtml': 'innerHTML',
      'readonly': 'readOnly',
      'tabindex': 'tabIndex'
    };

    var DomElementSchemaRegistry =
    /*#__PURE__*/
    function (_ElementSchemaRegistr) {
      _inherits(DomElementSchemaRegistry, _ElementSchemaRegistr);

      function DomElementSchemaRegistry() {
        var _this155;

        _classCallCheck(this, DomElementSchemaRegistry);

        _this155 = _possibleConstructorReturn(this, _getPrototypeOf(DomElementSchemaRegistry).call(this));
        _this155._schema = {};
        SCHEMA.forEach(function (encodedType) {
          var type = {};

          var _encodedType$split = encodedType.split('|'),
              _encodedType$split2 = _slicedToArray(_encodedType$split, 2),
              strType = _encodedType$split2[0],
              strProperties = _encodedType$split2[1];

          var properties = strProperties.split(',');

          var _strType$split = strType.split('^'),
              _strType$split2 = _slicedToArray(_strType$split, 2),
              typeNames = _strType$split2[0],
              superName = _strType$split2[1];

          typeNames.split(',').forEach(function (tag) {
            return _this155._schema[tag.toLowerCase()] = type;
          });

          var superType = superName && _this155._schema[superName.toLowerCase()];

          if (superType) {
            Object.keys(superType).forEach(function (prop) {
              type[prop] = superType[prop];
            });
          }

          properties.forEach(function (property) {
            if (property.length > 0) {
              switch (property[0]) {
                case '*':
                  // We don't yet support events.
                  // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
                  // will
                  // almost certainly introduce bad XSS vulnerabilities.
                  // type[property.substring(1)] = EVENT;
                  break;

                case '!':
                  type[property.substring(1)] = BOOLEAN;
                  break;

                case '#':
                  type[property.substring(1)] = NUMBER;
                  break;

                case '%':
                  type[property.substring(1)] = OBJECT;
                  break;

                default:
                  type[property] = STRING;
              }
            }
          });
        });
        return _this155;
      }

      _createClass(DomElementSchemaRegistry, [{
        key: "hasProperty",
        value: function hasProperty(tagName, propName, schemaMetas) {
          if (schemaMetas.some(function (schema) {
            return schema.name === NO_ERRORS_SCHEMA.name;
          })) {
            return true;
          }

          if (tagName.indexOf('-') > -1) {
            if (isNgContainer(tagName) || isNgContent(tagName)) {
              return false;
            }

            if (schemaMetas.some(function (schema) {
              return schema.name === CUSTOM_ELEMENTS_SCHEMA.name;
            })) {
              // Can't tell now as we don't know which properties a custom element will get
              // once it is instantiated
              return true;
            }
          }

          var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];

          return !!elementProperties[propName];
        }
      }, {
        key: "hasElement",
        value: function hasElement(tagName, schemaMetas) {
          if (schemaMetas.some(function (schema) {
            return schema.name === NO_ERRORS_SCHEMA.name;
          })) {
            return true;
          }

          if (tagName.indexOf('-') > -1) {
            if (isNgContainer(tagName) || isNgContent(tagName)) {
              return true;
            }

            if (schemaMetas.some(function (schema) {
              return schema.name === CUSTOM_ELEMENTS_SCHEMA.name;
            })) {
              // Allow any custom elements
              return true;
            }
          }

          return !!this._schema[tagName.toLowerCase()];
        }
        /**
         * securityContext returns the security context for the given property on the given DOM tag.
         *
         * Tag and property name are statically known and cannot change at runtime, i.e. it is not
         * possible to bind a value into a changing attribute or tag name.
         *
         * The filtering is based on a list of allowed tags|attributes. All attributes in the schema
         * above are assumed to have the 'NONE' security context, i.e. that they are safe inert
         * string values. Only specific well known attack vectors are assigned their appropriate context.
         */

      }, {
        key: "securityContext",
        value: function securityContext(tagName, propName, isAttribute) {
          if (isAttribute) {
            // NB: For security purposes, use the mapped property name, not the attribute name.
            propName = this.getMappedPropName(propName);
          } // Make sure comparisons are case insensitive, so that case differences between attribute and
          // property names do not have a security impact.


          tagName = tagName.toLowerCase();
          propName = propName.toLowerCase();
          var ctx = SECURITY_SCHEMA()[tagName + '|' + propName];

          if (ctx) {
            return ctx;
          }

          ctx = SECURITY_SCHEMA()['*|' + propName];
          return ctx ? ctx : SecurityContext.NONE;
        }
      }, {
        key: "getMappedPropName",
        value: function getMappedPropName(propName) {
          return _ATTR_TO_PROP[propName] || propName;
        }
      }, {
        key: "getDefaultComponentElementName",
        value: function getDefaultComponentElementName() {
          return 'ng-component';
        }
      }, {
        key: "validateProperty",
        value: function validateProperty(name) {
          if (name.toLowerCase().startsWith('on')) {
            var msg = "Binding to event property '".concat(name, "' is disallowed for security reasons, ") + "please use (".concat(name.slice(2), ")=...") + "\nIf '".concat(name, "' is a directive input, make sure the directive is imported by the") + " current module.";
            return {
              error: true,
              msg: msg
            };
          } else {
            return {
              error: false
            };
          }
        }
      }, {
        key: "validateAttribute",
        value: function validateAttribute(name) {
          if (name.toLowerCase().startsWith('on')) {
            var msg = "Binding to event attribute '".concat(name, "' is disallowed for security reasons, ") + "please use (".concat(name.slice(2), ")=...");
            return {
              error: true,
              msg: msg
            };
          } else {
            return {
              error: false
            };
          }
        }
      }, {
        key: "allKnownElementNames",
        value: function allKnownElementNames() {
          return Object.keys(this._schema);
        }
      }, {
        key: "normalizeAnimationStyleProperty",
        value: function normalizeAnimationStyleProperty(propName) {
          return dashCaseToCamelCase(propName);
        }
      }, {
        key: "normalizeAnimationStyleValue",
        value: function normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {
          var unit = '';
          var strVal = val.toString().trim();
          var errorMsg = null;

          if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {
            if (typeof val === 'number') {
              unit = 'px';
            } else {
              var valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);

              if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                errorMsg = "Please provide a CSS unit value for ".concat(userProvidedProp, ":").concat(val);
              }
            }
          }

          return {
            error: errorMsg,
            value: strVal + unit
          };
        }
      }]);

      return DomElementSchemaRegistry;
    }(ElementSchemaRegistry);

    function _isPixelDimensionStyle(prop) {
      switch (prop) {
        case 'width':
        case 'height':
        case 'minWidth':
        case 'minHeight':
        case 'maxWidth':
        case 'maxHeight':
        case 'left':
        case 'top':
        case 'bottom':
        case 'right':
        case 'fontSize':
        case 'outlineWidth':
        case 'outlineOffset':
        case 'paddingTop':
        case 'paddingLeft':
        case 'paddingBottom':
        case 'paddingRight':
        case 'marginTop':
        case 'marginLeft':
        case 'marginBottom':
        case 'marginRight':
        case 'borderRadius':
        case 'borderWidth':
        case 'borderTopWidth':
        case 'borderLeftWidth':
        case 'borderRightWidth':
        case 'borderBottomWidth':
        case 'textIndent':
          return true;

        default:
          return false;
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var BIND_NAME_REGEXP$1 = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/; // Group 1 = "bind-"

    var KW_BIND_IDX$1 = 1; // Group 2 = "let-"

    var KW_LET_IDX$1 = 2; // Group 3 = "ref-/#"

    var KW_REF_IDX$1 = 3; // Group 4 = "on-"

    var KW_ON_IDX$1 = 4; // Group 5 = "bindon-"

    var KW_BINDON_IDX$1 = 5; // Group 6 = "@"

    var KW_AT_IDX$1 = 6; // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"

    var IDENT_KW_IDX$1 = 7; // Group 8 = identifier inside [()]

    var IDENT_BANANA_BOX_IDX$1 = 8; // Group 9 = identifier inside []

    var IDENT_PROPERTY_IDX$1 = 9; // Group 10 = identifier inside ()

    var IDENT_EVENT_IDX$1 = 10;
    var TEMPLATE_ATTR_PREFIX$1 = '*';

    function htmlAstToRender3Ast(htmlNodes, bindingParser) {
      var transformer = new HtmlAstToIvyAst(bindingParser);
      var ivyNodes = visitAll$1(transformer, htmlNodes); // Errors might originate in either the binding parser or the html to ivy transformer

      var allErrors = bindingParser.errors.concat(transformer.errors);
      var errors = allErrors.filter(function (e) {
        return e.level === ParseErrorLevel.ERROR;
      });

      if (errors.length > 0) {
        var errorString = errors.join('\n');
        throw syntaxError("Template parse errors:\n".concat(errorString), errors);
      }

      return {
        nodes: ivyNodes,
        errors: allErrors,
        styleUrls: transformer.styleUrls,
        styles: transformer.styles
      };
    }

    var HtmlAstToIvyAst =
    /*#__PURE__*/
    function () {
      function HtmlAstToIvyAst(bindingParser) {
        _classCallCheck(this, HtmlAstToIvyAst);

        this.bindingParser = bindingParser;
        this.errors = [];
        this.styles = [];
        this.styleUrls = [];
        this.inI18nBlock = false;
      } // HTML visitor


      _createClass(HtmlAstToIvyAst, [{
        key: "visitElement",
        value: function visitElement(element) {
          var _this156 = this;

          var isI18nRootElement = isI18nRootNode(element.i18n);

          if (isI18nRootElement) {
            if (this.inI18nBlock) {
              this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);
            }

            this.inI18nBlock = true;
          }

          var preparsedElement = preparseElement(element);

          if (preparsedElement.type === PreparsedElementType.SCRIPT) {
            return null;
          } else if (preparsedElement.type === PreparsedElementType.STYLE) {
            var contents = textContents(element);

            if (contents !== null) {
              this.styles.push(contents);
            }

            return null;
          } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {
            this.styleUrls.push(preparsedElement.hrefAttr);
            return null;
          } // Whether the element is a `<ng-template>`


          var isTemplateElement = isNgTemplate(element.name);
          var parsedProperties = [];
          var boundEvents = [];
          var variables = [];
          var references = [];
          var attributes = [];
          var i18nAttrsMeta = {};
          var templateParsedProperties = [];
          var templateVariables = []; // Whether the element has any *-attribute

          var elementHasInlineTemplate = false;
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = element.attrs[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var attribute = _step8.value;
              var hasBinding = false;
              var normalizedName = normalizeAttributeName(attribute.name); // `*attr` defines template bindings

              var isTemplateBinding = false;

              if (attribute.i18n) {
                i18nAttrsMeta[attribute.name] = attribute.i18n;
              }

              if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {
                // *-attributes
                if (elementHasInlineTemplate) {
                  this.reportError("Can't have multiple template bindings on one element. Use only one attribute prefixed with *", attribute.sourceSpan);
                }

                isTemplateBinding = true;
                elementHasInlineTemplate = true;
                var templateValue = attribute.value;
                var templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);
                var parsedVariables = [];
                var absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : // If there is no value span the attribute does not have a value, like `attr` in
                //`<div attr></div>`. In this case, point to one character beyond the last character of
                // the attribute name.
                attribute.sourceSpan.start.offset + attribute.name.length;
                this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables);
                templateVariables.push.apply(templateVariables, _toConsumableArray(parsedVariables.map(function (v) {
                  return new Variable(v.name, v.value, v.sourceSpan);
                })));
              } else {
                // Check for variables, events, property bindings, interpolation
                hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);
              }

              if (!hasBinding && !isTemplateBinding) {
                // don't include the bindings as attributes as well in the AST
                attributes.push(this.visitAttribute(attribute));
              }
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }

          var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR$1 : this, element.children);
          var parsedElement;

          if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
            // `<ng-content>`
            if (element.children && !element.children.every(function (node) {
              return isEmptyTextNode(node) || isCommentNode(node);
            })) {
              this.reportError("<ng-content> element cannot have content.", element.sourceSpan);
            }

            var selector = preparsedElement.selectAttr;
            var attrs = element.attrs.map(function (attr) {
              return _this156.visitAttribute(attr);
            });
            parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);
          } else if (isTemplateElement) {
            // `<ng-template>`
            var _attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);

            parsedElement = new Template(element.name, attributes, _attrs.bound, boundEvents, [
              /* no template attributes */
            ], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
          } else {
            var _attrs2 = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);

            parsedElement = new Element(element.name, attributes, _attrs2.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
          }

          if (elementHasInlineTemplate) {
            // If this node is an inline-template (e.g. has *ngFor) then we need to create a template
            // node that contains this node.
            // Moreover, if the node is an element, then we need to hoist its attributes to the template
            // node for matching against content projection selectors.
            var _attrs3 = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);

            var templateAttrs = [];

            _attrs3.literal.forEach(function (attr) {
              return templateAttrs.push(attr);
            });

            _attrs3.bound.forEach(function (attr) {
              return templateAttrs.push(attr);
            });

            var hoistedAttrs = parsedElement instanceof Element ? {
              attributes: parsedElement.attributes,
              inputs: parsedElement.inputs,
              outputs: parsedElement.outputs
            } : {
              attributes: [],
              inputs: [],
              outputs: []
            }; // For <ng-template>s with structural directives on them, avoid passing i18n information to
            // the wrapping template to prevent unnecessary i18n instructions from being generated. The
            // necessary i18n meta information will be extracted from child elements.

            var i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n; // TODO(pk): test for this case

            parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [
              /* no references */
            ], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);
          }

          if (isI18nRootElement) {
            this.inI18nBlock = false;
          }

          return parsedElement;
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute) {
          return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.valueSpan, attribute.i18n);
        }
      }, {
        key: "visitText",
        value: function visitText(text) {
          return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(expansion) {
          var _this157 = this;

          if (!expansion.i18n) {
            // do not generate Icu in case it was created
            // outside of i18n block in a template
            return null;
          }

          if (!isI18nRootNode(expansion.i18n)) {
            throw new Error("Invalid type \"".concat(expansion.i18n.constructor, "\" for \"i18n\" property of ").concat(expansion.sourceSpan.toString(), ". Expected a \"Message\""));
          }

          var message = expansion.i18n;
          var vars = {};
          var placeholders = {}; // extract VARs from ICUs - we process them separately while
          // assembling resulting message via goog.getMsg function, since
          // we need to pass them to top-level goog.getMsg call

          Object.keys(message.placeholders).forEach(function (key) {
            var value = message.placeholders[key];

            if (key.startsWith(I18N_ICU_VAR_PREFIX)) {
              var config = _this157.bindingParser.interpolationConfig; // ICU expression is a plain string, not wrapped into start
              // and end tags, so we wrap it before passing to binding parser

              var wrapped = "".concat(config.start).concat(value).concat(config.end);
              vars[key] = _this157._visitTextWithInterpolation(wrapped, expansion.sourceSpan);
            } else {
              placeholders[key] = _this157._visitTextWithInterpolation(value, expansion.sourceSpan);
            }
          });
          return new Icu(vars, placeholders, expansion.sourceSpan, message);
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(expansionCase) {
          return null;
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment) {
          return null;
        } // convert view engine `ParsedProperty` to a format suitable for IVY

      }, {
        key: "extractAttributes",
        value: function extractAttributes(elementName, properties, i18nPropsMeta) {
          var _this158 = this;

          var bound = [];
          var literal = [];
          properties.forEach(function (prop) {
            var i18n = i18nPropsMeta[prop.name];

            if (prop.isLiteral) {
              literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, undefined, i18n));
            } else {
              // Note that validation is skipped and property mapping is disabled
              // due to the fact that we need to make sure a given prop is not an
              // input of a directive and directive matching happens at runtime.
              var bep = _this158.bindingParser.createBoundElementProperty(elementName, prop,
              /* skipValidation */
              true,
              /* mapPropertyName */
              false);

              bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));
            }
          });
          return {
            bound: bound,
            literal: literal
          };
        }
      }, {
        key: "parseAttribute",
        value: function parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
          var name = normalizeAttributeName(attribute.name);
          var value = attribute.value;
          var srcSpan = attribute.sourceSpan;
          var absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;
          var bindParts = name.match(BIND_NAME_REGEXP$1);
          var hasBinding = false;

          if (bindParts) {
            hasBinding = true;

            if (bindParts[KW_BIND_IDX$1] != null) {
              this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
            } else if (bindParts[KW_LET_IDX$1]) {
              if (isTemplateElement) {
                var identifier = bindParts[IDENT_KW_IDX$1];
                this.parseVariable(identifier, value, srcSpan, attribute.valueSpan, variables);
              } else {
                this.reportError("\"let-\" is only supported on ng-template elements.", srcSpan);
              }
            } else if (bindParts[KW_REF_IDX$1]) {
              var _identifier2 = bindParts[IDENT_KW_IDX$1];
              this.parseReference(_identifier2, value, srcSpan, attribute.valueSpan, references);
            } else if (bindParts[KW_ON_IDX$1]) {
              var events = [];
              this.bindingParser.parseEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events);
              addEvents(events, boundEvents);
            } else if (bindParts[KW_BINDON_IDX$1]) {
              this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
              this.parseAssignmentEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);
            } else if (bindParts[KW_AT_IDX$1]) {
              this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
            } else if (bindParts[IDENT_BANANA_BOX_IDX$1]) {
              this.bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
              this.parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX$1], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);
            } else if (bindParts[IDENT_PROPERTY_IDX$1]) {
              this.bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
            } else if (bindParts[IDENT_EVENT_IDX$1]) {
              var _events = [];
              this.bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX$1], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, _events);
              addEvents(_events, boundEvents);
            }
          } else {
            hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties);
          }

          return hasBinding;
        }
      }, {
        key: "_visitTextWithInterpolation",
        value: function _visitTextWithInterpolation(value, sourceSpan, i18n) {
          var valueNoNgsp = replaceNgsp(value);
          var expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);
          return expr ? new BoundText(expr, sourceSpan, i18n) : new Text(valueNoNgsp, sourceSpan);
        }
      }, {
        key: "parseVariable",
        value: function parseVariable(identifier, value, sourceSpan, valueSpan, variables) {
          if (identifier.indexOf('-') > -1) {
            this.reportError("\"-\" is not allowed in variable names", sourceSpan);
          } else if (identifier.length === 0) {
            this.reportError("Variable does not have a name", sourceSpan);
          }

          variables.push(new Variable(identifier, value, sourceSpan, valueSpan));
        }
      }, {
        key: "parseReference",
        value: function parseReference(identifier, value, sourceSpan, valueSpan, references) {
          if (identifier.indexOf('-') > -1) {
            this.reportError("\"-\" is not allowed in reference names", sourceSpan);
          } else if (identifier.length === 0) {
            this.reportError("Reference does not have a name", sourceSpan);
          }

          references.push(new Reference(identifier, value, sourceSpan, valueSpan));
        }
      }, {
        key: "parseAssignmentEvent",
        value: function parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents) {
          var events = [];
          this.bindingParser.parseEvent("".concat(name, "Change"), "".concat(expression, "=$event"), sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events);
          addEvents(events, boundEvents);
        }
      }, {
        key: "reportError",
        value: function reportError(message, sourceSpan) {
          var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;
          this.errors.push(new ParseError(sourceSpan, message, level));
        }
      }]);

      return HtmlAstToIvyAst;
    }();

    var NonBindableVisitor$1 =
    /*#__PURE__*/
    function () {
      function NonBindableVisitor$1() {
        _classCallCheck(this, NonBindableVisitor$1);
      }

      _createClass(NonBindableVisitor$1, [{
        key: "visitElement",
        value: function visitElement(ast) {
          var preparsedElement = preparseElement(ast);

          if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
            // Skipping <script> for security reasons
            // Skipping <style> and stylesheets as we already processed them
            // in the StyleCompiler
            return null;
          }

          var children = visitAll$1(this, ast.children, null);
          return new Element(ast.name, visitAll$1(this, ast.attrs),
          /* inputs */
          [],
          /* outputs */
          [], children,
          /* references */
          [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment) {
          return null;
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute) {
          return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, undefined, attribute.i18n);
        }
      }, {
        key: "visitText",
        value: function visitText(text) {
          return new Text(text.value, text.sourceSpan);
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(expansion) {
          return null;
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(expansionCase) {
          return null;
        }
      }]);

      return NonBindableVisitor$1;
    }();

    var NON_BINDABLE_VISITOR$1 = new NonBindableVisitor$1();

    function normalizeAttributeName(attrName) {
      return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
    }

    function addEvents(events, boundEvents) {
      boundEvents.push.apply(boundEvents, _toConsumableArray(events.map(function (e) {
        return BoundEvent.fromParsedEvent(e);
      })));
    }

    function isEmptyTextNode(node) {
      return node instanceof Text$3 && node.value.trim().length == 0;
    }

    function isCommentNode(node) {
      return node instanceof Comment;
    }

    function textContents(node) {
      if (node.children.length !== 1 || !(node.children[0] instanceof Text$3)) {
        return null;
      } else {
        return node.children[0].value;
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var TagType;

    (function (TagType) {
      TagType[TagType["ELEMENT"] = 0] = "ELEMENT";
      TagType[TagType["TEMPLATE"] = 1] = "TEMPLATE";
      TagType[TagType["PROJECTION"] = 2] = "PROJECTION";
    })(TagType || (TagType = {}));
    /**
     * Generates an object that is used as a shared state between parent and all child contexts.
     */


    function setupRegistry() {
      return {
        getUniqueId: getSeqNumberGenerator(),
        icus: new Map()
      };
    }
    /**
     * I18nContext is a helper class which keeps track of all i18n-related aspects
     * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.
     *
     * When we enter a nested template, the top-level context is being passed down
     * to the nested component, which uses this context to generate a child instance
     * of I18nContext class (to handle nested template) and at the end, reconciles it back
     * with the parent context.
     *
     * @param index Instruction index of i18nStart, which initiates this context
     * @param ref Reference to a translation const that represents the content if thus context
     * @param level Nestng level defined for child contexts
     * @param templateIndex Instruction index of a template which this context belongs to
     * @param meta Meta information (id, meaning, description, etc) associated with this context
     */


    var I18nContext =
    /*#__PURE__*/
    function () {
      function I18nContext(index, ref) {
        var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var templateIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var meta = arguments.length > 4 ? arguments[4] : undefined;
        var registry = arguments.length > 5 ? arguments[5] : undefined;

        _classCallCheck(this, I18nContext);

        this.index = index;
        this.ref = ref;
        this.level = level;
        this.templateIndex = templateIndex;
        this.meta = meta;
        this.registry = registry;
        this.bindings = new Set();
        this.placeholders = new Map();
        this.isEmitted = false;
        this._unresolvedCtxCount = 0;
        this._registry = registry || setupRegistry();
        this.id = this._registry.getUniqueId();
      }

      _createClass(I18nContext, [{
        key: "appendTag",
        value: function appendTag(type, node, index, closed) {
          if (node.isVoid && closed) {
            return; // ignore "close" for void tags
          }

          var ph = node.isVoid || !closed ? node.startName : node.closeName;
          var content = {
            type: type,
            index: index,
            ctx: this.id,
            isVoid: node.isVoid,
            closed: closed
          };
          updatePlaceholderMap(this.placeholders, ph, content);
        }
      }, {
        key: "getSerializedPlaceholders",
        value: function getSerializedPlaceholders() {
          var result = new Map();
          this.placeholders.forEach(function (values, key) {
            return result.set(key, values.map(serializePlaceholderValue));
          });
          return result;
        } // public API to accumulate i18n-related content

      }, {
        key: "appendBinding",
        value: function appendBinding(binding) {
          this.bindings.add(binding);
        }
      }, {
        key: "appendIcu",
        value: function appendIcu(name, ref) {
          updatePlaceholderMap(this._registry.icus, name, ref);
        }
      }, {
        key: "appendBoundText",
        value: function appendBoundText(node) {
          var _this159 = this;

          var phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);
          phs.forEach(function (values, key) {
            return updatePlaceholderMap.apply(void 0, [_this159.placeholders, key].concat(_toConsumableArray(values)));
          });
        }
      }, {
        key: "appendTemplate",
        value: function appendTemplate(node, index) {
          // add open and close tags at the same time,
          // since we process nested templates separately
          this.appendTag(TagType.TEMPLATE, node, index, false);
          this.appendTag(TagType.TEMPLATE, node, index, true);
          this._unresolvedCtxCount++;
        }
      }, {
        key: "appendElement",
        value: function appendElement(node, index, closed) {
          this.appendTag(TagType.ELEMENT, node, index, closed);
        }
      }, {
        key: "appendProjection",
        value: function appendProjection(node, index) {
          // add open and close tags at the same time,
          // since we process projected content separately
          this.appendTag(TagType.PROJECTION, node, index, false);
          this.appendTag(TagType.PROJECTION, node, index, true);
        }
        /**
         * Generates an instance of a child context based on the root one,
         * when we enter a nested template within I18n section.
         *
         * @param index Instruction index of corresponding i18nStart, which initiates this context
         * @param templateIndex Instruction index of a template which this context belongs to
         * @param meta Meta information (id, meaning, description, etc) associated with this context
         *
         * @returns I18nContext instance
         */

      }, {
        key: "forkChildContext",
        value: function forkChildContext(index, templateIndex, meta) {
          return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);
        }
        /**
         * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).
         *
         * @param context Child I18nContext instance to be reconciled with parent context.
         */

      }, {
        key: "reconcileChildContext",
        value: function reconcileChildContext(context) {
          var _this160 = this;

          // set the right context id for open and close
          // template tags, so we can use it as sub-block ids
          ['start', 'close'].forEach(function (op) {
            var key = context.meta["".concat(op, "Name")];
            var phs = _this160.placeholders.get(key) || [];
            var tag = phs.find(findTemplateFn(_this160.id, context.templateIndex));

            if (tag) {
              tag.ctx = context.id;
            }
          }); // reconcile placeholders

          var childPhs = context.placeholders;
          childPhs.forEach(function (values, key) {
            var phs = _this160.placeholders.get(key);

            if (!phs) {
              _this160.placeholders.set(key, values);

              return;
            } // try to find matching template...


            var tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));

            if (tmplIdx >= 0) {
              // ... if found - replace it with nested template content
              var isCloseTag = key.startsWith('CLOSE');
              var isTemplateTag = key.endsWith('NG-TEMPLATE');

              if (isTemplateTag) {
                // current template's content is placed before or after
                // parent template tag, depending on the open/close atrribute
                phs.splice.apply(phs, [tmplIdx + (isCloseTag ? 0 : 1), 0].concat(_toConsumableArray(values)));
              } else {
                var idx = isCloseTag ? values.length - 1 : 0;
                values[idx].tmpl = phs[tmplIdx];
                phs.splice.apply(phs, [tmplIdx, 1].concat(_toConsumableArray(values)));
              }
            } else {
              // ... otherwise just append content to placeholder value
              phs.push.apply(phs, _toConsumableArray(values));
            }

            _this160.placeholders.set(key, phs);
          });
          this._unresolvedCtxCount--;
        }
      }, {
        key: "icus",
        get: function get() {
          return this._registry.icus;
        }
      }, {
        key: "isRoot",
        get: function get() {
          return this.level === 0;
        }
      }, {
        key: "isResolved",
        get: function get() {
          return this._unresolvedCtxCount === 0;
        }
      }]);

      return I18nContext;
    }(); //
    // Helper methods
    //


    function wrap(symbol, index, contextId, closed) {
      var state = closed ? '/' : '';
      return wrapI18nPlaceholder("".concat(state).concat(symbol).concat(index), contextId);
    }

    function wrapTag(symbol, _ref13, closed) {
      var index = _ref13.index,
          ctx = _ref13.ctx,
          isVoid = _ref13.isVoid;
      return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) : wrap(symbol, index, ctx, closed);
    }

    function findTemplateFn(ctx, templateIndex) {
      return function (token) {
        return typeof token === 'object' && token.type === TagType.TEMPLATE && token.index === templateIndex && token.ctx === ctx;
      };
    }

    function serializePlaceholderValue(value) {
      var element = function element(data, closed) {
        return wrapTag('#', data, closed);
      };

      var template = function template(data, closed) {
        return wrapTag('*', data, closed);
      };

      var projection = function projection(data, closed) {
        return wrapTag('!', data, closed);
      };

      switch (value.type) {
        case TagType.ELEMENT:
          // close element tag
          if (value.closed) {
            return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');
          } // open element tag that also initiates a template


          if (value.tmpl) {
            return template(value.tmpl) + element(value) + (value.isVoid ? template(value.tmpl, true) : '');
          }

          return element(value);

        case TagType.TEMPLATE:
          return template(value, value.closed);

        case TagType.PROJECTION:
          return projection(value, value.closed);

        default:
          return value;
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var IcuSerializerVisitor =
    /*#__PURE__*/
    function () {
      function IcuSerializerVisitor() {
        _classCallCheck(this, IcuSerializerVisitor);
      }

      _createClass(IcuSerializerVisitor, [{
        key: "visitText",
        value: function visitText(text) {
          return text.value;
        }
      }, {
        key: "visitContainer",
        value: function visitContainer(container) {
          var _this161 = this;

          return container.children.map(function (child) {
            return child.visit(_this161);
          }).join('');
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu) {
          var _this162 = this;

          var strCases = Object.keys(icu.cases).map(function (k) {
            return "".concat(k, " {").concat(icu.cases[k].visit(_this162), "}");
          });
          var result = "{".concat(icu.expressionPlaceholder, ", ").concat(icu.type, ", ").concat(strCases.join(' '), "}");
          return result;
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph) {
          var _this163 = this;

          return ph.isVoid ? this.formatPh(ph.startName) : "".concat(this.formatPh(ph.startName)).concat(ph.children.map(function (child) {
            return child.visit(_this163);
          }).join('')).concat(this.formatPh(ph.closeName));
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph) {
          return this.formatPh(ph.name);
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          return this.formatPh(ph.name);
        }
      }, {
        key: "formatPh",
        value: function formatPh(value) {
          return "{".concat(formatI18nPlaceholderName(value,
          /* useCamelCase */
          false), "}");
        }
      }]);

      return IcuSerializerVisitor;
    }();

    var serializer = new IcuSerializerVisitor();

    function serializeIcuNode(icu) {
      return icu.visit(serializer);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var TAG_TO_PLACEHOLDER_NAMES = {
      'A': 'LINK',
      'B': 'BOLD_TEXT',
      'BR': 'LINE_BREAK',
      'EM': 'EMPHASISED_TEXT',
      'H1': 'HEADING_LEVEL1',
      'H2': 'HEADING_LEVEL2',
      'H3': 'HEADING_LEVEL3',
      'H4': 'HEADING_LEVEL4',
      'H5': 'HEADING_LEVEL5',
      'H6': 'HEADING_LEVEL6',
      'HR': 'HORIZONTAL_RULE',
      'I': 'ITALIC_TEXT',
      'LI': 'LIST_ITEM',
      'LINK': 'MEDIA_LINK',
      'OL': 'ORDERED_LIST',
      'P': 'PARAGRAPH',
      'Q': 'QUOTATION',
      'S': 'STRIKETHROUGH_TEXT',
      'SMALL': 'SMALL_TEXT',
      'SUB': 'SUBSTRIPT',
      'SUP': 'SUPERSCRIPT',
      'TBODY': 'TABLE_BODY',
      'TD': 'TABLE_CELL',
      'TFOOT': 'TABLE_FOOTER',
      'TH': 'TABLE_HEADER_CELL',
      'THEAD': 'TABLE_HEADER',
      'TR': 'TABLE_ROW',
      'TT': 'MONOSPACED_TEXT',
      'U': 'UNDERLINED_TEXT',
      'UL': 'UNORDERED_LIST'
    };
    /**
     * Creates unique names for placeholder with different content.
     *
     * Returns the same placeholder name when the content is identical.
     */

    var PlaceholderRegistry =
    /*#__PURE__*/
    function () {
      function PlaceholderRegistry() {
        _classCallCheck(this, PlaceholderRegistry);

        // Count the occurrence of the base name top generate a unique name
        this._placeHolderNameCounts = {}; // Maps signature to placeholder names

        this._signatureToName = {};
      }

      _createClass(PlaceholderRegistry, [{
        key: "getStartTagPlaceholderName",
        value: function getStartTagPlaceholderName(tag, attrs, isVoid) {
          var signature = this._hashTag(tag, attrs, isVoid);

          if (this._signatureToName[signature]) {
            return this._signatureToName[signature];
          }

          var upperTag = tag.toUpperCase();
          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_".concat(upperTag);

          var name = this._generateUniqueName(isVoid ? baseName : "START_".concat(baseName));

          this._signatureToName[signature] = name;
          return name;
        }
      }, {
        key: "getCloseTagPlaceholderName",
        value: function getCloseTagPlaceholderName(tag) {
          var signature = this._hashClosingTag(tag);

          if (this._signatureToName[signature]) {
            return this._signatureToName[signature];
          }

          var upperTag = tag.toUpperCase();
          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_".concat(upperTag);

          var name = this._generateUniqueName("CLOSE_".concat(baseName));

          this._signatureToName[signature] = name;
          return name;
        }
      }, {
        key: "getPlaceholderName",
        value: function getPlaceholderName(name, content) {
          var upperName = name.toUpperCase();
          var signature = "PH: ".concat(upperName, "=").concat(content);

          if (this._signatureToName[signature]) {
            return this._signatureToName[signature];
          }

          var uniqueName = this._generateUniqueName(upperName);

          this._signatureToName[signature] = uniqueName;
          return uniqueName;
        }
      }, {
        key: "getUniquePlaceholder",
        value: function getUniquePlaceholder(name) {
          return this._generateUniqueName(name.toUpperCase());
        } // Generate a hash for a tag - does not take attribute order into account

      }, {
        key: "_hashTag",
        value: function _hashTag(tag, attrs, isVoid) {
          var start = "<".concat(tag);
          var strAttrs = Object.keys(attrs).sort().map(function (name) {
            return " ".concat(name, "=").concat(attrs[name]);
          }).join('');
          var end = isVoid ? '/>' : "></".concat(tag, ">");
          return start + strAttrs + end;
        }
      }, {
        key: "_hashClosingTag",
        value: function _hashClosingTag(tag) {
          return this._hashTag("/".concat(tag), {}, false);
        }
      }, {
        key: "_generateUniqueName",
        value: function _generateUniqueName(base) {
          var seen = this._placeHolderNameCounts.hasOwnProperty(base);

          if (!seen) {
            this._placeHolderNameCounts[base] = 1;
            return base;
          }

          var id = this._placeHolderNameCounts[base];
          this._placeHolderNameCounts[base] = id + 1;
          return "".concat(base, "_").concat(id);
        }
      }]);

      return PlaceholderRegistry;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _expParser = new Parser$1(new Lexer());
    /**
     * Returns a function converting html nodes to an i18n Message given an interpolationConfig
     */


    function createI18nMessageFactory(interpolationConfig) {
      var visitor = new _I18nVisitor(_expParser, interpolationConfig);
      return function (nodes, meaning, description, customId, visitNodeFn) {
        return visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);
      };
    }

    function noopVisitNodeFn(_html, i18n) {
      return i18n;
    }

    var _I18nVisitor =
    /*#__PURE__*/
    function () {
      function _I18nVisitor(_expressionParser, _interpolationConfig) {
        _classCallCheck(this, _I18nVisitor);

        this._expressionParser = _expressionParser;
        this._interpolationConfig = _interpolationConfig;
      }

      _createClass(_I18nVisitor, [{
        key: "toI18nMessage",
        value: function toI18nMessage(nodes) {
          var meaning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          var customId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          var visitNodeFn = arguments.length > 4 ? arguments[4] : undefined;
          var context = {
            isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,
            icuDepth: 0,
            placeholderRegistry: new PlaceholderRegistry(),
            placeholderToContent: {},
            placeholderToMessage: {},
            visitNodeFn: visitNodeFn || noopVisitNodeFn
          };
          var i18nodes = visitAll$1(this, nodes, context);
          return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);
        }
      }, {
        key: "visitElement",
        value: function visitElement(el, context) {
          var children = visitAll$1(this, el.children, context);
          var attrs = {};
          el.attrs.forEach(function (attr) {
            // Do not visit the attributes, translatable ones are top-level ASTs
            attrs[attr.name] = attr.value;
          });
          var isVoid = getHtmlTagDefinition(el.name).isVoid;
          var startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
          context.placeholderToContent[startPhName] = el.sourceSpan.toString();
          var closePhName = '';

          if (!isVoid) {
            closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);
            context.placeholderToContent[closePhName] = "</".concat(el.name, ">");
          }

          var node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);
          return context.visitNodeFn(el, node);
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {
          var node = this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan, context);

          return context.visitNodeFn(attribute, node);
        }
      }, {
        key: "visitText",
        value: function visitText(text, context) {
          var node = this._visitTextWithInterpolation(text.value, text.sourceSpan, context);

          return context.visitNodeFn(text, node);
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {
          return null;
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(icu, context) {
          var _this164 = this;

          context.icuDepth++;
          var i18nIcuCases = {};
          var i18nIcu = new Icu$1(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
          icu.cases.forEach(function (caze) {
            i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) {
              return node.visit(_this164, context);
            }), caze.expSourceSpan);
          });
          context.icuDepth--;

          if (context.isIcu || context.icuDepth > 0) {
            // Returns an ICU node when:
            // - the message (vs a part of the message) is an ICU message, or
            // - the ICU message is nested.
            var expPh = context.placeholderRegistry.getUniquePlaceholder("VAR_".concat(icu.type));
            i18nIcu.expressionPlaceholder = expPh;
            context.placeholderToContent[expPh] = icu.switchValue;
            return context.visitNodeFn(icu, i18nIcu);
          } // Else returns a placeholder
          // ICU placeholders should not be replaced with their original content but with the their
          // translations.
          // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg


          var phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
          context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);
          var node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
          return context.visitNodeFn(icu, node);
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(_icuCase, _context) {
          throw new Error('Unreachable code');
        }
      }, {
        key: "_visitTextWithInterpolation",
        value: function _visitTextWithInterpolation(text, sourceSpan, context) {
          var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);

          if (!splitInterpolation) {
            // No expression, return a single text
            return new Text$1(text, sourceSpan);
          } // Return a group of text + expressions


          var nodes = [];
          var container = new Container(nodes, sourceSpan);
          var _this$_interpolationC = this._interpolationConfig,
              sDelimiter = _this$_interpolationC.start,
              eDelimiter = _this$_interpolationC.end;

          for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {
            var expression = splitInterpolation.expressions[i];
            var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';
            var phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);

            if (splitInterpolation.strings[i].length) {
              // No need to add empty strings
              nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));
            }

            nodes.push(new Placeholder(expression, phName, sourceSpan));
            context.placeholderToContent[phName] = sDelimiter + expression + eDelimiter;
          } // The last index contains no expression


          var lastStringIdx = splitInterpolation.strings.length - 1;

          if (splitInterpolation.strings[lastStringIdx].length) {
            nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));
          }

          return container;
        }
      }]);

      return _I18nVisitor;
    }();

    var _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;

    function _extractPlaceholderName(input) {
      return input.split(_CUSTOM_PH_EXP)[2];
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var setI18nRefs = function setI18nRefs(htmlNode, i18nNode) {
      if (htmlNode instanceof NodeWithI18n) {
        if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {
          // This html node represents an ICU but this is a second processing pass, and the legacy id
          // was computed in the previous pass and stored in the `i18n` property as a message.
          // We are about to wipe out that property so capture the previous message to be reused when
          // generating the message for this ICU later. See `_generateI18nMessage()`.
          i18nNode.previousMessage = htmlNode.i18n;
        }

        htmlNode.i18n = i18nNode;
      }

      return i18nNode;
    };
    /**
     * This visitor walks over HTML parse tree and converts information stored in
     * i18n-related attributes ("i18n" and "i18n-*") into i18n meta object that is
     * stored with other element's and attribute's information.
     */


    var I18nMetaVisitor =
    /*#__PURE__*/
    function () {
      function I18nMetaVisitor() {
        var interpolationConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_INTERPOLATION_CONFIG;
        var keepI18nAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var enableI18nLegacyMessageIdFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        _classCallCheck(this, I18nMetaVisitor);

        this.interpolationConfig = interpolationConfig;
        this.keepI18nAttrs = keepI18nAttrs;
        this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat; // whether visited nodes contain i18n information

        this.hasI18nMeta = false; // i18n message generation factory

        this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);
      }

      _createClass(I18nMetaVisitor, [{
        key: "_generateI18nMessage",
        value: function _generateI18nMessage(nodes) {
          var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var visitNodeFn = arguments.length > 2 ? arguments[2] : undefined;

          var _this$_parseMetadata = this._parseMetadata(meta),
              meaning = _this$_parseMetadata.meaning,
              description = _this$_parseMetadata.description,
              customId = _this$_parseMetadata.customId;

          var message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);

          this._setMessageId(message, meta);

          this._setLegacyIds(message, meta);

          return message;
        }
      }, {
        key: "visitElement",
        value: function visitElement(element) {
          if (hasI18nAttrs(element)) {
            this.hasI18nMeta = true;
            var attrs = [];
            var attrsMeta = {};
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
              for (var _iterator9 = element.attrs[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var _attr = _step9.value;

                if (_attr.name === I18N_ATTR) {
                  // root 'i18n' node attribute
                  var i18n = element.i18n || _attr.value;

                  var message = this._generateI18nMessage(element.children, i18n, setI18nRefs); // do not assign empty i18n meta


                  if (message.nodes.length) {
                    element.i18n = message;
                  }
                } else if (_attr.name.startsWith(I18N_ATTR_PREFIX)) {
                  // 'i18n-*' attributes
                  var key = _attr.name.slice(I18N_ATTR_PREFIX.length);

                  attrsMeta[key] = _attr.value;
                } else {
                  // non-i18n attributes
                  attrs.push(_attr);
                }
              } // set i18n meta for attributes

            } catch (err) {
              _didIteratorError9 = true;
              _iteratorError9 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                  _iterator9.return();
                }
              } finally {
                if (_didIteratorError9) {
                  throw _iteratorError9;
                }
              }
            }

            if (Object.keys(attrsMeta).length) {
              var _iteratorNormalCompletion10 = true;
              var _didIteratorError10 = false;
              var _iteratorError10 = undefined;

              try {
                for (var _iterator10 = attrs[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                  var attr = _step10.value;
                  var meta = attrsMeta[attr.name]; // do not create translation for empty attributes

                  if (meta !== undefined && attr.value) {
                    attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);
                  }
                }
              } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
                    _iterator10.return();
                  }
                } finally {
                  if (_didIteratorError10) {
                    throw _iteratorError10;
                  }
                }
              }
            }

            if (!this.keepI18nAttrs) {
              // update element's attributes,
              // keeping only non-i18n related ones
              element.attrs = attrs;
            }
          }

          visitAll$1(this, element.children, element.i18n);
          return element;
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(expansion, currentMessage) {
          var message;
          var meta = expansion.i18n;
          this.hasI18nMeta = true;

          if (meta instanceof IcuPlaceholder) {
            // set ICU placeholder name (e.g. "ICU_1"),
            // generated while processing root element contents,
            // so we can reference it when we output translation
            var name = meta.name;
            message = this._generateI18nMessage([expansion], meta);
            var icu = icuFromI18nMessage(message);
            icu.name = name;
          } else {
            // ICU is a top level message, try to use metadata from container element if provided via
            // `context` argument. Note: context may not be available for standalone ICUs (without
            // wrapping element), so fallback to ICU metadata in this case.
            message = this._generateI18nMessage([expansion], currentMessage || meta);
          }

          expansion.i18n = message;
          return expansion;
        }
      }, {
        key: "visitText",
        value: function visitText(text) {
          return text;
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute) {
          return attribute;
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment) {
          return comment;
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(expansionCase) {
          return expansionCase;
        }
        /**
         * Parse the general form `meta` passed into extract the explicit metadata needed to create a
         * `Message`.
         *
         * There are three possibilities for the `meta` variable
         * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.
         * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.
         * 4) other: ignore this and just process the message metadata as normal
         *
         * @param meta the bucket that holds information about the message
         * @returns the parsed metadata.
         */

      }, {
        key: "_parseMetadata",
        value: function _parseMetadata(meta) {
          return typeof meta === 'string' ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};
        }
        /**
         * Generate (or restore) message id if not specified already.
         */

      }, {
        key: "_setMessageId",
        value: function _setMessageId(message, meta) {
          if (!message.id) {
            message.id = meta instanceof Message && meta.id || decimalDigest(message);
          }
        }
        /**
         * Update the `message` with a `legacyId` if necessary.
         *
         * @param message the message whose legacy id should be set
         * @param meta information about the message being processed
         */

      }, {
        key: "_setLegacyIds",
        value: function _setLegacyIds(message, meta) {
          if (this.enableI18nLegacyMessageIdFormat) {
            message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];
          } else if (typeof meta !== 'string') {
            // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in
            // `packages/compiler/src/render3/view/template.ts`).
            // In that case we want to reuse the legacy message generated in the 1st pass (see
            // `setI18nRefs()`).
            var previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;
            message.legacyIds = previousMessage ? previousMessage.legacyIds : [];
          }
        }
      }]);

      return I18nMetaVisitor;
    }();
    /** I18n separators for metadata **/


    var I18N_MEANING_SEPARATOR = '|';
    var I18N_ID_SEPARATOR = '@@';
    /**
     * Parses i18n metas like:
     *  - "@@id",
     *  - "description[@@id]",
     *  - "meaning|description[@@id]"
     * and returns an object with parsed output.
     *
     * @param meta String that represents i18n meta
     * @returns Object with id, meaning and description fields
     */

    function parseI18nMeta() {
      var meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var customId;
      var meaning;
      var description;
      meta = meta.trim();

      if (meta) {
        var idIndex = meta.indexOf(I18N_ID_SEPARATOR);
        var descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);
        var meaningAndDesc;

        var _ref14 = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];

        var _ref15 = _slicedToArray(_ref14, 2);

        meaningAndDesc = _ref15[0];
        customId = _ref15[1];

        var _ref16 = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];

        var _ref17 = _slicedToArray(_ref16, 2);

        meaning = _ref17[0];
        description = _ref17[1];
      }

      return {
        customId: customId,
        meaning: meaning,
        description: description
      };
    } // Converts i18n meta information for a message (id, description, meaning)
    // to a JsDoc statement formatted as expected by the Closure compiler.


    function i18nMetaToDocStmt(meta) {
      var tags = [];

      if (meta.description) {
        tags.push({
          tagName: "desc"
          /* Desc */
          ,
          text: meta.description
        });
      }

      if (meta.meaning) {
        tags.push({
          tagName: "meaning"
          /* Meaning */
          ,
          text: meta.meaning
        });
      }

      return tags.length == 0 ? null : new JSDocCommentStmt(tags);
    }
    /** Closure uses `goog.getMsg(message)` to lookup translations */


    var GOOG_GET_MSG = 'goog.getMsg';

    function createGoogleGetMsgStatements(variable$1, message, closureVar, params) {
      var messageString = serializeI18nMessageForGetMsg(message);
      var args = [literal(messageString)];

      if (Object.keys(params).length) {
        args.push(mapLiteral(params, true));
      } // /**
      //  * @desc description of message
      //  * @meaning meaning of message
      //  */
      // const MSG_... = goog.getMsg(..);
      // I18N_X = MSG_...;


      var statements = [];
      var jsdocComment = i18nMetaToDocStmt(message);

      if (jsdocComment !== null) {
        statements.push(jsdocComment);
      }

      statements.push(closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl());
      statements.push(new ExpressionStatement(variable$1.set(closureVar)));
      return statements;
    }
    /**
     * This visitor walks over i18n tree and generates its string representation, including ICUs and
     * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.
     */


    var GetMsgSerializerVisitor =
    /*#__PURE__*/
    function () {
      function GetMsgSerializerVisitor() {
        _classCallCheck(this, GetMsgSerializerVisitor);
      }

      _createClass(GetMsgSerializerVisitor, [{
        key: "formatPh",
        value: function formatPh(value) {
          return "{$".concat(formatI18nPlaceholderName(value), "}");
        }
      }, {
        key: "visitText",
        value: function visitText(text) {
          return text.value;
        }
      }, {
        key: "visitContainer",
        value: function visitContainer(container) {
          var _this165 = this;

          return container.children.map(function (child) {
            return child.visit(_this165);
          }).join('');
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu) {
          return serializeIcuNode(icu);
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph) {
          var _this166 = this;

          return ph.isVoid ? this.formatPh(ph.startName) : "".concat(this.formatPh(ph.startName)).concat(ph.children.map(function (child) {
            return child.visit(_this166);
          }).join('')).concat(this.formatPh(ph.closeName));
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph) {
          return this.formatPh(ph.name);
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          return this.formatPh(ph.name);
        }
      }]);

      return GetMsgSerializerVisitor;
    }();

    var serializerVisitor$1 = new GetMsgSerializerVisitor();

    function serializeI18nMessageForGetMsg(message) {
      return message.nodes.map(function (node) {
        return node.visit(serializerVisitor$1, null);
      }).join('');
    }

    function createLocalizeStatements(variable, message, params) {
      var statements = [];

      var _serializeI18nMessage = serializeI18nMessageForLocalize(message),
          messageParts = _serializeI18nMessage.messageParts,
          placeHolders = _serializeI18nMessage.placeHolders;

      statements.push(new ExpressionStatement(variable.set(localizedString(message, messageParts, placeHolders, placeHolders.map(function (ph) {
        return params[ph];
      })))));
      return statements;
    }

    var MessagePiece = function MessagePiece(text) {
      _classCallCheck(this, MessagePiece);

      this.text = text;
    };

    var LiteralPiece =
    /*#__PURE__*/
    function (_MessagePiece) {
      _inherits(LiteralPiece, _MessagePiece);

      function LiteralPiece() {
        _classCallCheck(this, LiteralPiece);

        return _possibleConstructorReturn(this, _getPrototypeOf(LiteralPiece).apply(this, arguments));
      }

      return LiteralPiece;
    }(MessagePiece);

    var PlaceholderPiece =
    /*#__PURE__*/
    function (_MessagePiece2) {
      _inherits(PlaceholderPiece, _MessagePiece2);

      function PlaceholderPiece(name) {
        _classCallCheck(this, PlaceholderPiece);

        return _possibleConstructorReturn(this, _getPrototypeOf(PlaceholderPiece).call(this, formatI18nPlaceholderName(name,
        /* useCamelCase */
        false)));
      }

      return PlaceholderPiece;
    }(MessagePiece);
    /**
     * This visitor walks over an i18n tree, capturing literal strings and placeholders.
     *
     * The result can be used for generating the `$localize` tagged template literals.
     */


    var LocalizeSerializerVisitor =
    /*#__PURE__*/
    function () {
      function LocalizeSerializerVisitor() {
        _classCallCheck(this, LocalizeSerializerVisitor);
      }

      _createClass(LocalizeSerializerVisitor, [{
        key: "visitText",
        value: function visitText(text, context) {
          if (context[context.length - 1] instanceof LiteralPiece) {
            // Two literal pieces in a row means that there was some comment node in-between.
            context[context.length - 1].text += text.value;
          } else {
            context.push(new LiteralPiece(text.value));
          }
        }
      }, {
        key: "visitContainer",
        value: function visitContainer(container, context) {
          var _this167 = this;

          container.children.forEach(function (child) {
            return child.visit(_this167, context);
          });
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu, context) {
          context.push(new LiteralPiece(serializeIcuNode(icu)));
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, context) {
          var _this168 = this;

          context.push(new PlaceholderPiece(ph.startName));

          if (!ph.isVoid) {
            ph.children.forEach(function (child) {
              return child.visit(_this168, context);
            });
            context.push(new PlaceholderPiece(ph.closeName));
          }
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, context) {
          context.push(new PlaceholderPiece(ph.name));
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          context.push(new PlaceholderPiece(ph.name));
        }
      }]);

      return LocalizeSerializerVisitor;
    }();

    var serializerVisitor$2 = new LocalizeSerializerVisitor();
    /**
     * Serialize an i18n message into two arrays: messageParts and placeholders.
     *
     * These arrays will be used to generate `$localize` tagged template literals.
     *
     * @param message The message to be serialized.
     * @returns an object containing the messageParts and placeholders.
     */

    function serializeI18nMessageForLocalize(message) {
      var pieces = [];
      message.nodes.forEach(function (node) {
        return node.visit(serializerVisitor$2, pieces);
      });
      return processMessagePieces(pieces);
    }
    /**
     * Convert the list of serialized MessagePieces into two arrays.
     *
     * One contains the literal string pieces and the other the placeholders that will be replaced by
     * expressions when rendering `$localize` tagged template literals.
     *
     * @param pieces The pieces to process.
     * @returns an object containing the messageParts and placeholders.
     */


    function processMessagePieces(pieces) {
      var messageParts = [];
      var placeHolders = [];

      if (pieces[0] instanceof PlaceholderPiece) {
        // The first piece was a placeholder so we need to add an initial empty message part.
        messageParts.push('');
      }

      for (var i = 0; i < pieces.length; i++) {
        var part = pieces[i];

        if (part instanceof LiteralPiece) {
          messageParts.push(part.text);
        } else {
          placeHolders.push(part.text);

          if (pieces[i - 1] instanceof PlaceholderPiece) {
            // There were two placeholders in a row, so we need to add an empty message part.
            messageParts.push('');
          }
        }
      }

      if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {
        // The last piece was a placeholder so we need to add a final empty message part.
        messageParts.push('');
      }

      return {
        messageParts: messageParts,
        placeHolders: placeHolders
      };
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Selector attribute name of `<ng-content>`


    var NG_CONTENT_SELECT_ATTR$1 = 'select'; // Attribute name of `ngProjectAs`.

    var NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs'; // List of supported global targets for event listeners

    var GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers$1.resolveWindow], ['document', Identifiers$1.resolveDocument], ['body', Identifiers$1.resolveBody]]);
    var LEADING_TRIVIA_CHARS = [' ', '\n', '\r', '\t']; //  if (rf & flags) { .. }

    function renderFlagCheckIfStmt(flags, statements) {
      return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);
    }

    function prepareEventListenerParameters(eventAst) {
      var handlerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var type = eventAst.type,
          name = eventAst.name,
          target = eventAst.target,
          phase = eventAst.phase,
          handler = eventAst.handler;

      if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {
        throw new Error("Unexpected global target '".concat(target, "' defined for '").concat(name, "' event.\n        Supported list of global targets: ").concat(Array.from(GLOBAL_TARGET_RESOLVERS.keys()), "."));
      }

      var eventArgumentName = '$event';
      var implicitReceiverAccesses = new Set();
      var implicitReceiverExpr = scope === null || scope.bindingLevel === 0 ? variable(CONTEXT_NAME) : scope.getOrCreateSharedContextVar(0);
      var bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', function () {
        return error('Unexpected interpolation');
      }, eventAst.handlerSpan, implicitReceiverAccesses);
      var statements = [];

      if (scope) {
        statements.push.apply(statements, _toConsumableArray(scope.restoreViewStatement()));
        statements.push.apply(statements, _toConsumableArray(scope.variableDeclarations()));
      }

      statements.push.apply(statements, _toConsumableArray(bindingExpr.render3Stmts));
      var eventName = type === 1
      /* Animation */
      ? prepareSyntheticListenerName(name, phase) : name;
      var fnName = handlerName && sanitizeIdentifier(handlerName);
      var fnArgs = [];

      if (implicitReceiverAccesses.has(eventArgumentName)) {
        fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));
      }

      var handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);
      var params = [literal(eventName), handlerFn];

      if (target) {
        params.push(literal(false), // `useCapture` flag, defaults to `false`
        importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));
      }

      return params;
    }

    var TemplateDefinitionBuilder =
    /*#__PURE__*/
    function () {
      function TemplateDefinitionBuilder(constantPool, parentBindingScope) {
        var _this169 = this;

        var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var contextName = arguments.length > 3 ? arguments[3] : undefined;
        var i18nContext = arguments.length > 4 ? arguments[4] : undefined;
        var templateIndex = arguments.length > 5 ? arguments[5] : undefined;
        var templateName = arguments.length > 6 ? arguments[6] : undefined;
        var directiveMatcher = arguments.length > 7 ? arguments[7] : undefined;
        var directives = arguments.length > 8 ? arguments[8] : undefined;
        var pipeTypeByName = arguments.length > 9 ? arguments[9] : undefined;
        var pipes = arguments.length > 10 ? arguments[10] : undefined;

        var _namespace = arguments.length > 11 ? arguments[11] : undefined;

        var relativeContextFilePath = arguments.length > 12 ? arguments[12] : undefined;
        var i18nUseExternalIds = arguments.length > 13 ? arguments[13] : undefined;

        var _constants = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : [];

        _classCallCheck(this, TemplateDefinitionBuilder);

        this.constantPool = constantPool;
        this.level = level;
        this.contextName = contextName;
        this.i18nContext = i18nContext;
        this.templateIndex = templateIndex;
        this.templateName = templateName;
        this.directiveMatcher = directiveMatcher;
        this.directives = directives;
        this.pipeTypeByName = pipeTypeByName;
        this.pipes = pipes;
        this._namespace = _namespace;
        this.i18nUseExternalIds = i18nUseExternalIds;
        this._constants = _constants;
        this._dataIndex = 0;
        this._bindingContext = 0;
        this._prefixCode = [];
        /**
         * List of callbacks to generate creation mode instructions. We store them here as we process
         * the template so bindings in listeners are resolved only once all nodes have been visited.
         * This ensures all local refs and context variables are available for matching.
         */

        this._creationCodeFns = [];
        /**
         * List of callbacks to generate update mode instructions. We store them here as we process
         * the template so bindings are resolved only once all nodes have been visited. This ensures
         * all local refs and context variables are available for matching.
         */

        this._updateCodeFns = [];
        /** Index of the currently-selected node. */

        this._currentIndex = 0;
        /** Temporary variable declarations generated from visiting pipes, literals, etc. */

        this._tempVariables = [];
        /**
         * List of callbacks to build nested templates. Nested templates must not be visited until
         * after the parent template has finished visiting all of its nodes. This ensures that all
         * local ref bindings in nested templates are able to find local ref values if the refs
         * are defined after the template declaration.
         */

        this._nestedTemplateFns = [];
        this._unsupported = unsupported; // i18n context local to this template

        this.i18n = null; // Number of slots to reserve for pureFunctions

        this._pureFunctionSlots = 0; // Number of binding slots

        this._bindingSlots = 0; // Projection slots found in the template. Projection slots can distribute projected
        // nodes based on a selector, or can just use the wildcard selector to match
        // all nodes which aren't matching any selector.

        this._ngContentReservedSlots = []; // Number of non-default selectors found in all parent templates of this template. We need to
        // track it to properly adjust projection slot index in the `projection` instruction.

        this._ngContentSelectorsOffset = 0; // Expression that should be used as implicit receiver when converting template
        // expressions to output AST.

        this._implicitReceiverExpr = null; // These should be handled in the template or element directly.

        this.visitReference = invalid$1;
        this.visitVariable = invalid$1;
        this.visitTextAttribute = invalid$1;
        this.visitBoundAttribute = invalid$1;
        this.visitBoundEvent = invalid$1;
        this._bindingScope = parentBindingScope.nestedScope(level); // Turn the relative context file path into an identifier by replacing non-alphanumeric
        // characters with underscores.

        this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';
        this._valueConverter = new ValueConverter(constantPool, function () {
          return _this169.allocateDataSlot();
        }, function (numSlots) {
          return _this169.allocatePureFunctionSlots(numSlots);
        }, function (name, localName, slot, value) {
          var pipeType = pipeTypeByName.get(name);

          if (pipeType) {
            _this169.pipes.add(pipeType);
          }

          _this169._bindingScope.set(_this169.level, localName, value);

          _this169.creationInstruction(null, Identifiers$1.pipe, [literal(slot), literal(name)]);
        });
      }

      _createClass(TemplateDefinitionBuilder, [{
        key: "buildTemplateFunction",
        value: function buildTemplateFunction(nodes, variables) {
          var _this170 = this;

          var ngContentSelectorsOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var i18n = arguments.length > 3 ? arguments[3] : undefined;
          this._ngContentSelectorsOffset = ngContentSelectorsOffset;

          if (this._namespace !== Identifiers$1.namespaceHTML) {
            this.creationInstruction(null, this._namespace);
          } // Create variable bindings


          variables.forEach(function (v) {
            return _this170.registerContextVariables(v);
          }); // Initiate i18n context in case:
          // - this template has parent i18n context
          // - or the template has i18n meta associated with it,
          //   but it's not initiated by the Element (e.g. <ng-template i18n>)

          var initI18nContext = this.i18nContext || isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) && !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n);
          var selfClosingI18nInstruction = hasTextChildrenOnly(nodes);

          if (initI18nContext) {
            this.i18nStart(null, i18n, selfClosingI18nInstruction);
          } // This is the initial pass through the nodes of this template. In this pass, we
          // queue all creation mode and update mode instructions for generation in the second
          // pass. It's necessary to separate the passes to ensure local refs are defined before
          // resolving bindings. We also count bindings in this pass as we walk bound expressions.


          visitAll(this, nodes); // Add total binding count to pure function count so pure function instructions are
          // generated with the correct slot offset when update instructions are processed.

          this._pureFunctionSlots += this._bindingSlots; // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and
          // `pipeBind` update instructions), so we have to update the slot offsets manually
          // to account for bindings.

          this._valueConverter.updatePipeSlotOffsets(this._bindingSlots); // Nested templates must be processed before creation instructions so template()
          // instructions can be generated with the correct internal const count.


          this._nestedTemplateFns.forEach(function (buildTemplateFn) {
            return buildTemplateFn();
          }); // Output the `projectionDef` instruction when some `<ng-content>` tags are present.
          // The `projectionDef` instruction is only emitted for the component template and
          // is skipped for nested templates (<ng-template> tags).


          if (this.level === 0 && this._ngContentReservedSlots.length) {
            var parameters = []; // By default the `projectionDef` instructions creates one slot for the wildcard
            // selector if no parameters are passed. Therefore we only want to allocate a new
            // array for the projection slots if the default projection slot is not sufficient.

            if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {
              var r3ReservedSlots = this._ngContentReservedSlots.map(function (s) {
                return s !== '*' ? parseSelectorToR3Selector(s) : s;
              });

              parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));
            } // Since we accumulate ngContent selectors while processing template elements,
            // we *prepend* `projectionDef` to creation instructions block, to put it before
            // any `projection` instructions


            this.creationInstruction(null, Identifiers$1.projectionDef, parameters,
            /* prepend */
            true);
          }

          if (initI18nContext) {
            this.i18nEnd(null, selfClosingI18nInstruction);
          } // Generate all the creation mode instructions (e.g. resolve bindings in listeners)


          var creationStatements = this._creationCodeFns.map(function (fn) {
            return fn();
          }); // Generate all the update mode instructions (e.g. resolve property or text bindings)


          var updateStatements = this._updateCodeFns.map(function (fn) {
            return fn();
          }); //  Variable declaration must occur after binding resolution so we can generate context
          //  instructions that build on each other.
          // e.g. const b = nextContext().$implicit(); const b = nextContext();


          var creationVariables = this._bindingScope.viewSnapshotStatements();

          var updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);

          var creationBlock = creationStatements.length > 0 ? [renderFlagCheckIfStmt(1
          /* Create */
          , creationVariables.concat(creationStatements))] : [];
          var updateBlock = updateStatements.length > 0 ? [renderFlagCheckIfStmt(2
          /* Update */
          , updateVariables.concat(updateStatements))] : [];
          return fn( // i.e. (rf: RenderFlags, ctx: any)
          [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [].concat(_toConsumableArray(this._prefixCode), creationBlock, updateBlock), INFERRED_TYPE, null, this.templateName);
        } // LocalResolver

      }, {
        key: "getLocal",
        value: function getLocal(name) {
          return this._bindingScope.get(name);
        } // LocalResolver

      }, {
        key: "notifyImplicitReceiverUse",
        value: function notifyImplicitReceiverUse() {
          this._bindingScope.notifyImplicitReceiverUse();
        }
      }, {
        key: "i18nTranslate",
        value: function i18nTranslate(message) {
          var _this$constantPool$st;

          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var ref = arguments.length > 2 ? arguments[2] : undefined;
          var transformFn = arguments.length > 3 ? arguments[3] : undefined;

          var _ref = ref || variable(this.constantPool.uniqueName(TRANSLATION_PREFIX)); // Closure Compiler requires const names to start with `MSG_` but disallows any other const to
          // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call


          var closureVar = this.i18nGenerateClosureVar(message.id);
          var statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);

          (_this$constantPool$st = this.constantPool.statements).push.apply(_this$constantPool$st, _toConsumableArray(statements));

          return _ref;
        }
      }, {
        key: "registerContextVariables",
        value: function registerContextVariables(variable$1) {
          var scopedName = this._bindingScope.freshReferenceName();

          var retrievalLevel = this.level;
          var lhs = variable(variable$1.name + scopedName);

          this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1
          /* CONTEXT */
          , function (scope, relativeLevel) {
            var rhs;

            if (scope.bindingLevel === retrievalLevel) {
              // e.g. ctx
              rhs = variable(CONTEXT_NAME);
            } else {
              var sharedCtxVar = scope.getSharedContextName(retrievalLevel); // e.g. ctx_r0   OR  x(2);

              rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);
            } // e.g. const $item$ = x(2).$implicit;


            return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];
          });
        }
      }, {
        key: "i18nAppendBindings",
        value: function i18nAppendBindings(expressions) {
          var _this171 = this;

          if (expressions.length > 0) {
            expressions.forEach(function (expression) {
              return _this171.i18n.appendBinding(expression);
            });
          }
        }
      }, {
        key: "i18nBindProps",
        value: function i18nBindProps(props) {
          var _this172 = this;

          var bound = {};
          Object.keys(props).forEach(function (key) {
            var prop = props[key];

            if (prop instanceof Text) {
              bound[key] = literal(prop.value);
            } else {
              var value = prop.value.visit(_this172._valueConverter);

              _this172.allocateBindingSlots(value);

              if (value instanceof Interpolation) {
                var strings = value.strings,
                    expressions = value.expressions;
                var _this172$i18n = _this172.i18n,
                    id = _this172$i18n.id,
                    bindings = _this172$i18n.bindings;
                var label = assembleI18nBoundString(strings, bindings.size, id);

                _this172.i18nAppendBindings(expressions);

                bound[key] = literal(label);
              }
            }
          });
          return bound;
        }
      }, {
        key: "i18nGenerateClosureVar",
        value: function i18nGenerateClosureVar(messageId) {
          var name;
          var suffix = this.fileBasedI18nSuffix.toUpperCase();

          if (this.i18nUseExternalIds) {
            var prefix = getTranslationConstPrefix("EXTERNAL_");
            var uniqueSuffix = this.constantPool.uniqueName(suffix);
            name = "".concat(prefix).concat(sanitizeIdentifier(messageId), "$$").concat(uniqueSuffix);
          } else {
            var _prefix = getTranslationConstPrefix(suffix);

            name = this.constantPool.uniqueName(_prefix);
          }

          return variable(name);
        }
      }, {
        key: "i18nUpdateRef",
        value: function i18nUpdateRef(context) {
          var icus = context.icus,
              meta = context.meta,
              isRoot = context.isRoot,
              isResolved = context.isResolved,
              isEmitted = context.isEmitted;

          if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {
            context.isEmitted = true;
            var placeholders = context.getSerializedPlaceholders();
            var icuMapping = {};
            var params = placeholders.size ? placeholdersToParams(placeholders) : {};

            if (icus.size) {
              icus.forEach(function (refs, key) {
                if (refs.length === 1) {
                  // if we have one ICU defined for a given
                  // placeholder - just output its reference
                  params[key] = refs[0];
                } else {
                  // ... otherwise we need to activate post-processing
                  // to replace ICU placeholders with proper values
                  var placeholder = wrapI18nPlaceholder("".concat(I18N_ICU_MAPPING_PREFIX).concat(key));
                  params[key] = literal(placeholder);
                  icuMapping[key] = literalArr(refs);
                }
              });
            } // translation requires post processing in 2 cases:
            // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])
            // - if we have multiple ICUs that refer to the same placeholder name


            var needsPostprocessing = Array.from(placeholders.values()).some(function (value) {
              return value.length > 1;
            }) || Object.keys(icuMapping).length;
            var transformFn;

            if (needsPostprocessing) {
              transformFn = function transformFn(raw) {
                var args = [raw];

                if (Object.keys(icuMapping).length) {
                  args.push(mapLiteral(icuMapping, true));
                }

                return instruction(null, Identifiers$1.i18nPostprocess, args);
              };
            }

            this.i18nTranslate(meta, params, context.ref, transformFn);
          }
        }
      }, {
        key: "i18nStart",
        value: function i18nStart() {
          var span = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var meta = arguments.length > 1 ? arguments[1] : undefined;
          var selfClosing = arguments.length > 2 ? arguments[2] : undefined;
          var index = this.allocateDataSlot();

          if (this.i18nContext) {
            this.i18n = this.i18nContext.forkChildContext(index, this.templateIndex, meta);
          } else {
            var _ref18 = variable(this.constantPool.uniqueName(TRANSLATION_PREFIX));

            this.i18n = new I18nContext(index, _ref18, 0, this.templateIndex, meta);
          } // generate i18nStart instruction


          var _this$i18n = this.i18n,
              id = _this$i18n.id,
              ref = _this$i18n.ref;
          var params = [literal(index), ref];

          if (id > 0) {
            // do not push 3rd argument (sub-block id)
            // into i18nStart call for top level i18n context
            params.push(literal(id));
          }

          this.creationInstruction(span, selfClosing ? Identifiers$1.i18n : Identifiers$1.i18nStart, params);
        }
      }, {
        key: "i18nEnd",
        value: function i18nEnd() {
          var _this173 = this;

          var span = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var selfClosing = arguments.length > 1 ? arguments[1] : undefined;

          if (!this.i18n) {
            throw new Error('i18nEnd is executed with no i18n context present');
          }

          if (this.i18nContext) {
            this.i18nContext.reconcileChildContext(this.i18n);
            this.i18nUpdateRef(this.i18nContext);
          } else {
            this.i18nUpdateRef(this.i18n);
          } // setup accumulated bindings


          var _this$i18n2 = this.i18n,
              index = _this$i18n2.index,
              bindings = _this$i18n2.bindings;

          if (bindings.size) {
            var chainBindings = [];
            bindings.forEach(function (binding) {
              chainBindings.push({
                sourceSpan: span,
                value: function value() {
                  return _this173.convertPropertyBinding(binding);
                }
              });
            }); // for i18n block, advance to the most recent element index (by taking the current number of
            // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the
            // necessary lifecycle hooks of components/directives are properly flushed.

            this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers$1.i18nExp, chainBindings);
            this.updateInstruction(span, Identifiers$1.i18nApply, [literal(index)]);
          }

          if (!selfClosing) {
            this.creationInstruction(span, Identifiers$1.i18nEnd);
          }

          this.i18n = null; // reset local i18n context
        }
      }, {
        key: "getNamespaceInstruction",
        value: function getNamespaceInstruction(namespaceKey) {
          switch (namespaceKey) {
            case 'math':
              return Identifiers$1.namespaceMathML;

            case 'svg':
              return Identifiers$1.namespaceSVG;

            default:
              return Identifiers$1.namespaceHTML;
          }
        }
      }, {
        key: "addNamespaceInstruction",
        value: function addNamespaceInstruction(nsInstruction, element) {
          this._namespace = nsInstruction;
          this.creationInstruction(element.sourceSpan, nsInstruction);
        }
        /**
         * Adds an update instruction for an interpolated property or attribute, such as
         * `prop="{{value}}"` or `attr.title="{{value}}"`
         */

      }, {
        key: "interpolatedUpdateInstruction",
        value: function interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {
          var _this174 = this;

          this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, function () {
            return [literal(attrName)].concat(_toConsumableArray(_this174.getUpdateInstructionArguments(value)), _toConsumableArray(params));
          });
        }
      }, {
        key: "visitContent",
        value: function visitContent(ngContent) {
          var slot = this.allocateDataSlot();
          var projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;
          var parameters = [literal(slot)];

          this._ngContentReservedSlots.push(ngContent.selector);

          var nonContentSelectAttributes = ngContent.attributes.filter(function (attr) {
            return attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1;
          });
          var attributes = this.getAttributeExpressions(nonContentSelectAttributes, [], []);

          if (attributes.length > 0) {
            parameters.push(literal(projectionSlotIdx), literalArr(attributes));
          } else if (projectionSlotIdx !== 0) {
            parameters.push(literal(projectionSlotIdx));
          }

          this.creationInstruction(ngContent.sourceSpan, Identifiers$1.projection, parameters);

          if (this.i18n) {
            this.i18n.appendProjection(ngContent.i18n, slot);
          }
        }
      }, {
        key: "visitElement",
        value: function visitElement(element) {
          var _this175 = this;

          var elementIndex = this.allocateDataSlot();
          var stylingBuilder = new StylingBuilder(null);
          var isNonBindableMode = false;
          var isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);
          var i18nAttrs = [];
          var outputAttrs = [];

          var _splitNsName = splitNsName(element.name),
              _splitNsName2 = _slicedToArray(_splitNsName, 2),
              namespaceKey = _splitNsName2[0],
              elementName = _splitNsName2[1];

          var isNgContainer$1 = isNgContainer(element.name); // Handle styling, i18n, ngNonBindable attributes

          var _iteratorNormalCompletion11 = true;
          var _didIteratorError11 = false;
          var _iteratorError11 = undefined;

          try {
            for (var _iterator11 = element.attributes[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
              var attr = _step11.value;
              var name = attr.name,
                  value = attr.value;

              if (name === NON_BINDABLE_ATTR) {
                isNonBindableMode = true;
              } else if (name === 'style') {
                stylingBuilder.registerStyleAttr(value);
              } else if (name === 'class') {
                stylingBuilder.registerClassAttr(value);
              } else {
                if (attr.i18n) {
                  // Place attributes into a separate array for i18n processing, but also keep such
                  // attributes in the main list to make them available for directive matching at runtime.
                  // TODO(FW-1248): prevent attributes duplication in `i18nAttributes` and `elementStart`
                  // arguments
                  i18nAttrs.push(attr);
                } else {
                  outputAttrs.push(attr);
                }
              }
            } // Match directives on non i18n attributes

          } catch (err) {
            _didIteratorError11 = true;
            _iteratorError11 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
                _iterator11.return();
              }
            } finally {
              if (_didIteratorError11) {
                throw _iteratorError11;
              }
            }
          }

          this.matchDirectives(element.name, element); // Regular element or ng-container creation mode

          var parameters = [literal(elementIndex)];

          if (!isNgContainer$1) {
            parameters.push(literal(elementName));
          } // Add the attributes


          var allOtherInputs = [];
          element.inputs.forEach(function (input) {
            var stylingInputWasSet = stylingBuilder.registerBoundInput(input);

            if (!stylingInputWasSet) {
              if (input.type === 0
              /* Property */
              && input.i18n) {
                // Place attributes into a separate array for i18n processing, but also keep such
                // attributes in the main list to make them available for directive matching at runtime.
                // TODO(FW-1248): prevent attributes duplication in `i18nAttributes` and `elementStart`
                // arguments
                i18nAttrs.push(input);
              } else {
                allOtherInputs.push(input);
              }
            }
          }); // add attributes for directive and projection matching purposes

          var attributes = this.getAttributeExpressions(outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], i18nAttrs);
          parameters.push(this.addAttrsToConsts(attributes)); // local refs (ex.: <div #foo #bar="baz">)

          var refs = this.prepareRefsArray(element.references);
          parameters.push(this.addToConsts(refs));
          var wasInNamespace = this._namespace;
          var currentNamespace = this.getNamespaceInstruction(namespaceKey); // If the namespace is changing now, include an instruction to change it
          // during element creation.

          if (currentNamespace !== wasInNamespace) {
            this.addNamespaceInstruction(currentNamespace, element);
          }

          if (this.i18n) {
            this.i18n.appendElement(element.i18n, elementIndex);
          } // Note that we do not append text node instructions and ICUs inside i18n section,
          // so we exclude them while calculating whether current element has children


          var hasChildren = !isI18nRootElement && this.i18n ? !hasTextChildrenOnly(element.children) : element.children.length > 0;
          var createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes && element.outputs.length === 0 && i18nAttrs.length === 0 && !hasChildren;
          var createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);

          if (createSelfClosingInstruction) {
            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainer : Identifiers$1.element, trimTrailingNulls(parameters));
          } else {
            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainerStart : Identifiers$1.elementStart, trimTrailingNulls(parameters));

            if (isNonBindableMode) {
              this.creationInstruction(element.sourceSpan, Identifiers$1.disableBindings);
            } // process i18n element attributes


            if (i18nAttrs.length) {
              var hasBindings = false;
              var i18nAttrArgs = [];
              var bindings = [];
              i18nAttrs.forEach(function (attr) {
                var message = attr.i18n;

                if (attr instanceof TextAttribute) {
                  i18nAttrArgs.push(literal(attr.name), _this175.i18nTranslate(message));
                } else {
                  var converted = attr.value.visit(_this175._valueConverter);

                  _this175.allocateBindingSlots(converted);

                  if (converted instanceof Interpolation) {
                    var placeholders = assembleBoundTextPlaceholders(message);
                    var params = placeholdersToParams(placeholders);
                    i18nAttrArgs.push(literal(attr.name), _this175.i18nTranslate(message, params));
                    converted.expressions.forEach(function (expression) {
                      hasBindings = true;
                      bindings.push({
                        sourceSpan: element.sourceSpan,
                        value: function value() {
                          return _this175.convertPropertyBinding(expression);
                        }
                      });
                    });
                  }
                }
              });

              if (bindings.length) {
                this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.i18nExp, bindings);
              }

              if (i18nAttrArgs.length) {
                var index = literal(this.allocateDataSlot());
                var args = this.constantPool.getConstLiteral(literalArr(i18nAttrArgs), true);
                this.creationInstruction(element.sourceSpan, Identifiers$1.i18nAttributes, [index, args]);

                if (hasBindings) {
                  this.updateInstruction(element.sourceSpan, Identifiers$1.i18nApply, [index]);
                }
              }
            } // Generate Listeners (outputs)


            if (element.outputs.length > 0) {
              var listeners = element.outputs.map(function (outputAst) {
                return {
                  sourceSpan: outputAst.sourceSpan,
                  params: _this175.prepareListenerParameter(element.name, outputAst, elementIndex)
                };
              });
              this.creationInstructionChain(Identifiers$1.listener, listeners);
            } // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and
            // listeners, to make sure i18nAttributes instruction targets current element at runtime.


            if (isI18nRootElement) {
              this.i18nStart(element.sourceSpan, element.i18n, createSelfClosingI18nInstruction);
            }
          } // the code here will collect all update-level styling instructions and add them to the
          // update block of the template function AOT code. Instructions like `styleProp`,
          // `styleMap`, `classMap`, `classProp`
          // are all generated and assigned in the code below.


          var stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);
          var limit = stylingInstructions.length - 1;

          for (var i = 0; i <= limit; i++) {
            var _instruction = stylingInstructions[i];
            this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, _instruction);
          } // the reason why `undefined` is used is because the renderer understands this as a
          // special value to symbolize that there is no RHS to this binding
          // TODO (matsko): revisit this once FW-959 is approached


          var emptyValueBindInstruction = literal(undefined);
          var propertyBindings = [];
          var attributeBindings = []; // Generate element input bindings

          allOtherInputs.forEach(function (input) {
            var inputType = input.type;

            if (inputType === 4
            /* Animation */
            ) {
                var _value2 = input.value.visit(_this175._valueConverter); // animation bindings can be presented in the following formats:
                // 1. [@binding]="fooExp"
                // 2. [@binding]="{value:fooExp, params:{...}}"
                // 3. [@binding]
                // 4. @binding
                // All formats will be valid for when a synthetic binding is created.
                // The reasoning for this is because the renderer should get each
                // synthetic binding value in the order of the array that they are
                // defined in...


                var hasValue = _value2 instanceof LiteralPrimitive ? !!_value2.value : true;

                _this175.allocateBindingSlots(_value2);

                propertyBindings.push({
                  name: prepareSyntheticPropertyName(input.name),
                  sourceSpan: input.sourceSpan,
                  value: function value() {
                    return hasValue ? _this175.convertPropertyBinding(_value2) : emptyValueBindInstruction;
                  }
                });
              } else {
              // we must skip attributes with associated i18n context, since these attributes are handled
              // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated
              if (input.i18n) return;

              var _value3 = input.value.visit(_this175._valueConverter);

              if (_value3 !== undefined) {
                var params = [];

                var _splitNsName3 = splitNsName(input.name),
                    _splitNsName4 = _slicedToArray(_splitNsName3, 2),
                    attrNamespace = _splitNsName4[0],
                    attrName = _splitNsName4[1];

                var isAttributeBinding = inputType === 1
                /* Attribute */
                ;
                var sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);
                if (sanitizationRef) params.push(sanitizationRef);

                if (attrNamespace) {
                  var namespaceLiteral = literal(attrNamespace);

                  if (sanitizationRef) {
                    params.push(namespaceLiteral);
                  } else {
                    // If there wasn't a sanitization ref, we need to add
                    // an extra param so that we can pass in the namespace.
                    params.push(literal(null), namespaceLiteral);
                  }
                }

                _this175.allocateBindingSlots(_value3);

                if (inputType === 0
                /* Property */
                ) {
                    if (_value3 instanceof Interpolation) {
                      // prop="{{value}}" and friends
                      _this175.interpolatedUpdateInstruction(getPropertyInterpolationExpression(_value3), elementIndex, attrName, input, _value3, params);
                    } else {
                      // [prop]="value"
                      // Collect all the properties so that we can chain into a single function at the end.
                      propertyBindings.push({
                        name: attrName,
                        sourceSpan: input.sourceSpan,
                        value: function value() {
                          return _this175.convertPropertyBinding(_value3);
                        },
                        params: params
                      });
                    }
                  } else if (inputType === 1
                /* Attribute */
                ) {
                    if (_value3 instanceof Interpolation && getInterpolationArgsLength(_value3) > 1) {
                      // attr.name="text{{value}}" and friends
                      _this175.interpolatedUpdateInstruction(getAttributeInterpolationExpression(_value3), elementIndex, attrName, input, _value3, params);
                    } else {
                      var boundValue = _value3 instanceof Interpolation ? _value3.expressions[0] : _value3; // [attr.name]="value" or attr.name="{{value}}"
                      // Collect the attribute bindings so that they can be chained at the end.

                      attributeBindings.push({
                        name: attrName,
                        sourceSpan: input.sourceSpan,
                        value: function value() {
                          return _this175.convertPropertyBinding(boundValue);
                        },
                        params: params
                      });
                    }
                  } else {
                  // class prop
                  _this175.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers$1.classProp, function () {
                    return [literal(elementIndex), literal(attrName), _this175.convertPropertyBinding(_value3)].concat(params);
                  });
                }
              }
            }
          });

          if (propertyBindings.length > 0) {
            this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.property, propertyBindings);
          }

          if (attributeBindings.length > 0) {
            this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.attribute, attributeBindings);
          } // Traverse element child nodes


          visitAll(this, element.children);

          if (!isI18nRootElement && this.i18n) {
            this.i18n.appendElement(element.i18n, elementIndex, true);
          }

          if (!createSelfClosingInstruction) {
            // Finish element construction mode.
            var span = element.endSourceSpan || element.sourceSpan;

            if (isI18nRootElement) {
              this.i18nEnd(span, createSelfClosingI18nInstruction);
            }

            if (isNonBindableMode) {
              this.creationInstruction(span, Identifiers$1.enableBindings);
            }

            this.creationInstruction(span, isNgContainer$1 ? Identifiers$1.elementContainerEnd : Identifiers$1.elementEnd);
          }
        }
      }, {
        key: "visitTemplate",
        value: function visitTemplate(template) {
          var _this176 = this;

          var NG_TEMPLATE_TAG_NAME = 'ng-template';
          var templateIndex = this.allocateDataSlot();

          if (this.i18n) {
            this.i18n.appendTemplate(template.i18n, templateIndex);
          }

          var tagName = sanitizeIdentifier(template.tagName || '');
          var contextName = "".concat(this.contextName).concat(tagName ? '_' + tagName : '', "_").concat(templateIndex);
          var templateName = "".concat(contextName, "_Template");
          var parameters = [literal(templateIndex), variable(templateName), // We don't care about the tag's namespace here, because we infer
          // it based on the parent nodes inside the template instruction.
          literal(template.tagName ? splitNsName(template.tagName)[1] : template.tagName)]; // find directives matching on a given <ng-template> node

          this.matchDirectives(NG_TEMPLATE_TAG_NAME, template); // prepare attributes parameter (including attributes used for directive matching)

          var attrsExprs = this.getAttributeExpressions(template.attributes, template.inputs, template.outputs, undefined, template.templateAttrs, undefined);
          parameters.push(this.addAttrsToConsts(attrsExprs)); // local refs (ex.: <ng-template #foo>)

          if (template.references && template.references.length) {
            var refs = this.prepareRefsArray(template.references);
            parameters.push(this.addToConsts(refs));
            parameters.push(importExpr(Identifiers$1.templateRefExtractor));
          } // Create the template function


          var templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants); // Nested templates must not be visited until after their parent templates have completed
          // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't
          // be able to support bindings in nested templates to local refs that occur after the
          // template definition. e.g. <div *ngIf="showing">{{ foo }}</div>  <div #foo></div>

          this._nestedTemplateFns.push(function () {
            var templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, _this176._ngContentReservedSlots.length + _this176._ngContentSelectorsOffset, template.i18n);

            _this176.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName, null));

            if (templateVisitor._ngContentReservedSlots.length) {
              var _this176$_ngContentRe;

              (_this176$_ngContentRe = _this176._ngContentReservedSlots).push.apply(_this176$_ngContentRe, _toConsumableArray(templateVisitor._ngContentReservedSlots));
            }
          }); // e.g. template(1, MyComp_Template_1)


          this.creationInstruction(template.sourceSpan, Identifiers$1.templateCreate, function () {
            parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));
            return trimTrailingNulls(parameters);
          }); // handle property bindings e.g. ɵɵproperty('ngForOf', ctx.items), et al;

          this.templatePropertyBindings(templateIndex, template.templateAttrs); // Only add normal input/output binding instructions on explicit ng-template elements.

          if (template.tagName === NG_TEMPLATE_TAG_NAME) {
            // Add the input bindings
            this.templatePropertyBindings(templateIndex, template.inputs); // Generate listeners for directive output

            if (template.outputs.length > 0) {
              var listeners = template.outputs.map(function (outputAst) {
                return {
                  sourceSpan: outputAst.sourceSpan,
                  params: _this176.prepareListenerParameter('ng_template', outputAst, templateIndex)
                };
              });
              this.creationInstructionChain(Identifiers$1.listener, listeners);
            }
          }
        }
      }, {
        key: "visitBoundText",
        value: function visitBoundText(text) {
          var _this177 = this;

          if (this.i18n) {
            var _value4 = text.value.visit(this._valueConverter);

            this.allocateBindingSlots(_value4);

            if (_value4 instanceof Interpolation) {
              this.i18n.appendBoundText(text.i18n);
              this.i18nAppendBindings(_value4.expressions);
            }

            return;
          }

          var nodeIndex = this.allocateDataSlot();
          this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(nodeIndex)]);
          var value = text.value.visit(this._valueConverter);
          this.allocateBindingSlots(value);

          if (value instanceof Interpolation) {
            this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), function () {
              return _this177.getUpdateInstructionArguments(value);
            });
          } else {
            error('Text nodes should be interpolated and never bound directly.');
          }
        }
      }, {
        key: "visitText",
        value: function visitText(text) {
          // when a text element is located within a translatable
          // block, we exclude this text element from instructions set,
          // since it will be captured in i18n content and processed at runtime
          if (!this.i18n) {
            this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(this.allocateDataSlot()), literal(text.value)]);
          }
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu) {
          var initWasInvoked = false; // if an ICU was created outside of i18n block, we still treat
          // it as a translatable entity and invoke i18nStart and i18nEnd
          // to generate i18n context and the necessary instructions

          if (!this.i18n) {
            initWasInvoked = true;
            this.i18nStart(null, icu.i18n, true);
          }

          var i18n = this.i18n;
          var vars = this.i18nBindProps(icu.vars);
          var placeholders = this.i18nBindProps(icu.placeholders); // output ICU directly and keep ICU reference in context

          var message = icu.i18n; // we always need post-processing function for ICUs, to make sure that:
          // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:
          // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders
          // inside ICUs)
          // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values

          var transformFn = function transformFn(raw) {
            var params = Object.assign(Object.assign({}, vars), placeholders);
            var formatted = i18nFormatPlaceholderNames(params,
            /* useCamelCase */
            false);
            return instruction(null, Identifiers$1.i18nPostprocess, [raw, mapLiteral(formatted, true)]);
          }; // in case the whole i18n message is a single ICU - we do not need to
          // create a separate top-level translation, we can use the root ref instead
          // and make this ICU a top-level translation
          // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function
          // separately, so we do not pass placeholders into `i18nTranslate` function.


          if (isSingleI18nIcu(i18n.meta)) {
            this.i18nTranslate(message,
            /* placeholders */
            {}, i18n.ref, transformFn);
          } else {
            // output ICU directly and keep ICU reference in context
            var ref = this.i18nTranslate(message,
            /* placeholders */
            {},
            /* ref */
            undefined, transformFn);
            i18n.appendIcu(icuFromI18nMessage(message).name, ref);
          }

          if (initWasInvoked) {
            this.i18nEnd(null, true);
          }

          return null;
        }
      }, {
        key: "allocateDataSlot",
        value: function allocateDataSlot() {
          return this._dataIndex++;
        }
      }, {
        key: "getConstCount",
        value: function getConstCount() {
          return this._dataIndex;
        }
      }, {
        key: "getVarCount",
        value: function getVarCount() {
          return this._pureFunctionSlots;
        }
      }, {
        key: "getConsts",
        value: function getConsts() {
          return this._constants;
        }
      }, {
        key: "getNgContentSelectors",
        value: function getNgContentSelectors() {
          return this._ngContentReservedSlots.length ? this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) : null;
        }
      }, {
        key: "bindingContext",
        value: function bindingContext() {
          return "".concat(this._bindingContext++);
        }
      }, {
        key: "templatePropertyBindings",
        value: function templatePropertyBindings(templateIndex, attrs) {
          var _this178 = this;

          var propertyBindings = [];
          attrs.forEach(function (input) {
            if (input instanceof BoundAttribute) {
              var _value5 = input.value.visit(_this178._valueConverter);

              if (_value5 !== undefined) {
                _this178.allocateBindingSlots(_value5);

                propertyBindings.push({
                  name: input.name,
                  sourceSpan: input.sourceSpan,
                  value: function value() {
                    return _this178.convertPropertyBinding(_value5);
                  }
                });
              }
            }
          });

          if (propertyBindings.length > 0) {
            this.updateInstructionChainWithAdvance(templateIndex, Identifiers$1.property, propertyBindings);
          }
        } // Bindings must only be resolved after all local refs have been visited, so all
        // instructions are queued in callbacks that execute once the initial pass has completed.
        // Otherwise, we wouldn't be able to support local refs that are defined after their
        // bindings. e.g. {{ foo }} <div #foo></div>

      }, {
        key: "instructionFn",
        value: function instructionFn(fns, span, reference, paramsOrFn) {
          var prepend = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          fns[prepend ? 'unshift' : 'push'](function () {
            var params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();
            return instruction(span, reference, params).toStmt();
          });
        }
      }, {
        key: "processStylingUpdateInstruction",
        value: function processStylingUpdateInstruction(elementIndex, instruction) {
          var _this179 = this;

          var allocateBindingSlots = 0;

          if (instruction) {
            var calls = [];
            instruction.calls.forEach(function (call) {
              allocateBindingSlots += call.allocateBindingSlots;
              calls.push({
                sourceSpan: call.sourceSpan,
                value: function value() {
                  return call.params(function (value) {
                    return call.supportsInterpolation && value instanceof Interpolation ? _this179.getUpdateInstructionArguments(value) : _this179.convertPropertyBinding(value);
                  });
                }
              });
            });
            this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls);
          }

          return allocateBindingSlots;
        }
      }, {
        key: "creationInstruction",
        value: function creationInstruction(span, reference, paramsOrFn, prepend) {
          this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);
        }
      }, {
        key: "creationInstructionChain",
        value: function creationInstructionChain(reference, calls) {
          var span = calls.length ? calls[0].sourceSpan : null;

          this._creationCodeFns.push(function () {
            return chainedInstruction(reference, calls.map(function (call) {
              return call.params();
            }), span).toStmt();
          });
        }
      }, {
        key: "updateInstructionWithAdvance",
        value: function updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {
          this.addAdvanceInstructionIfNecessary(nodeIndex, span);
          this.updateInstruction(span, reference, paramsOrFn);
        }
      }, {
        key: "updateInstruction",
        value: function updateInstruction(span, reference, paramsOrFn) {
          this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);
        }
      }, {
        key: "updateInstructionChain",
        value: function updateInstructionChain(reference, bindings) {
          var span = bindings.length ? bindings[0].sourceSpan : null;

          this._updateCodeFns.push(function () {
            var calls = bindings.map(function (property) {
              var value = property.value();
              var fnParams = Array.isArray(value) ? value : [value];

              if (property.params) {
                fnParams.push.apply(fnParams, _toConsumableArray(property.params));
              }

              if (property.name) {
                // We want the property name to always be the first function parameter.
                fnParams.unshift(literal(property.name));
              }

              return fnParams;
            });
            return chainedInstruction(reference, calls, span).toStmt();
          });
        }
      }, {
        key: "updateInstructionChainWithAdvance",
        value: function updateInstructionChainWithAdvance(nodeIndex, reference, bindings) {
          this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);
          this.updateInstructionChain(reference, bindings);
        }
      }, {
        key: "addAdvanceInstructionIfNecessary",
        value: function addAdvanceInstructionIfNecessary(nodeIndex, span) {
          if (nodeIndex !== this._currentIndex) {
            var delta = nodeIndex - this._currentIndex;

            if (delta < 1) {
              throw new Error('advance instruction can only go forwards');
            }

            this.instructionFn(this._updateCodeFns, span, Identifiers$1.advance, [literal(delta)]);
            this._currentIndex = nodeIndex;
          }
        }
      }, {
        key: "allocatePureFunctionSlots",
        value: function allocatePureFunctionSlots(numSlots) {
          var originalSlots = this._pureFunctionSlots;
          this._pureFunctionSlots += numSlots;
          return originalSlots;
        }
      }, {
        key: "allocateBindingSlots",
        value: function allocateBindingSlots(value) {
          this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;
        }
        /**
         * Gets an expression that refers to the implicit receiver. The implicit
         * receiver is always the root level context.
         */

      }, {
        key: "getImplicitReceiverExpr",
        value: function getImplicitReceiverExpr() {
          if (this._implicitReceiverExpr) {
            return this._implicitReceiverExpr;
          }

          return this._implicitReceiverExpr = this.level === 0 ? variable(CONTEXT_NAME) : this._bindingScope.getOrCreateSharedContextVar(0);
        }
      }, {
        key: "convertPropertyBinding",
        value: function convertPropertyBinding(value) {
          var _this$_tempVariables;

          var convertedPropertyBinding = _convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.TrySimple, function () {
            return error('Unexpected interpolation');
          });

          var valExpr = convertedPropertyBinding.currValExpr;

          (_this$_tempVariables = this._tempVariables).push.apply(_this$_tempVariables, _toConsumableArray(convertedPropertyBinding.stmts));

          return valExpr;
        }
        /**
         * Gets a list of argument expressions to pass to an update instruction expression. Also updates
         * the temp variables state with temp variables that were identified as needing to be created
         * while visiting the arguments.
         * @param value The original expression we will be resolving an arguments list from.
         */

      }, {
        key: "getUpdateInstructionArguments",
        value: function getUpdateInstructionArguments(value) {
          var _this$_tempVariables2;

          var _convertUpdateArgumen = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext()),
              args = _convertUpdateArgumen.args,
              stmts = _convertUpdateArgumen.stmts;

          (_this$_tempVariables2 = this._tempVariables).push.apply(_this$_tempVariables2, _toConsumableArray(stmts));

          return args;
        }
      }, {
        key: "matchDirectives",
        value: function matchDirectives(elementName, elOrTpl) {
          var _this180 = this;

          if (this.directiveMatcher) {
            var selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));
            this.directiveMatcher.match(selector, function (cssSelector, staticType) {
              _this180.directives.add(staticType);
            });
          }
        }
        /**
         * Prepares all attribute expression values for the `TAttributes` array.
         *
         * The purpose of this function is to properly construct an attributes array that
         * is passed into the `elementStart` (or just `element`) functions. Because there
         * are many different types of attributes, the array needs to be constructed in a
         * special way so that `elementStart` can properly evaluate them.
         *
         * The format looks like this:
         *
         * ```
         * attrs = [prop, value, prop2, value2,
         *   PROJECT_AS, selector,
         *   CLASSES, class1, class2,
         *   STYLES, style1, value1, style2, value2,
         *   BINDINGS, name1, name2, name3,
         *   TEMPLATE, name4, name5, name6,
         *   I18N, name7, name8, ...]
         * ```
         *
         * Note that this function will fully ignore all synthetic (@foo) attribute values
         * because those values are intended to always be generated as property instructions.
         */

      }, {
        key: "getAttributeExpressions",
        value: function getAttributeExpressions(renderAttributes, inputs, outputs, styles) {
          var templateAttrs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
          var i18nAttrs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
          var alreadySeen = new Set();
          var attrExprs = [];
          var ngProjectAsAttr;
          renderAttributes.forEach(function (attr) {
            if (attr.name === NG_PROJECT_AS_ATTR_NAME) {
              ngProjectAsAttr = attr;
            }

            attrExprs.push.apply(attrExprs, _toConsumableArray(getAttributeNameLiterals(attr.name)).concat([asLiteral(attr.value)]));
          }); // Keep ngProjectAs next to the other name, value pairs so we can verify that we match
          // ngProjectAs marker in the attribute name slot.

          if (ngProjectAsAttr) {
            attrExprs.push.apply(attrExprs, _toConsumableArray(getNgProjectAsLiteral(ngProjectAsAttr)));
          }

          function addAttrExpr(key, value) {
            if (typeof key === 'string') {
              if (!alreadySeen.has(key)) {
                attrExprs.push.apply(attrExprs, _toConsumableArray(getAttributeNameLiterals(key)));
                value !== undefined && attrExprs.push(value);
                alreadySeen.add(key);
              }
            } else {
              attrExprs.push(literal(key));
            }
          } // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`
          // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as
          // as single property value cell by cell.


          if (styles) {
            styles.populateInitialStylingAttrs(attrExprs);
          }

          if (inputs.length || outputs.length) {
            var attrsLengthBeforeInputs = attrExprs.length;

            for (var i = 0; i < inputs.length; i++) {
              var input = inputs[i]; // We don't want the animation and attribute bindings in the
              // attributes array since they aren't used for directive matching.

              if (input.type !== 4
              /* Animation */
              && input.type !== 1
              /* Attribute */
              ) {
                  addAttrExpr(input.name);
                }
            }

            for (var _i7 = 0; _i7 < outputs.length; _i7++) {
              var output = outputs[_i7];

              if (output.type !== 1
              /* Animation */
              ) {
                  addAttrExpr(output.name);
                }
            } // this is a cheap way of adding the marker only after all the input/output
            // values have been filtered (by not including the animation ones) and added
            // to the expressions. The marker is important because it tells the runtime
            // code that this is where attributes without values start...


            if (attrExprs.length !== attrsLengthBeforeInputs) {
              attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3
              /* Bindings */
              ));
            }
          }

          if (templateAttrs.length) {
            attrExprs.push(literal(4
            /* Template */
            ));
            templateAttrs.forEach(function (attr) {
              return addAttrExpr(attr.name);
            });
          }

          if (i18nAttrs.length) {
            attrExprs.push(literal(6
            /* I18n */
            ));
            i18nAttrs.forEach(function (attr) {
              return addAttrExpr(attr.name);
            });
          }

          return attrExprs;
        }
      }, {
        key: "addToConsts",
        value: function addToConsts(expression) {
          if (isNull(expression)) {
            return TYPED_NULL_EXPR;
          } // Try to reuse a literal that's already in the array, if possible.


          for (var i = 0; i < this._constants.length; i++) {
            if (this._constants[i].isEquivalent(expression)) {
              return literal(i);
            }
          }

          return literal(this._constants.push(expression) - 1);
        }
      }, {
        key: "addAttrsToConsts",
        value: function addAttrsToConsts(attrs) {
          return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;
        }
      }, {
        key: "prepareRefsArray",
        value: function prepareRefsArray(references) {
          var _this181 = this;

          if (!references || references.length === 0) {
            return TYPED_NULL_EXPR;
          }

          var refsParam = flatten(references.map(function (reference) {
            var slot = _this181.allocateDataSlot(); // Generate the update temporary.


            var variableName = _this181._bindingScope.freshReferenceName();

            var retrievalLevel = _this181.level;
            var lhs = variable(variableName);

            _this181._bindingScope.set(retrievalLevel, reference.name, lhs, 0
            /* DEFAULT */
            , function (scope, relativeLevel) {
              // e.g. nextContext(2);
              var nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : []; // e.g. const $foo$ = reference(1);

              var refExpr = lhs.set(importExpr(Identifiers$1.reference).callFn([literal(slot)]));
              return nextContextStmt.concat(refExpr.toConstDecl());
            }, true);

            return [reference.name, reference.value];
          }));
          return asLiteral(refsParam);
        }
      }, {
        key: "prepareListenerParameter",
        value: function prepareListenerParameter(tagName, outputAst, index) {
          var _this182 = this;

          return function () {
            var eventName = outputAst.name;
            var bindingFnName = outputAst.type === 1
            /* Animation */
            ? // synthetic @listener.foo values are treated the exact same as are standard listeners
            prepareSyntheticListenerFunctionName(eventName, outputAst.phase) : sanitizeIdentifier(eventName);
            var handlerName = "".concat(_this182.templateName, "_").concat(tagName, "_").concat(bindingFnName, "_").concat(index, "_listener");

            var scope = _this182._bindingScope.nestedScope(_this182._bindingScope.bindingLevel);

            return prepareEventListenerParameters(outputAst, handlerName, scope);
          };
        }
      }]);

      return TemplateDefinitionBuilder;
    }();

    var ValueConverter =
    /*#__PURE__*/
    function (_AstMemoryEfficientTr) {
      _inherits(ValueConverter, _AstMemoryEfficientTr);

      function ValueConverter(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {
        var _this183;

        _classCallCheck(this, ValueConverter);

        _this183 = _possibleConstructorReturn(this, _getPrototypeOf(ValueConverter).call(this));
        _this183.constantPool = constantPool;
        _this183.allocateSlot = allocateSlot;
        _this183.allocatePureFunctionSlots = allocatePureFunctionSlots;
        _this183.definePipe = definePipe;
        _this183._pipeBindExprs = [];
        return _this183;
      } // AstMemoryEfficientTransformer


      _createClass(ValueConverter, [{
        key: "visitPipe",
        value: function visitPipe(pipe, context) {
          // Allocate a slot to create the pipe
          var slot = this.allocateSlot();
          var slotPseudoLocal = "PIPE:".concat(slot); // Allocate one slot for the result plus one slot per pipe argument

          var pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);
          var target = new PropertyRead(pipe.span, pipe.sourceSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);

          var _pipeBindingCallInfo = pipeBindingCallInfo(pipe.args),
              identifier = _pipeBindingCallInfo.identifier,
              isVarLength = _pipeBindingCallInfo.isVarLength;

          this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));
          var args = [pipe.exp].concat(_toConsumableArray(pipe.args));
          var convertedArgs = isVarLength ? this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) : this.visitAll(args);
          var pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, [new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot), new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot)].concat(_toConsumableArray(convertedArgs)));

          this._pipeBindExprs.push(pipeBindExpr);

          return pipeBindExpr;
        }
      }, {
        key: "updatePipeSlotOffsets",
        value: function updatePipeSlotOffsets(bindingSlots) {
          this._pipeBindExprs.forEach(function (pipe) {
            // update the slot offset arg (index 1) to account for binding slots
            var slotOffset = pipe.args[1];
            slotOffset.value += bindingSlots;
          });
        }
      }, {
        key: "visitLiteralArray",
        value: function visitLiteralArray(array, context) {
          var _this184 = this;

          return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), function (values) {
            // If the literal has calculated (non-literal) elements transform it into
            // calls to literal factories that compose the literal and will cache intermediate
            // values.
            var literal = literalArr(values);
            return getLiteralFactory(_this184.constantPool, literal, _this184.allocatePureFunctionSlots);
          });
        }
      }, {
        key: "visitLiteralMap",
        value: function visitLiteralMap(map, context) {
          var _this185 = this;

          return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), function (values) {
            // If the literal has calculated (non-literal) elements  transform it into
            // calls to literal factories that compose the literal and will cache intermediate
            // values.
            var literal = literalMap(values.map(function (value, index) {
              return {
                key: map.keys[index].key,
                value: value,
                quoted: map.keys[index].quoted
              };
            }));
            return getLiteralFactory(_this185.constantPool, literal, _this185.allocatePureFunctionSlots);
          });
        }
      }]);

      return ValueConverter;
    }(AstMemoryEfficientTransformer); // Pipes always have at least one parameter, the value they operate on


    var pipeBindingIdentifiers = [Identifiers$1.pipeBind1, Identifiers$1.pipeBind2, Identifiers$1.pipeBind3, Identifiers$1.pipeBind4];

    function pipeBindingCallInfo(args) {
      var identifier = pipeBindingIdentifiers[args.length];
      return {
        identifier: identifier || Identifiers$1.pipeBindV,
        isVarLength: !identifier
      };
    }

    var pureFunctionIdentifiers = [Identifiers$1.pureFunction0, Identifiers$1.pureFunction1, Identifiers$1.pureFunction2, Identifiers$1.pureFunction3, Identifiers$1.pureFunction4, Identifiers$1.pureFunction5, Identifiers$1.pureFunction6, Identifiers$1.pureFunction7, Identifiers$1.pureFunction8];

    function pureFunctionCallInfo(args) {
      var identifier = pureFunctionIdentifiers[args.length];
      return {
        identifier: identifier || Identifiers$1.pureFunctionV,
        isVarLength: !identifier
      };
    }

    function instruction(span, reference, params) {
      return importExpr(reference, null, span).callFn(params, span);
    } // e.g. x(2);


    function generateNextContextExpr(relativeLevelDiff) {
      return importExpr(Identifiers$1.nextContext).callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);
    }

    function getLiteralFactory(constantPool, literal$1, allocateSlots) {
      var _constantPool$getLite = constantPool.getLiteralFactory(literal$1),
          literalFactory = _constantPool$getLite.literalFactory,
          literalFactoryArguments = _constantPool$getLite.literalFactoryArguments; // Allocate 1 slot for the result plus 1 per argument


      var startSlot = allocateSlots(1 + literalFactoryArguments.length);

      var _pureFunctionCallInfo = pureFunctionCallInfo(literalFactoryArguments),
          identifier = _pureFunctionCallInfo.identifier,
          isVarLength = _pureFunctionCallInfo.isVarLength; // Literal factories are pure functions that only need to be re-invoked when the parameters
      // change.


      var args = [literal(startSlot), literalFactory];

      if (isVarLength) {
        args.push(literalArr(literalFactoryArguments));
      } else {
        args.push.apply(args, _toConsumableArray(literalFactoryArguments));
      }

      return importExpr(identifier).callFn(args);
    }
    /**
     * Gets an array of literals that can be added to an expression
     * to represent the name and namespace of an attribute. E.g.
     * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.
     *
     * @param name Name of the attribute, including the namespace.
     */


    function getAttributeNameLiterals(name) {
      var _splitNsName5 = splitNsName(name),
          _splitNsName6 = _slicedToArray(_splitNsName5, 2),
          attributeNamespace = _splitNsName6[0],
          attributeName = _splitNsName6[1];

      var nameLiteral = literal(attributeName);

      if (attributeNamespace) {
        return [literal(0
        /* NamespaceURI */
        ), literal(attributeNamespace), nameLiteral];
      }

      return [nameLiteral];
    }
    /** The prefix used to get a shared context in BindingScope's map. */


    var SHARED_CONTEXT_KEY = '$$shared_ctx$$';

    var BindingScope =
    /*#__PURE__*/
    function () {
      function BindingScope() {
        var bindingLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, BindingScope);

        this.bindingLevel = bindingLevel;
        this.parent = parent;
        /** Keeps a map from local variables to their BindingData. */

        this.map = new Map();
        this.referenceNameIndex = 0;
        this.restoreViewVariable = null;
      }

      _createClass(BindingScope, [{
        key: "get",
        value: function get(name) {
          var current = this;

          while (current) {
            var value = current.map.get(name);

            if (value != null) {
              if (current !== this) {
                // make a local copy and reset the `declare` state
                value = {
                  retrievalLevel: value.retrievalLevel,
                  lhs: value.lhs,
                  declareLocalCallback: value.declareLocalCallback,
                  declare: false,
                  priority: value.priority,
                  localRef: value.localRef
                }; // Cache the value locally.

                this.map.set(name, value); // Possibly generate a shared context var

                this.maybeGenerateSharedContextVar(value);
                this.maybeRestoreView(value.retrievalLevel, value.localRef);
              }

              if (value.declareLocalCallback && !value.declare) {
                value.declare = true;
              }

              return value.lhs;
            }

            current = current.parent;
          } // If we get to this point, we are looking for a property on the top level component
          // - If level === 0, we are on the top and don't need to re-declare `ctx`.
          // - If level > 0, we are in an embedded view. We need to retrieve the name of the
          // local var we used to store the component context, e.g. const $comp$ = x();


          return this.bindingLevel === 0 ? null : this.getComponentProperty(name);
        }
        /**
         * Create a local variable for later reference.
         *
         * @param retrievalLevel The level from which this value can be retrieved
         * @param name Name of the variable.
         * @param lhs AST representing the left hand side of the `let lhs = rhs;`.
         * @param priority The sorting priority of this var
         * @param declareLocalCallback The callback to invoke when declaring this local var
         * @param localRef Whether or not this is a local ref
         */

      }, {
        key: "set",
        value: function set(retrievalLevel, name, lhs) {
          var priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var
          /* DEFAULT */
          declareLocalCallback = arguments.length > 4 ? arguments[4] : undefined;
          var localRef = arguments.length > 5 ? arguments[5] : undefined;

          if (this.map.has(name)) {
            if (localRef) {
              // Do not throw an error if it's a local ref and do not update existing value,
              // so the first defined ref is always returned.
              return this;
            }

            error("The name ".concat(name, " is already defined in scope to be ").concat(this.map.get(name)));
          }

          this.map.set(name, {
            retrievalLevel: retrievalLevel,
            lhs: lhs,
            declare: false,
            declareLocalCallback: declareLocalCallback,
            priority: priority,
            localRef: localRef || false
          });
          return this;
        } // Implemented as part of LocalResolver.

      }, {
        key: "getLocal",
        value: function getLocal(name) {
          return this.get(name);
        } // Implemented as part of LocalResolver.

      }, {
        key: "notifyImplicitReceiverUse",
        value: function notifyImplicitReceiverUse() {
          if (this.bindingLevel !== 0) {
            // Since the implicit receiver is accessed in an embedded view, we need to
            // ensure that we declare a shared context variable for the current template
            // in the update variables.
            this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;
          }
        }
      }, {
        key: "nestedScope",
        value: function nestedScope(level) {
          var newScope = new BindingScope(level, this);
          if (level > 0) newScope.generateSharedContextVar(0);
          return newScope;
        }
        /**
         * Gets or creates a shared context variable and returns its expression. Note that
         * this does not mean that the shared variable will be declared. Variables in the
         * binding scope will be only declared if they are used.
         */

      }, {
        key: "getOrCreateSharedContextVar",
        value: function getOrCreateSharedContextVar(retrievalLevel) {
          var bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;

          if (!this.map.has(bindingKey)) {
            this.generateSharedContextVar(retrievalLevel);
          } // Shared context variables are always generated as "ReadVarExpr".


          return this.map.get(bindingKey).lhs;
        }
      }, {
        key: "getSharedContextName",
        value: function getSharedContextName(retrievalLevel) {
          var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel); // Shared context variables are always generated as "ReadVarExpr".

          return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;
        }
      }, {
        key: "maybeGenerateSharedContextVar",
        value: function maybeGenerateSharedContextVar(value) {
          if (value.priority === 1
          /* CONTEXT */
          && value.retrievalLevel < this.bindingLevel) {
            var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);

            if (sharedCtxObj) {
              sharedCtxObj.declare = true;
            } else {
              this.generateSharedContextVar(value.retrievalLevel);
            }
          }
        }
      }, {
        key: "generateSharedContextVar",
        value: function generateSharedContextVar(retrievalLevel) {
          var lhs = variable(CONTEXT_NAME + this.freshReferenceName());
          this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {
            retrievalLevel: retrievalLevel,
            lhs: lhs,
            declareLocalCallback: function declareLocalCallback(scope, relativeLevel) {
              // const ctx_r0 = nextContext(2);
              return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];
            },
            declare: false,
            priority: 2
            /* SHARED_CONTEXT */
            ,
            localRef: false
          });
        }
      }, {
        key: "getComponentProperty",
        value: function getComponentProperty(name) {
          var componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);
          componentValue.declare = true;
          this.maybeRestoreView(0, false);
          return componentValue.lhs.prop(name);
        }
      }, {
        key: "maybeRestoreView",
        value: function maybeRestoreView(retrievalLevel, localRefLookup) {
          // We want to restore the current view in listener fns if:
          // 1 - we are accessing a value in a parent view, which requires walking the view tree rather
          // than using the ctx arg. In this case, the retrieval and binding level will be different.
          // 2 - we are looking up a local ref, which requires restoring the view where the local
          // ref is stored
          if (this.isListenerScope() && (retrievalLevel < this.bindingLevel || localRefLookup)) {
            if (!this.parent.restoreViewVariable) {
              // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction
              this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());
            }

            this.restoreViewVariable = this.parent.restoreViewVariable;
          }
        }
      }, {
        key: "restoreViewStatement",
        value: function restoreViewStatement() {
          // restoreView($state$);
          return this.restoreViewVariable ? [instruction(null, Identifiers$1.restoreView, [this.restoreViewVariable]).toStmt()] : [];
        }
      }, {
        key: "viewSnapshotStatements",
        value: function viewSnapshotStatements() {
          // const $state$ = getCurrentView();
          var getCurrentViewInstruction = instruction(null, Identifiers$1.getCurrentView, []);
          return this.restoreViewVariable ? [this.restoreViewVariable.set(getCurrentViewInstruction).toConstDecl()] : [];
        }
      }, {
        key: "isListenerScope",
        value: function isListenerScope() {
          return this.parent && this.parent.bindingLevel === this.bindingLevel;
        }
      }, {
        key: "variableDeclarations",
        value: function variableDeclarations() {
          var _this186 = this;

          var currentContextLevel = 0;
          return Array.from(this.map.values()).filter(function (value) {
            return value.declare;
          }).sort(function (a, b) {
            return b.retrievalLevel - a.retrievalLevel || b.priority - a.priority;
          }).reduce(function (stmts, value) {
            var levelDiff = _this186.bindingLevel - value.retrievalLevel;
            var currStmts = value.declareLocalCallback(_this186, levelDiff - currentContextLevel);
            currentContextLevel = levelDiff;
            return stmts.concat(currStmts);
          }, []);
        }
      }, {
        key: "freshReferenceName",
        value: function freshReferenceName() {
          var current = this; // Find the top scope as it maintains the global reference count

          while (current.parent) {
            current = current.parent;
          }

          var ref = "".concat(REFERENCE_PREFIX).concat(current.referenceNameIndex++);
          return ref;
        }
      }], [{
        key: "ROOT_SCOPE",
        get: function get() {
          if (!BindingScope._ROOT_SCOPE) {
            BindingScope._ROOT_SCOPE = new BindingScope().set(0, '$event', variable('$event'));
          }

          return BindingScope._ROOT_SCOPE;
        }
      }]);

      return BindingScope;
    }();
    /**
     * Creates a `CssSelector` given a tag name and a map of attributes
     */


    function createCssSelector(elementName, attributes) {
      var cssSelector = new CssSelector();
      var elementNameNoNs = splitNsName(elementName)[1];
      cssSelector.setElement(elementNameNoNs);
      Object.getOwnPropertyNames(attributes).forEach(function (name) {
        var nameNoNs = splitNsName(name)[1];
        var value = attributes[name];
        cssSelector.addAttribute(nameNoNs, value);

        if (name.toLowerCase() === 'class') {
          var classes = value.trim().split(/\s+/);
          classes.forEach(function (className) {
            return cssSelector.addClassName(className);
          });
        }
      });
      return cssSelector;
    }
    /**
     * Creates an array of expressions out of an `ngProjectAs` attributes
     * which can be added to the instruction parameters.
     */


    function getNgProjectAsLiteral(attribute) {
      // Parse the attribute value into a CssSelectorList. Note that we only take the
      // first selector, because we don't support multiple selectors in ngProjectAs.
      var parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];
      return [literal(5
      /* ProjectAs */
      ), asLiteral(parsedR3Selector)];
    }
    /**
     * Gets the instruction to generate for an interpolated property
     * @param interpolation An Interpolation AST
     */


    function getPropertyInterpolationExpression(interpolation) {
      switch (getInterpolationArgsLength(interpolation)) {
        case 1:
          return Identifiers$1.propertyInterpolate;

        case 3:
          return Identifiers$1.propertyInterpolate1;

        case 5:
          return Identifiers$1.propertyInterpolate2;

        case 7:
          return Identifiers$1.propertyInterpolate3;

        case 9:
          return Identifiers$1.propertyInterpolate4;

        case 11:
          return Identifiers$1.propertyInterpolate5;

        case 13:
          return Identifiers$1.propertyInterpolate6;

        case 15:
          return Identifiers$1.propertyInterpolate7;

        case 17:
          return Identifiers$1.propertyInterpolate8;

        default:
          return Identifiers$1.propertyInterpolateV;
      }
    }
    /**
     * Gets the instruction to generate for an interpolated attribute
     * @param interpolation An Interpolation AST
     */


    function getAttributeInterpolationExpression(interpolation) {
      switch (getInterpolationArgsLength(interpolation)) {
        case 3:
          return Identifiers$1.attributeInterpolate1;

        case 5:
          return Identifiers$1.attributeInterpolate2;

        case 7:
          return Identifiers$1.attributeInterpolate3;

        case 9:
          return Identifiers$1.attributeInterpolate4;

        case 11:
          return Identifiers$1.attributeInterpolate5;

        case 13:
          return Identifiers$1.attributeInterpolate6;

        case 15:
          return Identifiers$1.attributeInterpolate7;

        case 17:
          return Identifiers$1.attributeInterpolate8;

        default:
          return Identifiers$1.attributeInterpolateV;
      }
    }
    /**
     * Gets the instruction to generate for interpolated text.
     * @param interpolation An Interpolation AST
     */


    function getTextInterpolationExpression(interpolation) {
      switch (getInterpolationArgsLength(interpolation)) {
        case 1:
          return Identifiers$1.textInterpolate;

        case 3:
          return Identifiers$1.textInterpolate1;

        case 5:
          return Identifiers$1.textInterpolate2;

        case 7:
          return Identifiers$1.textInterpolate3;

        case 9:
          return Identifiers$1.textInterpolate4;

        case 11:
          return Identifiers$1.textInterpolate5;

        case 13:
          return Identifiers$1.textInterpolate6;

        case 15:
          return Identifiers$1.textInterpolate7;

        case 17:
          return Identifiers$1.textInterpolate8;

        default:
          return Identifiers$1.textInterpolateV;
      }
    }
    /**
     * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.
     *
     * @param template text of the template to parse
     * @param templateUrl URL to use for source mapping of the parsed template
     * @param options options to modify how the template is parsed
     */


    function parseTemplate(template, templateUrl) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var interpolationConfig = options.interpolationConfig,
          preserveWhitespaces = options.preserveWhitespaces,
          enableI18nLegacyMessageIdFormat = options.enableI18nLegacyMessageIdFormat;
      var bindingParser = makeBindingParser(interpolationConfig);
      var htmlParser = new HtmlParser();
      var parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({
        leadingTriviaChars: LEADING_TRIVIA_CHARS
      }, options), {
        tokenizeExpansionForms: true
      }));

      if (parseResult.errors && parseResult.errors.length > 0) {
        return {
          errors: parseResult.errors,
          nodes: [],
          styleUrls: [],
          styles: []
        };
      }

      var rootNodes = parseResult.rootNodes; // process i18n meta information (scan attributes, generate ids)
      // before we run whitespace removal process, because existing i18n
      // extraction process (ng xi18n) relies on a raw content to generate
      // message ids

      var i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig,
      /* keepI18nAttrs */
      !preserveWhitespaces, enableI18nLegacyMessageIdFormat);
      rootNodes = visitAll$1(i18nMetaVisitor, rootNodes);

      if (!preserveWhitespaces) {
        rootNodes = visitAll$1(new WhitespaceVisitor(), rootNodes); // run i18n meta visitor again in case whitespaces are removed (because that might affect
        // generated i18n message content) and first pass indicated that i18n content is present in a
        // template. During this pass i18n IDs generated at the first pass will be preserved, so we can
        // mimic existing extraction process (ng xi18n)

        if (i18nMetaVisitor.hasI18nMeta) {
          rootNodes = visitAll$1(new I18nMetaVisitor(interpolationConfig,
          /* keepI18nAttrs */
          false), rootNodes);
        }
      }

      var _htmlAstToRender3Ast = htmlAstToRender3Ast(rootNodes, bindingParser),
          nodes = _htmlAstToRender3Ast.nodes,
          errors = _htmlAstToRender3Ast.errors,
          styleUrls = _htmlAstToRender3Ast.styleUrls,
          styles = _htmlAstToRender3Ast.styles;

      if (errors && errors.length > 0) {
        return {
          errors: errors,
          nodes: [],
          styleUrls: [],
          styles: []
        };
      }

      return {
        nodes: nodes,
        styleUrls: styleUrls,
        styles: styles
      };
    }

    var elementRegistry = new DomElementSchemaRegistry();
    /**
     * Construct a `BindingParser` with a default configuration.
     */

    function makeBindingParser() {
      var interpolationConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_INTERPOLATION_CONFIG;
      return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);
    }

    function resolveSanitizationFn(context, isAttribute) {
      switch (context) {
        case SecurityContext.HTML:
          return importExpr(Identifiers$1.sanitizeHtml);

        case SecurityContext.SCRIPT:
          return importExpr(Identifiers$1.sanitizeScript);

        case SecurityContext.STYLE:
          // the compiler does not fill in an instruction for [style.prop?] binding
          // values because the style algorithm knows internally what props are subject
          // to sanitization (only [attr.style] values are explicitly sanitized)
          return isAttribute ? importExpr(Identifiers$1.sanitizeStyle) : null;

        case SecurityContext.URL:
          return importExpr(Identifiers$1.sanitizeUrl);

        case SecurityContext.RESOURCE_URL:
          return importExpr(Identifiers$1.sanitizeResourceUrl);

        default:
          return null;
      }
    }

    function isSingleElementTemplate(children) {
      return children.length === 1 && children[0] instanceof Element;
    }

    function isTextNode(node) {
      return node instanceof Text || node instanceof BoundText || node instanceof Icu;
    }

    function hasTextChildrenOnly(children) {
      return children.every(isTextNode);
    }
    /** Name of the global variable that is used to determine if we use Closure translations or not */


    var NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';
    /**
     * Generate statements that define a given translation message.
     *
     * ```
     * var I18N_1;
     * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {
     *     var MSG_EXTERNAL_XXX = goog.getMsg(
     *          "Some message with {$interpolation}!",
     *          { "interpolation": "\uFFFD0\uFFFD" }
     *     );
     *     I18N_1 = MSG_EXTERNAL_XXX;
     * }
     * else {
     *     I18N_1 = $localize`Some message with ${'\uFFFD0\uFFFD'}!`;
     * }
     * ```
     *
     * @param message The original i18n AST message node
     * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.
     * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.
     * @param params Object mapping placeholder names to their values (e.g.
     * `{ "interpolation": "\uFFFD0\uFFFD" }`).
     * @param transformFn Optional transformation function that will be applied to the translation (e.g.
     * post-processing).
     * @returns An array of statements that defined a given translation.
     */

    function getTranslationDeclStmts(message, variable, closureVar) {
      var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var transformFn = arguments.length > 4 ? arguments[4] : undefined;
      var statements = [declareI18nVariable(variable), ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, i18nFormatPlaceholderNames(params,
      /* useCamelCase */
      true)), createLocalizeStatements(variable, message, i18nFormatPlaceholderNames(params,
      /* useCamelCase */
      false)))];

      if (transformFn) {
        statements.push(new ExpressionStatement(variable.set(transformFn(variable))));
      }

      return statements;
    }
    /**
     * Create the expression that will be used to guard the closure mode block
     * It is equivalent to:
     *
     * ```
     * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode
     * ```
     */


    function createClosureModeGuard() {
      return typeofExpr(variable(NG_I18N_CLOSURE_MODE)).notIdentical(literal('undefined', STRING_TYPE)).and(variable(NG_I18N_CLOSURE_MODE));
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var EMPTY_ARRAY = []; // This regex matches any binding names that contain the "attr." prefix, e.g. "attr.required"
    // If there is a match, the first matching group will contain the attribute name to bind.

    var ATTR_REGEX = /attr\.([^\]]+)/;

    function baseDirectiveFields(meta, constantPool, bindingParser) {
      var definitionMap = new DefinitionMap();
      var selectors = parseSelectorToR3Selector(meta.selector); // e.g. `type: MyDirective`

      definitionMap.set('type', meta.internalType); // e.g. `selectors: [['', 'someDir', '']]`

      if (selectors.length > 0) {
        definitionMap.set('selectors', asLiteral(selectors));
      }

      if (meta.queries.length > 0) {
        // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }
        definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));
      }

      if (meta.viewQueries.length) {
        definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));
      } // e.g. `hostBindings: (rf, ctx) => { ... }


      definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap)); // e.g 'inputs: {a: 'a'}`

      definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true)); // e.g 'outputs: {a: 'a'}`

      definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));

      if (meta.exportAs !== null) {
        definitionMap.set('exportAs', literalArr(meta.exportAs.map(function (e) {
          return literal(e);
        })));
      }

      return definitionMap;
    }
    /**
     * Add features to the definition map.
     */


    function addFeatures(definitionMap, meta) {
      // e.g. `features: [NgOnChangesFeature()]`
      var features = [];
      var providers = meta.providers;
      var viewProviders = meta.viewProviders;

      if (providers || viewProviders) {
        var args = [providers || new LiteralArrayExpr([])];

        if (viewProviders) {
          args.push(viewProviders);
        }

        features.push(importExpr(Identifiers$1.ProvidersFeature).callFn(args));
      }

      if (meta.usesInheritance) {
        features.push(importExpr(Identifiers$1.InheritDefinitionFeature));
      }

      if (meta.fullInheritance) {
        features.push(importExpr(Identifiers$1.CopyDefinitionFeature));
      }

      if (meta.lifecycle.usesOnChanges) {
        features.push(importExpr(Identifiers$1.NgOnChangesFeature).callFn(EMPTY_ARRAY));
      }

      if (features.length) {
        definitionMap.set('features', literalArr(features));
      }
    }
    /**
     * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.
     */


    function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {
      var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
      addFeatures(definitionMap, meta);
      var expression = importExpr(Identifiers$1.defineDirective).callFn([definitionMap.toLiteralMap()]);
      var type = createTypeForDef(meta, Identifiers$1.DirectiveDefWithMeta);
      return {
        expression: expression,
        type: type
      };
    }
    /**
     * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.
     */


    function compileComponentFromMetadata(meta, constantPool, bindingParser) {
      var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
      addFeatures(definitionMap, meta);
      var selector = meta.selector && CssSelector.parse(meta.selector);
      var firstSelector = selector && selector[0]; // e.g. `attr: ["class", ".my.app"]`
      // This is optional an only included if the first selector of a component specifies attributes.

      if (firstSelector) {
        var selectorAttributes = firstSelector.getAttrs();

        if (selectorAttributes.length) {
          definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(function (value) {
            return value != null ? literal(value) : literal(undefined);
          })),
          /* forceShared */
          true));
        }
      } // Generate the CSS matcher that recognize directive


      var directiveMatcher = null;

      if (meta.directives.length > 0) {
        var matcher = new SelectorMatcher();
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = meta.directives[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var _step12$value = _step12.value,
                _selector = _step12$value.selector,
                _expression = _step12$value.expression;
            matcher.addSelectables(CssSelector.parse(_selector), _expression);
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
              _iterator12.return();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }

        directiveMatcher = matcher;
      } // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`


      var templateTypeName = meta.name;
      var templateName = templateTypeName ? "".concat(templateTypeName, "_Template") : null;
      var directivesUsed = new Set();
      var pipesUsed = new Set();
      var changeDetection = meta.changeDetection;
      var template = meta.template;
      var templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.ROOT_SCOPE, 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers$1.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);
      var templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []); // We need to provide this so that dynamically generated components know what
      // projected content blocks to pass through to the component when it is instantiated.

      var ngContentSelectors = templateBuilder.getNgContentSelectors();

      if (ngContentSelectors) {
        definitionMap.set('ngContentSelectors', ngContentSelectors);
      } // e.g. `decls: 2`


      definitionMap.set('decls', literal(templateBuilder.getConstCount())); // e.g. `vars: 2`

      definitionMap.set('vars', literal(templateBuilder.getVarCount())); // e.g. `consts: [['one', 'two'], ['three', 'four']]

      var consts = templateBuilder.getConsts();

      if (consts.length > 0) {
        definitionMap.set('consts', literalArr(consts));
      }

      definitionMap.set('template', templateFunctionExpression); // e.g. `directives: [MyDirective]`

      if (directivesUsed.size) {
        var directivesExpr = literalArr(Array.from(directivesUsed));

        if (meta.wrapDirectivesAndPipesInClosure) {
          directivesExpr = fn([], [new ReturnStatement(directivesExpr)]);
        }

        definitionMap.set('directives', directivesExpr);
      } // e.g. `pipes: [MyPipe]`


      if (pipesUsed.size) {
        var pipesExpr = literalArr(Array.from(pipesUsed));

        if (meta.wrapDirectivesAndPipesInClosure) {
          pipesExpr = fn([], [new ReturnStatement(pipesExpr)]);
        }

        definitionMap.set('pipes', pipesExpr);
      }

      if (meta.encapsulation === null) {
        meta.encapsulation = ViewEncapsulation.Emulated;
      } // e.g. `styles: [str1, str2]`


      if (meta.styles && meta.styles.length) {
        var styleValues = meta.encapsulation == ViewEncapsulation.Emulated ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) : meta.styles;
        var strings = styleValues.map(function (str) {
          return literal(str);
        });
        definitionMap.set('styles', literalArr(strings));
      } else if (meta.encapsulation === ViewEncapsulation.Emulated) {
        // If there is no style, don't generate css selectors on elements
        meta.encapsulation = ViewEncapsulation.None;
      } // Only set view encapsulation if it's not the default value


      if (meta.encapsulation !== ViewEncapsulation.Emulated) {
        definitionMap.set('encapsulation', literal(meta.encapsulation));
      } // e.g. `animation: [trigger('123', [])]`


      if (meta.animations !== null) {
        definitionMap.set('data', literalMap([{
          key: 'animation',
          value: meta.animations,
          quoted: false
        }]));
      } // Only set the change detection flag if it's defined and it's not the default.


      if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {
        definitionMap.set('changeDetection', literal(changeDetection));
      }

      var expression = importExpr(Identifiers$1.defineComponent).callFn([definitionMap.toLiteralMap()]);
      var type = createTypeForDef(meta, Identifiers$1.ComponentDefWithMeta);
      return {
        expression: expression,
        type: type
      };
    }
    /**
     * A wrapper around `compileDirective` which depends on render2 global analysis data as its input
     * instead of the `R3DirectiveMetadata`.
     *
     * `R3DirectiveMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected
     * information.
     */


    function compileDirectiveFromRender2(outputCtx, directive, reflector, bindingParser) {
      var name = identifierName(directive.type);
      name || error("Cannot resolver the name of ".concat(directive.type));
      var definitionField = outputCtx.constantPool.propertyNameOf(1
      /* Directive */
      );
      var meta = directiveMetadataFromGlobalMetadata(directive, outputCtx, reflector);
      var res = compileDirectiveFromMetadata(meta, outputCtx.constantPool, bindingParser);
      var factoryRes = compileFactoryFunction(Object.assign(Object.assign({}, meta), {
        injectFn: Identifiers$1.directiveInject,
        target: R3FactoryTarget.Directive
      }));
      var ngFactoryDefStatement = new ClassStmt(name, null, [new ClassField('ɵfac', INFERRED_TYPE, [StmtModifier.Static], factoryRes.factory)], [], new ClassMethod(null, [], []), []);
      var directiveDefStatement = new ClassStmt(name, null, [new ClassField(definitionField, INFERRED_TYPE, [StmtModifier.Static], res.expression)], [], new ClassMethod(null, [], []), []); // Create the partial class to be merged with the actual class.

      outputCtx.statements.push(ngFactoryDefStatement, directiveDefStatement);
    }
    /**
     * A wrapper around `compileComponent` which depends on render2 global analysis data as its input
     * instead of the `R3DirectiveMetadata`.
     *
     * `R3ComponentMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected
     * information.
     */


    function compileComponentFromRender2(outputCtx, component, render3Ast, reflector, bindingParser, directiveTypeBySel, pipeTypeByName) {
      var name = identifierName(component.type);
      name || error("Cannot resolver the name of ".concat(component.type));
      var definitionField = outputCtx.constantPool.propertyNameOf(2
      /* Component */
      );
      var summary = component.toSummary(); // Compute the R3ComponentMetadata from the CompileDirectiveMetadata

      var meta = Object.assign(Object.assign({}, directiveMetadataFromGlobalMetadata(component, outputCtx, reflector)), {
        selector: component.selector,
        template: {
          nodes: render3Ast.nodes
        },
        directives: [],
        pipes: typeMapToExpressionMap(pipeTypeByName, outputCtx),
        viewQueries: queriesFromGlobalMetadata(component.viewQueries, outputCtx),
        wrapDirectivesAndPipesInClosure: false,
        styles: summary.template && summary.template.styles || EMPTY_ARRAY,
        encapsulation: summary.template && summary.template.encapsulation || ViewEncapsulation.Emulated,
        interpolation: DEFAULT_INTERPOLATION_CONFIG,
        animations: null,
        viewProviders: component.viewProviders.length > 0 ? new WrappedNodeExpr(component.viewProviders) : null,
        relativeContextFilePath: '',
        i18nUseExternalIds: true
      });
      var res = compileComponentFromMetadata(meta, outputCtx.constantPool, bindingParser);
      var factoryRes = compileFactoryFunction(Object.assign(Object.assign({}, meta), {
        injectFn: Identifiers$1.directiveInject,
        target: R3FactoryTarget.Directive
      }));
      var ngFactoryDefStatement = new ClassStmt(name, null, [new ClassField('ɵfac', INFERRED_TYPE, [StmtModifier.Static], factoryRes.factory)], [], new ClassMethod(null, [], []), []);
      var componentDefStatement = new ClassStmt(name, null, [new ClassField(definitionField, INFERRED_TYPE, [StmtModifier.Static], res.expression)], [], new ClassMethod(null, [], []), []); // Create the partial class to be merged with the actual class.

      outputCtx.statements.push(ngFactoryDefStatement, componentDefStatement);
    }
    /**
     * Compute `R3DirectiveMetadata` given `CompileDirectiveMetadata` and a `CompileReflector`.
     */


    function directiveMetadataFromGlobalMetadata(directive, outputCtx, reflector) {
      // The global-analysis based Ivy mode in ngc is no longer utilized/supported.
      throw new Error('unsupported');
    }
    /**
     * Convert `CompileQueryMetadata` into `R3QueryMetadata`.
     */


    function queriesFromGlobalMetadata(queries, outputCtx) {
      return queries.map(function (query) {
        var read = null;

        if (query.read && query.read.identifier) {
          read = outputCtx.importExpr(query.read.identifier.reference);
        }

        return {
          propertyName: query.propertyName,
          first: query.first,
          predicate: selectorsFromGlobalMetadata(query.selectors, outputCtx),
          descendants: query.descendants,
          read: read,
          static: !!query.static
        };
      });
    }
    /**
     * Convert `CompileTokenMetadata` for query selectors into either an expression for a predicate
     * type, or a list of string predicates.
     */


    function selectorsFromGlobalMetadata(selectors, outputCtx) {
      if (selectors.length > 1 || selectors.length == 1 && selectors[0].value) {
        var selectorStrings = selectors.map(function (value) {
          return value.value;
        });
        selectorStrings.some(function (value) {
          return !value;
        }) && error('Found a type among the string selectors expected');
        return outputCtx.constantPool.getConstLiteral(literalArr(selectorStrings.map(function (value) {
          return literal(value);
        })));
      }

      if (selectors.length == 1) {
        var first = selectors[0];

        if (first.identifier) {
          return outputCtx.importExpr(first.identifier.reference);
        }
      }

      error('Unexpected query form');
      return NULL_EXPR;
    }

    function prepareQueryParams(query, constantPool) {
      var parameters = [getQueryPredicate(query, constantPool), literal(query.descendants)];

      if (query.read) {
        parameters.push(query.read);
      }

      return parameters;
    }

    function convertAttributesToExpressions(attributes) {
      var values = [];
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = Object.getOwnPropertyNames(attributes)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var key = _step13.value;
          var value = attributes[key];
          values.push(literal(key), value);
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
            _iterator13.return();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }

      return values;
    } // Define and update any content queries


    function createContentQueriesFunction(queries, constantPool, name) {
      var createStatements = [];
      var updateStatements = [];
      var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = queries[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var query = _step14.value;
          var queryInstruction = query.static ? Identifiers$1.staticContentQuery : Identifiers$1.contentQuery; // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);

          createStatements.push(importExpr(queryInstruction).callFn([variable('dirIndex')].concat(_toConsumableArray(prepareQueryParams(query, constantPool)))).toStmt()); // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));

          var temporary = tempAllocator();
          var getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);
          var refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);
          var updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);
          updateStatements.push(refresh.and(updateDirective).toStmt());
        }
      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
            _iterator14.return();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }

      var contentQueriesFnName = name ? "".concat(name, "_ContentQueries") : null;
      return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null), new FnParam('dirIndex', null)], [renderFlagCheckIfStmt(1
      /* Create */
      , createStatements), renderFlagCheckIfStmt(2
      /* Update */
      , updateStatements)], INFERRED_TYPE, null, contentQueriesFnName);
    }

    function stringAsType(str) {
      return expressionType(literal(str));
    }

    function stringMapAsType(map) {
      var mapValues = Object.keys(map).map(function (key) {
        var value = Array.isArray(map[key]) ? map[key][0] : map[key];
        return {
          key: key,
          value: literal(value),
          quoted: true
        };
      });
      return expressionType(literalMap(mapValues));
    }

    function stringArrayAsType(arr) {
      return arr.length > 0 ? expressionType(literalArr(arr.map(function (value) {
        return literal(value);
      }))) : NONE_TYPE;
    }

    function createTypeForDef(meta, typeBase) {
      // On the type side, remove newlines from the selector as it will need to fit into a TypeScript
      // string literal, which must be on one line.
      var selectorForType = meta.selector !== null ? meta.selector.replace(/\n/g, '') : null;
      return expressionType(importExpr(typeBase, [typeWithParameters(meta.type.type, meta.typeArgumentCount), selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE, meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE, stringMapAsType(meta.inputs), stringMapAsType(meta.outputs), stringArrayAsType(meta.queries.map(function (q) {
        return q.propertyName;
      }))]));
    } // Define and update any view queries


    function createViewQueriesFunction(viewQueries, constantPool, name) {
      var createStatements = [];
      var updateStatements = [];
      var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
      viewQueries.forEach(function (query) {
        var queryInstruction = query.static ? Identifiers$1.staticViewQuery : Identifiers$1.viewQuery; // creation, e.g. r3.viewQuery(somePredicate, true);

        var queryDefinition = importExpr(queryInstruction).callFn(prepareQueryParams(query, constantPool));
        createStatements.push(queryDefinition.toStmt()); // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));

        var temporary = tempAllocator();
        var getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);
        var refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);
        var updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);
        updateStatements.push(refresh.and(updateDirective).toStmt());
      });
      var viewQueryFnName = name ? "".concat(name, "_Query") : null;
      return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [renderFlagCheckIfStmt(1
      /* Create */
      , createStatements), renderFlagCheckIfStmt(2
      /* Update */
      , updateStatements)], INFERRED_TYPE, null, viewQueryFnName);
    } // Return a host binding function or null if one is not necessary.


    function createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {
      var bindingContext = variable(CONTEXT_NAME);
      var styleBuilder = new StylingBuilder(bindingContext);
      var _hostBindingsMetadata = hostBindingsMetadata.specialAttributes,
          styleAttr = _hostBindingsMetadata.styleAttr,
          classAttr = _hostBindingsMetadata.classAttr;

      if (styleAttr !== undefined) {
        styleBuilder.registerStyleAttr(styleAttr);
      }

      if (classAttr !== undefined) {
        styleBuilder.registerClassAttr(classAttr);
      }

      var createStatements = [];
      var updateStatements = [];
      var hostBindingSourceSpan = typeSourceSpan;
      var directiveSummary = metadataAsSummary(hostBindingsMetadata); // Calculate host event bindings

      var eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);

      if (eventBindings && eventBindings.length) {
        var listeners = createHostListeners(eventBindings, name);
        createStatements.push.apply(createStatements, _toConsumableArray(listeners));
      } // Calculate the host property bindings


      var bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);
      var allOtherBindings = []; // We need to calculate the total amount of binding slots required by
      // all the instructions together before any value conversions happen.
      // Value conversions may require additional slots for interpolation and
      // bindings with pipes. These calculates happen after this block.

      var totalHostVarsCount = 0;
      bindings && bindings.forEach(function (binding) {
        var name = binding.name;
        var stylingInputWasSet = styleBuilder.registerInputBasedOnName(name, binding.expression, binding.sourceSpan);

        if (stylingInputWasSet) {
          totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;
        } else {
          allOtherBindings.push(binding);
          totalHostVarsCount++;
        }
      });
      var valueConverter;

      var getValueConverter = function getValueConverter() {
        if (!valueConverter) {
          var hostVarsCountFn = function hostVarsCountFn(numSlots) {
            var originalVarsCount = totalHostVarsCount;
            totalHostVarsCount += numSlots;
            return originalVarsCount;
          };

          valueConverter = new ValueConverter(constantPool, function () {
            return error('Unexpected node');
          }, // new nodes are illegal here
          hostVarsCountFn, function () {
            return error('Unexpected pipe');
          }); // pipes are illegal here
        }

        return valueConverter;
      };

      var propertyBindings = [];
      var attributeBindings = [];
      var syntheticHostBindings = [];
      allOtherBindings.forEach(function (binding) {
        // resolve literal arrays and literal objects
        var value = binding.expression.visit(getValueConverter());
        var bindingExpr = bindingFn(bindingContext, value);

        var _getBindingNameAndIns = getBindingNameAndInstruction(binding),
            bindingName = _getBindingNameAndIns.bindingName,
            instruction = _getBindingNameAndIns.instruction,
            isAttribute = _getBindingNameAndIns.isAttribute;

        var securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute).filter(function (context) {
          return context !== SecurityContext.NONE;
        });
        var sanitizerFn = null;

        if (securityContexts.length) {
          if (securityContexts.length === 2 && securityContexts.indexOf(SecurityContext.URL) > -1 && securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {
            // Special case for some URL attributes (such as "src" and "href") that may be a part
            // of different security contexts. In this case we use special santitization function and
            // select the actual sanitizer at runtime based on a tag name that is provided while
            // invoking sanitization function.
            sanitizerFn = importExpr(Identifiers$1.sanitizeUrlOrResourceUrl);
          } else {
            sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);
          }
        }

        var instructionParams = [literal(bindingName), bindingExpr.currValExpr];

        if (sanitizerFn) {
          instructionParams.push(sanitizerFn);
        }

        updateStatements.push.apply(updateStatements, _toConsumableArray(bindingExpr.stmts));

        if (instruction === Identifiers$1.hostProperty) {
          propertyBindings.push(instructionParams);
        } else if (instruction === Identifiers$1.attribute) {
          attributeBindings.push(instructionParams);
        } else if (instruction === Identifiers$1.updateSyntheticHostBinding) {
          syntheticHostBindings.push(instructionParams);
        } else {
          updateStatements.push(importExpr(instruction).callFn(instructionParams).toStmt());
        }
      });

      if (propertyBindings.length > 0) {
        updateStatements.push(chainedInstruction(Identifiers$1.hostProperty, propertyBindings).toStmt());
      }

      if (attributeBindings.length > 0) {
        updateStatements.push(chainedInstruction(Identifiers$1.attribute, attributeBindings).toStmt());
      }

      if (syntheticHostBindings.length > 0) {
        updateStatements.push(chainedInstruction(Identifiers$1.updateSyntheticHostBinding, syntheticHostBindings).toStmt());
      } // since we're dealing with directives/components and both have hostBinding
      // functions, we need to generate a special hostAttrs instruction that deals
      // with both the assignment of styling as well as static attributes to the host
      // element. The instruction below will instruct all initial styling (styling
      // that is inside of a host binding within a directive/component) to be attached
      // to the host element alongside any of the provided host attributes that were
      // collected earlier.


      var hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);
      styleBuilder.assignHostAttrs(hostAttrs, definitionMap);

      if (styleBuilder.hasBindings) {
        // finally each binding that was registered in the statement above will need to be added to
        // the update block of a component/directive templateFn/hostBindingsFn so that the bindings
        // are evaluated and updated for the element.
        styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(function (instruction) {
          if (instruction.calls.length > 0) {
            var calls = [];
            instruction.calls.forEach(function (call) {
              // we subtract a value of `1` here because the binding slot was already allocated
              // at the top of this method when all the input bindings were counted.
              totalHostVarsCount += Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);
              calls.push(convertStylingCall(call, bindingContext, bindingFn));
            });
            updateStatements.push(chainedInstruction(instruction.reference, calls).toStmt());
          }
        });
      }

      if (totalHostVarsCount) {
        definitionMap.set('hostVars', literal(totalHostVarsCount));
      }

      if (createStatements.length > 0 || updateStatements.length > 0) {
        var hostBindingsFnName = name ? "".concat(name, "_HostBindings") : null;
        var statements = [];

        if (createStatements.length > 0) {
          statements.push(renderFlagCheckIfStmt(1
          /* Create */
          , createStatements));
        }

        if (updateStatements.length > 0) {
          statements.push(renderFlagCheckIfStmt(2
          /* Update */
          , updateStatements));
        }

        return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);
      }

      return null;
    }

    function bindingFn(implicit, value) {
      return _convertPropertyBinding(null, implicit, value, 'b', BindingForm.TrySimple, function () {
        return error('Unexpected interpolation');
      });
    }

    function convertStylingCall(call, bindingContext, bindingFn) {
      return call.params(function (value) {
        return bindingFn(bindingContext, value).currValExpr;
      });
    }

    function getBindingNameAndInstruction(binding) {
      var bindingName = binding.name;
      var instruction; // Check to see if this is an attr binding or a property binding

      var attrMatches = bindingName.match(ATTR_REGEX);

      if (attrMatches) {
        bindingName = attrMatches[1];
        instruction = Identifiers$1.attribute;
      } else {
        if (binding.isAnimation) {
          bindingName = prepareSyntheticPropertyName(bindingName); // host bindings that have a synthetic property (e.g. @foo) should always be rendered
          // in the context of the component and not the parent. Therefore there is a special
          // compatibility instruction available for this purpose.

          instruction = Identifiers$1.updateSyntheticHostBinding;
        } else {
          instruction = Identifiers$1.hostProperty;
        }
      }

      return {
        bindingName: bindingName,
        instruction: instruction,
        isAttribute: !!attrMatches
      };
    }

    function createHostListeners(eventBindings, name) {
      var listeners = [];
      var syntheticListeners = [];
      var instructions = [];
      eventBindings.forEach(function (binding) {
        var bindingName = binding.name && sanitizeIdentifier(binding.name);
        var bindingFnName = binding.type === 1
        /* Animation */
        ? prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) : bindingName;
        var handlerName = name && bindingName ? "".concat(name, "_").concat(bindingFnName, "_HostBindingHandler") : null;
        var params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);

        if (binding.type == 1
        /* Animation */
        ) {
            syntheticListeners.push(params);
          } else {
          listeners.push(params);
        }
      });

      if (syntheticListeners.length > 0) {
        instructions.push(chainedInstruction(Identifiers$1.componentHostSyntheticListener, syntheticListeners).toStmt());
      }

      if (listeners.length > 0) {
        instructions.push(chainedInstruction(Identifiers$1.listener, listeners).toStmt());
      }

      return instructions;
    }

    function metadataAsSummary(meta) {
      // clang-format off
      return {
        // This is used by the BindingParser, which only deals with listeners and properties. There's no
        // need to pass attributes to it.
        hostAttributes: {},
        hostListeners: meta.listeners,
        hostProperties: meta.properties
      }; // clang-format on
    }

    function typeMapToExpressionMap(map, outputCtx) {
      // Convert each map entry into another entry where the value is an expression importing the type.
      var entries = Array.from(map).map(function (_ref19) {
        var _ref20 = _slicedToArray(_ref19, 2),
            key = _ref20[0],
            type = _ref20[1];

        return [key, outputCtx.importExpr(type)];
      });
      return new Map(entries);
    }

    var HOST_REG_EXP$1 = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;

    function parseHostBindings(host) {
      var attributes = {};
      var listeners = {};
      var properties = {};
      var specialAttributes = {};

      for (var _i8 = 0, _Object$keys2 = Object.keys(host); _i8 < _Object$keys2.length; _i8++) {
        var key = _Object$keys2[_i8];
        var value = host[key];
        var matches = key.match(HOST_REG_EXP$1);

        if (matches === null) {
          switch (key) {
            case 'class':
              if (typeof value !== 'string') {
                // TODO(alxhub): make this a diagnostic.
                throw new Error("Class binding must be string");
              }

              specialAttributes.classAttr = value;
              break;

            case 'style':
              if (typeof value !== 'string') {
                // TODO(alxhub): make this a diagnostic.
                throw new Error("Style binding must be string");
              }

              specialAttributes.styleAttr = value;
              break;

            default:
              if (typeof value === 'string') {
                attributes[key] = literal(value);
              } else {
                attributes[key] = value;
              }

          }
        } else if (matches[1
        /* Binding */
        ] != null) {
          if (typeof value !== 'string') {
            // TODO(alxhub): make this a diagnostic.
            throw new Error("Property binding must be string");
          } // synthetic properties (the ones that have a `@` as a prefix)
          // are still treated the same as regular properties. Therefore
          // there is no point in storing them in a separate map.


          properties[matches[1
          /* Binding */
          ]] = value;
        } else if (matches[2
        /* Event */
        ] != null) {
          if (typeof value !== 'string') {
            // TODO(alxhub): make this a diagnostic.
            throw new Error("Event binding must be string");
          }

          listeners[matches[2
          /* Event */
          ]] = value;
        }
      }

      return {
        attributes: attributes,
        listeners: listeners,
        properties: properties,
        specialAttributes: specialAttributes
      };
    }
    /**
     * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a
     * given set of host bindings has no errors.
     *
     * @param bindings set of host bindings to verify.
     * @param sourceSpan source span where host bindings were defined.
     * @returns array of errors associated with a given set of host bindings.
     */


    function verifyHostBindings(bindings, sourceSpan) {
      var summary = metadataAsSummary(bindings); // TODO: abstract out host bindings verification logic and use it instead of
      // creating events and properties ASTs to detect errors (FW-996)

      var bindingParser = makeBindingParser();
      bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);
      bindingParser.createBoundHostProperties(summary, sourceSpan);
      return bindingParser.errors;
    }

    function compileStyles(styles, selector, hostSelector) {
      var shadowCss = new ShadowCss();
      return styles.map(function (style) {
        return shadowCss.shimCssText(style, selector, hostSelector);
      });
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * An interface for retrieving documents by URL that the compiler uses
     * to load templates.
     */


    var ResourceLoader =
    /*#__PURE__*/
    function () {
      function ResourceLoader() {
        _classCallCheck(this, ResourceLoader);
      }

      _createClass(ResourceLoader, [{
        key: "get",
        value: function get(url) {
          return '';
        }
      }]);

      return ResourceLoader;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var CompilerFacadeImpl =
    /*#__PURE__*/
    function () {
      function CompilerFacadeImpl() {
        var jitEvaluator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new JitEvaluator();

        _classCallCheck(this, CompilerFacadeImpl);

        this.jitEvaluator = jitEvaluator;
        this.R3ResolvedDependencyType = R3ResolvedDependencyType;
        this.R3FactoryTarget = R3FactoryTarget;
        this.ResourceLoader = ResourceLoader;
        this.elementSchemaRegistry = new DomElementSchemaRegistry();
      }

      _createClass(CompilerFacadeImpl, [{
        key: "compilePipe",
        value: function compilePipe(angularCoreEnv, sourceMapUrl, facade) {
          var metadata = {
            name: facade.name,
            type: wrapReference$1(facade.type),
            internalType: new WrappedNodeExpr(facade.type),
            typeArgumentCount: facade.typeArgumentCount,
            deps: convertR3DependencyMetadataArray(facade.deps),
            pipeName: facade.pipeName,
            pure: facade.pure
          };
          var res = compilePipeFromMetadata(metadata);
          return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
      }, {
        key: "compileInjectable",
        value: function compileInjectable(angularCoreEnv, sourceMapUrl, facade) {
          var _compileInjectable2 = _compileInjectable({
            name: facade.name,
            type: wrapReference$1(facade.type),
            internalType: new WrappedNodeExpr(facade.type),
            typeArgumentCount: facade.typeArgumentCount,
            providedIn: computeProvidedIn(facade.providedIn),
            useClass: wrapExpression(facade, USE_CLASS),
            useFactory: wrapExpression(facade, USE_FACTORY),
            useValue: wrapExpression(facade, USE_VALUE),
            useExisting: wrapExpression(facade, USE_EXISTING),
            userDeps: convertR3DependencyMetadataArray(facade.userDeps) || undefined
          }),
              expression = _compileInjectable2.expression,
              statements = _compileInjectable2.statements;

          return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
        }
      }, {
        key: "compileInjector",
        value: function compileInjector(angularCoreEnv, sourceMapUrl, facade) {
          var meta = {
            name: facade.name,
            type: wrapReference$1(facade.type),
            internalType: new WrappedNodeExpr(facade.type),
            deps: convertR3DependencyMetadataArray(facade.deps),
            providers: new WrappedNodeExpr(facade.providers),
            imports: facade.imports.map(function (i) {
              return new WrappedNodeExpr(i);
            })
          };

          var res = _compileInjector(meta);

          return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, res.statements);
        }
      }, {
        key: "compileNgModule",
        value: function compileNgModule(angularCoreEnv, sourceMapUrl, facade) {
          var meta = {
            type: wrapReference$1(facade.type),
            internalType: new WrappedNodeExpr(facade.type),
            adjacentType: new WrappedNodeExpr(facade.type),
            bootstrap: facade.bootstrap.map(wrapReference$1),
            declarations: facade.declarations.map(wrapReference$1),
            imports: facade.imports.map(wrapReference$1),
            exports: facade.exports.map(wrapReference$1),
            emitInline: true,
            containsForwardDecls: false,
            schemas: facade.schemas ? facade.schemas.map(wrapReference$1) : null,
            id: facade.id ? new WrappedNodeExpr(facade.id) : null
          };

          var res = _compileNgModule(meta);

          return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
      }, {
        key: "compileDirective",
        value: function compileDirective(angularCoreEnv, sourceMapUrl, facade) {
          var constantPool = new ConstantPool();
          var bindingParser = makeBindingParser();
          var meta = convertDirectiveFacadeToMetadata(facade);
          var res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);
          return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
        }
      }, {
        key: "compileComponent",
        value: function compileComponent(angularCoreEnv, sourceMapUrl, facade) {
          // The ConstantPool is a requirement of the JIT'er.
          var constantPool = new ConstantPool();
          var interpolationConfig = facade.interpolation ? InterpolationConfig.fromArray(facade.interpolation) : DEFAULT_INTERPOLATION_CONFIG; // Parse the template and check for errors.

          var template = parseTemplate(facade.template, sourceMapUrl, {
            preserveWhitespaces: facade.preserveWhitespaces,
            interpolationConfig: interpolationConfig
          });

          if (template.errors !== undefined) {
            var errors = template.errors.map(function (err) {
              return err.toString();
            }).join(', ');
            throw new Error("Errors during JIT compilation of template for ".concat(facade.name, ": ").concat(errors));
          } // Compile the component metadata, including template, into an expression.
          // TODO(alxhub): implement inputs, outputs, queries, etc.


          var metadata = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), {
            selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),
            template: template,
            wrapDirectivesAndPipesInClosure: false,
            styles: [].concat(_toConsumableArray(facade.styles), _toConsumableArray(template.styles)),
            encapsulation: facade.encapsulation,
            interpolation: interpolationConfig,
            changeDetection: facade.changeDetection,
            animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,
            viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,
            relativeContextFilePath: '',
            i18nUseExternalIds: true
          });
          var res = compileComponentFromMetadata(metadata, constantPool, makeBindingParser(interpolationConfig));
          var jitExpressionSourceMap = "ng:///".concat(facade.name, ".js");
          return this.jitExpression(res.expression, angularCoreEnv, jitExpressionSourceMap, constantPool.statements);
        }
      }, {
        key: "compileFactory",
        value: function compileFactory(angularCoreEnv, sourceMapUrl, meta) {
          var factoryRes = compileFactoryFunction({
            name: meta.name,
            type: wrapReference$1(meta.type),
            internalType: new WrappedNodeExpr(meta.type),
            typeArgumentCount: meta.typeArgumentCount,
            deps: convertR3DependencyMetadataArray(meta.deps),
            injectFn: meta.injectFn === 'directiveInject' ? Identifiers.directiveInject : Identifiers.inject,
            target: meta.target
          });
          return this.jitExpression(factoryRes.factory, angularCoreEnv, sourceMapUrl, factoryRes.statements);
        }
      }, {
        key: "createParseSourceSpan",
        value: function createParseSourceSpan(kind, typeName, sourceUrl) {
          return r3JitTypeSourceSpan(kind, typeName, sourceUrl);
        }
        /**
         * JIT compiles an expression and returns the result of executing that expression.
         *
         * @param def the definition which will be compiled and executed to get the value to patch
         * @param context an object map of @angular/core symbol names to symbols which will be available
         * in the context of the compiled expression
         * @param sourceUrl a URL to use for the source map of the compiled expression
         * @param preStatements a collection of statements that should be evaluated before the expression.
         */

      }, {
        key: "jitExpression",
        value: function jitExpression(def, context, sourceUrl, preStatements) {
          // The ConstantPool may contain Statements which declare variables used in the final expression.
          // Therefore, its statements need to precede the actual JIT operation. The final statement is a
          // declaration of $def which is set to the expression being compiled.
          var statements = [].concat(_toConsumableArray(preStatements), [new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported])]);
          var res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context),
          /* enableSourceMaps */
          true);
          return res['$def'];
        }
      }]);

      return CompilerFacadeImpl;
    }();

    var USE_CLASS = Object.keys({
      useClass: null
    })[0];
    var USE_FACTORY = Object.keys({
      useFactory: null
    })[0];
    var USE_VALUE = Object.keys({
      useValue: null
    })[0];
    var USE_EXISTING = Object.keys({
      useExisting: null
    })[0];

    var wrapReference$1 = function wrapReference$1(value) {
      var wrapped = new WrappedNodeExpr(value);
      return {
        value: wrapped,
        type: wrapped
      };
    };

    function convertToR3QueryMetadata(facade) {
      return Object.assign(Object.assign({}, facade), {
        predicate: Array.isArray(facade.predicate) ? facade.predicate : new WrappedNodeExpr(facade.predicate),
        read: facade.read ? new WrappedNodeExpr(facade.read) : null,
        static: facade.static
      });
    }

    function convertDirectiveFacadeToMetadata(facade) {
      var inputsFromMetadata = parseInputOutputs(facade.inputs || []);
      var outputsFromMetadata = parseInputOutputs(facade.outputs || []);
      var propMetadata = facade.propMetadata;
      var inputsFromType = {};
      var outputsFromType = {};

      var _loop = function _loop(field) {
        if (propMetadata.hasOwnProperty(field)) {
          propMetadata[field].forEach(function (ann) {
            if (isInput(ann)) {
              inputsFromType[field] = ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
            } else if (isOutput(ann)) {
              outputsFromType[field] = ann.bindingPropertyName || field;
            }
          });
        }
      };

      for (var field in propMetadata) {
        _loop(field);
      }

      return Object.assign(Object.assign({}, facade), {
        typeSourceSpan: facade.typeSourceSpan,
        type: wrapReference$1(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        deps: convertR3DependencyMetadataArray(facade.deps),
        host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),
        inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType),
        outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType),
        queries: facade.queries.map(convertToR3QueryMetadata),
        providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,
        viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),
        fullInheritance: false
      });
    }

    function wrapExpression(obj, property) {
      if (obj.hasOwnProperty(property)) {
        return new WrappedNodeExpr(obj[property]);
      } else {
        return undefined;
      }
    }

    function computeProvidedIn(providedIn) {
      if (providedIn == null || typeof providedIn === 'string') {
        return new LiteralExpr(providedIn);
      } else {
        return new WrappedNodeExpr(providedIn);
      }
    }

    function convertR3DependencyMetadata(facade) {
      var tokenExpr;

      if (facade.token === null) {
        tokenExpr = new LiteralExpr(null);
      } else if (facade.resolved === R3ResolvedDependencyType.Attribute) {
        tokenExpr = new LiteralExpr(facade.token);
      } else {
        tokenExpr = new WrappedNodeExpr(facade.token);
      }

      return {
        token: tokenExpr,
        resolved: facade.resolved,
        host: facade.host,
        optional: facade.optional,
        self: facade.self,
        skipSelf: facade.skipSelf
      };
    }

    function convertR3DependencyMetadataArray(facades) {
      return facades == null ? null : facades.map(convertR3DependencyMetadata);
    }

    function extractHostBindings(propMetadata, sourceSpan, host) {
      // First parse the declarations from the metadata.
      var bindings = parseHostBindings(host || {}); // After that check host bindings for errors

      var errors = verifyHostBindings(bindings, sourceSpan);

      if (errors.length) {
        throw new Error(errors.map(function (error) {
          return error.msg;
        }).join('\n'));
      } // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.


      var _loop2 = function _loop2(field) {
        if (propMetadata.hasOwnProperty(field)) {
          propMetadata[field].forEach(function (ann) {
            if (isHostBinding(ann)) {
              bindings.properties[ann.hostPropertyName || field] = field;
            } else if (isHostListener(ann)) {
              bindings.listeners[ann.eventName || field] = "".concat(field, "(").concat((ann.args || []).join(','), ")");
            }
          });
        }
      };

      for (var field in propMetadata) {
        _loop2(field);
      }

      return bindings;
    }

    function isHostBinding(value) {
      return value.ngMetadataName === 'HostBinding';
    }

    function isHostListener(value) {
      return value.ngMetadataName === 'HostListener';
    }

    function isInput(value) {
      return value.ngMetadataName === 'Input';
    }

    function isOutput(value) {
      return value.ngMetadataName === 'Output';
    }

    function parseInputOutputs(values) {
      return values.reduce(function (map, value) {
        var _value$split$map = value.split(',').map(function (piece) {
          return piece.trim();
        }),
            _value$split$map2 = _slicedToArray(_value$split$map, 2),
            field = _value$split$map2[0],
            property = _value$split$map2[1];

        map[field] = property || field;
        return map;
      }, {});
    }

    function publishFacade(global) {
      var ng = global.ng || (global.ng = {});
      ng.ɵcompilerFacade = new CompilerFacadeImpl();
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var VERSION$1 = new Version('9.0.4');
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    var CompilerConfig = function CompilerConfig() {
      var _ref21 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref21$defaultEncapsu = _ref21.defaultEncapsulation,
          defaultEncapsulation = _ref21$defaultEncapsu === void 0 ? ViewEncapsulation.Emulated : _ref21$defaultEncapsu,
          _ref21$useJit = _ref21.useJit,
          useJit = _ref21$useJit === void 0 ? true : _ref21$useJit,
          _ref21$jitDevMode = _ref21.jitDevMode,
          jitDevMode = _ref21$jitDevMode === void 0 ? false : _ref21$jitDevMode,
          _ref21$missingTransla = _ref21.missingTranslation,
          missingTranslation = _ref21$missingTransla === void 0 ? null : _ref21$missingTransla,
          preserveWhitespaces = _ref21.preserveWhitespaces,
          strictInjectionParameters = _ref21.strictInjectionParameters;

      _classCallCheck(this, CompilerConfig);

      this.defaultEncapsulation = defaultEncapsulation;
      this.useJit = !!useJit;
      this.jitDevMode = !!jitDevMode;
      this.missingTranslation = missingTranslation;
      this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));
      this.strictInjectionParameters = strictInjectionParameters === true;
    };

    function preserveWhitespacesDefault(preserveWhitespacesOption) {
      var defaultSetting = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var DirectiveNormalizer =
    /*#__PURE__*/
    function () {
      function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {
        _classCallCheck(this, DirectiveNormalizer);

        this._resourceLoader = _resourceLoader;
        this._urlResolver = _urlResolver;
        this._htmlParser = _htmlParser;
        this._config = _config;
        this._resourceLoaderCache = new Map();
      }

      _createClass(DirectiveNormalizer, [{
        key: "clearCache",
        value: function clearCache() {
          this._resourceLoaderCache.clear();
        }
      }, {
        key: "clearCacheFor",
        value: function clearCacheFor(normalizedDirective) {
          var _this187 = this;

          if (!normalizedDirective.isComponent) {
            return;
          }

          var template = normalizedDirective.template;

          this._resourceLoaderCache.delete(template.templateUrl);

          template.externalStylesheets.forEach(function (stylesheet) {
            _this187._resourceLoaderCache.delete(stylesheet.moduleUrl);
          });
        }
      }, {
        key: "_fetch",
        value: function _fetch(url) {
          var result = this._resourceLoaderCache.get(url);

          if (!result) {
            result = this._resourceLoader.get(url);

            this._resourceLoaderCache.set(url, result);
          }

          return result;
        }
      }, {
        key: "normalizeTemplate",
        value: function normalizeTemplate(prenormData) {
          var _this188 = this;

          if (isDefined(prenormData.template)) {
            if (isDefined(prenormData.templateUrl)) {
              throw syntaxError("'".concat(stringify(prenormData.componentType), "' component cannot define both template and templateUrl"));
            }

            if (typeof prenormData.template !== 'string') {
              throw syntaxError("The template specified for component ".concat(stringify(prenormData.componentType), " is not a string"));
            }
          } else if (isDefined(prenormData.templateUrl)) {
            if (typeof prenormData.templateUrl !== 'string') {
              throw syntaxError("The templateUrl specified for component ".concat(stringify(prenormData.componentType), " is not a string"));
            }
          } else {
            throw syntaxError("No template specified for component ".concat(stringify(prenormData.componentType)));
          }

          if (isDefined(prenormData.preserveWhitespaces) && typeof prenormData.preserveWhitespaces !== 'boolean') {
            throw syntaxError("The preserveWhitespaces option for component ".concat(stringify(prenormData.componentType), " must be a boolean"));
          }

          return SyncAsync.then(this._preParseTemplate(prenormData), function (preparsedTemplate) {
            return _this188._normalizeTemplateMetadata(prenormData, preparsedTemplate);
          });
        }
      }, {
        key: "_preParseTemplate",
        value: function _preParseTemplate(prenomData) {
          var _this189 = this;

          var template;
          var templateUrl;

          if (prenomData.template != null) {
            template = prenomData.template;
            templateUrl = prenomData.moduleUrl;
          } else {
            templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);
            template = this._fetch(templateUrl);
          }

          return SyncAsync.then(template, function (template) {
            return _this189._preparseLoadedTemplate(prenomData, template, templateUrl);
          });
        }
      }, {
        key: "_preparseLoadedTemplate",
        value: function _preparseLoadedTemplate(prenormData, template, templateAbsUrl) {
          var isInline = !!prenormData.template;
          var interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation);
          var templateUrl = templateSourceUrl({
            reference: prenormData.ngModuleType
          }, {
            type: {
              reference: prenormData.componentType
            }
          }, {
            isInline: isInline,
            templateUrl: templateAbsUrl
          });

          var rootNodesAndErrors = this._htmlParser.parse(template, templateUrl, {
            tokenizeExpansionForms: true,
            interpolationConfig: interpolationConfig
          });

          if (rootNodesAndErrors.errors.length > 0) {
            var errorString = rootNodesAndErrors.errors.join('\n');
            throw syntaxError("Template parse errors:\n".concat(errorString));
          }

          var templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({
            styles: prenormData.styles,
            moduleUrl: prenormData.moduleUrl
          }));

          var visitor = new TemplatePreparseVisitor();
          visitAll$1(visitor, rootNodesAndErrors.rootNodes);

          var templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({
            styles: visitor.styles,
            styleUrls: visitor.styleUrls,
            moduleUrl: templateAbsUrl
          }));

          var styles = templateMetadataStyles.styles.concat(templateStyles.styles);
          var inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);

          var styleUrls = this._normalizeStylesheet(new CompileStylesheetMetadata({
            styleUrls: prenormData.styleUrls,
            moduleUrl: prenormData.moduleUrl
          })).styleUrls;

          return {
            template: template,
            templateUrl: templateAbsUrl,
            isInline: isInline,
            htmlAst: rootNodesAndErrors,
            styles: styles,
            inlineStyleUrls: inlineStyleUrls,
            styleUrls: styleUrls,
            ngContentSelectors: visitor.ngContentSelectors
          };
        }
      }, {
        key: "_normalizeTemplateMetadata",
        value: function _normalizeTemplateMetadata(prenormData, preparsedTemplate) {
          var _this190 = this;

          return SyncAsync.then(this._loadMissingExternalStylesheets(preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)), function (externalStylesheets) {
            return _this190._normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, externalStylesheets);
          });
        }
      }, {
        key: "_normalizeLoadedTemplateMetadata",
        value: function _normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, stylesheets) {
          var _this191 = this;

          // Algorithm:
          // - produce exactly 1 entry per original styleUrl in
          // CompileTemplateMetadata.externalStylesheets with all styles inlined
          // - inline all styles that are referenced by the template into CompileTemplateMetadata.styles.
          // Reason: be able to determine how many stylesheets there are even without loading
          // the template nor the stylesheets, so we can create a stub for TypeScript always synchronously
          // (as resource loading may be async)
          var styles = _toConsumableArray(preparsedTemplate.styles);

          this._inlineStyles(preparsedTemplate.inlineStyleUrls, stylesheets, styles);

          var styleUrls = preparsedTemplate.styleUrls;
          var externalStylesheets = styleUrls.map(function (styleUrl) {
            var stylesheet = stylesheets.get(styleUrl);

            var styles = _toConsumableArray(stylesheet.styles);

            _this191._inlineStyles(stylesheet.styleUrls, stylesheets, styles);

            return new CompileStylesheetMetadata({
              moduleUrl: styleUrl,
              styles: styles
            });
          });
          var encapsulation = prenormData.encapsulation;

          if (encapsulation == null) {
            encapsulation = this._config.defaultEncapsulation;
          }

          if (encapsulation === ViewEncapsulation.Emulated && styles.length === 0 && styleUrls.length === 0) {
            encapsulation = ViewEncapsulation.None;
          }

          return new CompileTemplateMetadata({
            encapsulation: encapsulation,
            template: preparsedTemplate.template,
            templateUrl: preparsedTemplate.templateUrl,
            htmlAst: preparsedTemplate.htmlAst,
            styles: styles,
            styleUrls: styleUrls,
            ngContentSelectors: preparsedTemplate.ngContentSelectors,
            animations: prenormData.animations,
            interpolation: prenormData.interpolation,
            isInline: preparsedTemplate.isInline,
            externalStylesheets: externalStylesheets,
            preserveWhitespaces: preserveWhitespacesDefault(prenormData.preserveWhitespaces, this._config.preserveWhitespaces)
          });
        }
      }, {
        key: "_inlineStyles",
        value: function _inlineStyles(styleUrls, stylesheets, targetStyles) {
          var _this192 = this;

          styleUrls.forEach(function (styleUrl) {
            var stylesheet = stylesheets.get(styleUrl);
            stylesheet.styles.forEach(function (style) {
              return targetStyles.push(style);
            });

            _this192._inlineStyles(stylesheet.styleUrls, stylesheets, targetStyles);
          });
        }
      }, {
        key: "_loadMissingExternalStylesheets",
        value: function _loadMissingExternalStylesheets(styleUrls) {
          var _this193 = this;

          var loadedStylesheets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();
          return SyncAsync.then(SyncAsync.all(styleUrls.filter(function (styleUrl) {
            return !loadedStylesheets.has(styleUrl);
          }).map(function (styleUrl) {
            return SyncAsync.then(_this193._fetch(styleUrl), function (loadedStyle) {
              var stylesheet = _this193._normalizeStylesheet(new CompileStylesheetMetadata({
                styles: [loadedStyle],
                moduleUrl: styleUrl
              }));

              loadedStylesheets.set(styleUrl, stylesheet);
              return _this193._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
            });
          })), function (_) {
            return loadedStylesheets;
          });
        }
      }, {
        key: "_normalizeStylesheet",
        value: function _normalizeStylesheet(stylesheet) {
          var _this194 = this;

          var moduleUrl = stylesheet.moduleUrl;
          var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable).map(function (url) {
            return _this194._urlResolver.resolve(moduleUrl, url);
          });
          var allStyles = stylesheet.styles.map(function (style) {
            var styleWithImports = extractStyleUrls(_this194._urlResolver, moduleUrl, style);
            allStyleUrls.push.apply(allStyleUrls, _toConsumableArray(styleWithImports.styleUrls));
            return styleWithImports.style;
          });
          return new CompileStylesheetMetadata({
            styles: allStyles,
            styleUrls: allStyleUrls,
            moduleUrl: moduleUrl
          });
        }
      }]);

      return DirectiveNormalizer;
    }();

    var TemplatePreparseVisitor =
    /*#__PURE__*/
    function () {
      function TemplatePreparseVisitor() {
        _classCallCheck(this, TemplatePreparseVisitor);

        this.ngContentSelectors = [];
        this.styles = [];
        this.styleUrls = [];
        this.ngNonBindableStackCount = 0;
      }

      _createClass(TemplatePreparseVisitor, [{
        key: "visitElement",
        value: function visitElement(ast, context) {
          var preparsedElement = preparseElement(ast);

          switch (preparsedElement.type) {
            case PreparsedElementType.NG_CONTENT:
              if (this.ngNonBindableStackCount === 0) {
                this.ngContentSelectors.push(preparsedElement.selectAttr);
              }

              break;

            case PreparsedElementType.STYLE:
              var textContent = '';
              ast.children.forEach(function (child) {
                if (child instanceof Text$3) {
                  textContent += child.value;
                }
              });
              this.styles.push(textContent);
              break;

            case PreparsedElementType.STYLESHEET:
              this.styleUrls.push(preparsedElement.hrefAttr);
              break;

            default:
              break;
          }

          if (preparsedElement.nonBindable) {
            this.ngNonBindableStackCount++;
          }

          visitAll$1(this, ast.children);

          if (preparsedElement.nonBindable) {
            this.ngNonBindableStackCount--;
          }

          return null;
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(ast, context) {
          visitAll$1(this, ast.cases);
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(ast, context) {
          visitAll$1(this, ast.expression);
        }
      }, {
        key: "visitComment",
        value: function visitComment(ast, context) {
          return null;
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(ast, context) {
          return null;
        }
      }, {
        key: "visitText",
        value: function visitText(ast, context) {
          return null;
        }
      }]);

      return TemplatePreparseVisitor;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var QUERY_METADATA_IDENTIFIERS = [createViewChild, createViewChildren, createContentChild, createContentChildren];
    /*
     * Resolve a `Type` for {@link Directive}.
     *
     * This interface can be overridden by the application developer to create custom behavior.
     *
     * See {@link Compiler}
     */

    var DirectiveResolver =
    /*#__PURE__*/
    function () {
      function DirectiveResolver(_reflector) {
        _classCallCheck(this, DirectiveResolver);

        this._reflector = _reflector;
      }

      _createClass(DirectiveResolver, [{
        key: "isDirective",
        value: function isDirective(type) {
          var typeMetadata = this._reflector.annotations(resolveForwardRef(type));

          return typeMetadata && typeMetadata.some(isDirectiveMetadata);
        }
      }, {
        key: "resolve",
        value: function resolve(type) {
          var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          var typeMetadata = this._reflector.annotations(resolveForwardRef(type));

          if (typeMetadata) {
            var metadata = findLast(typeMetadata, isDirectiveMetadata);

            if (metadata) {
              var propertyMetadata = this._reflector.propMetadata(type);

              var guards = this._reflector.guards(type);

              return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);
            }
          }

          if (throwIfNotFound) {
            throw new Error("No Directive annotation found on ".concat(stringify(type)));
          }

          return null;
        }
      }, {
        key: "_mergeWithPropertyMetadata",
        value: function _mergeWithPropertyMetadata(dm, propertyMetadata, guards, directiveType) {
          var inputs = [];
          var outputs = [];
          var host = {};
          var queries = {};
          Object.keys(propertyMetadata).forEach(function (propName) {
            var input = findLast(propertyMetadata[propName], function (a) {
              return createInput.isTypeOf(a);
            });

            if (input) {
              if (input.bindingPropertyName) {
                inputs.push("".concat(propName, ": ").concat(input.bindingPropertyName));
              } else {
                inputs.push(propName);
              }
            }

            var output = findLast(propertyMetadata[propName], function (a) {
              return createOutput.isTypeOf(a);
            });

            if (output) {
              if (output.bindingPropertyName) {
                outputs.push("".concat(propName, ": ").concat(output.bindingPropertyName));
              } else {
                outputs.push(propName);
              }
            }

            var hostBindings = propertyMetadata[propName].filter(function (a) {
              return createHostBinding.isTypeOf(a);
            });
            hostBindings.forEach(function (hostBinding) {
              if (hostBinding.hostPropertyName) {
                var startWith = hostBinding.hostPropertyName[0];

                if (startWith === '(') {
                  throw new Error("@HostBinding can not bind to events. Use @HostListener instead.");
                } else if (startWith === '[') {
                  throw new Error("@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.");
                }

                host["[".concat(hostBinding.hostPropertyName, "]")] = propName;
              } else {
                host["[".concat(propName, "]")] = propName;
              }
            });
            var hostListeners = propertyMetadata[propName].filter(function (a) {
              return createHostListener.isTypeOf(a);
            });
            hostListeners.forEach(function (hostListener) {
              var args = hostListener.args || [];
              host["(".concat(hostListener.eventName, ")")] = "".concat(propName, "(").concat(args.join(','), ")");
            });
            var query = findLast(propertyMetadata[propName], function (a) {
              return QUERY_METADATA_IDENTIFIERS.some(function (i) {
                return i.isTypeOf(a);
              });
            });

            if (query) {
              queries[propName] = query;
            }
          });
          return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);
        }
      }, {
        key: "_extractPublicName",
        value: function _extractPublicName(def) {
          return splitAtColon(def, [null, def])[1].trim();
        }
      }, {
        key: "_dedupeBindings",
        value: function _dedupeBindings(bindings) {
          var names = new Set();
          var publicNames = new Set();
          var reversedResult = []; // go last to first to allow later entries to overwrite previous entries

          for (var i = bindings.length - 1; i >= 0; i--) {
            var binding = bindings[i];

            var name = this._extractPublicName(binding);

            publicNames.add(name);

            if (!names.has(name)) {
              names.add(name);
              reversedResult.push(binding);
            }
          }

          return reversedResult.reverse();
        }
      }, {
        key: "_merge",
        value: function _merge(directive, inputs, outputs, host, queries, guards, directiveType) {
          var mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);

          var mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);

          var mergedHost = directive.host ? Object.assign(Object.assign({}, directive.host), host) : host;
          var mergedQueries = directive.queries ? Object.assign(Object.assign({}, directive.queries), queries) : queries;

          if (createComponent.isTypeOf(directive)) {
            var comp = directive;
            return createComponent({
              selector: comp.selector,
              inputs: mergedInputs,
              outputs: mergedOutputs,
              host: mergedHost,
              exportAs: comp.exportAs,
              moduleId: comp.moduleId,
              queries: mergedQueries,
              changeDetection: comp.changeDetection,
              providers: comp.providers,
              viewProviders: comp.viewProviders,
              entryComponents: comp.entryComponents,
              template: comp.template,
              templateUrl: comp.templateUrl,
              styles: comp.styles,
              styleUrls: comp.styleUrls,
              encapsulation: comp.encapsulation,
              animations: comp.animations,
              interpolation: comp.interpolation,
              preserveWhitespaces: directive.preserveWhitespaces
            });
          } else {
            return createDirective({
              selector: directive.selector,
              inputs: mergedInputs,
              outputs: mergedOutputs,
              host: mergedHost,
              exportAs: directive.exportAs,
              queries: mergedQueries,
              providers: directive.providers,
              guards: guards
            });
          }
        }
      }]);

      return DirectiveResolver;
    }();

    function isDirectiveMetadata(type) {
      return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);
    }

    function findLast(arr, condition) {
      for (var i = arr.length - 1; i >= 0; i--) {
        if (condition(arr[i])) {
          return arr[i];
        }
      }

      return null;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * An i18n error.
     */


    var I18nError =
    /*#__PURE__*/
    function (_ParseError6) {
      _inherits(I18nError, _ParseError6);

      function I18nError(span, msg) {
        _classCallCheck(this, I18nError);

        return _possibleConstructorReturn(this, _getPrototypeOf(I18nError).call(this, span, msg));
      }

      return I18nError;
    }(ParseError);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _I18N_ATTR = 'i18n';
    var _I18N_ATTR_PREFIX = 'i18n-';
    var _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;
    var MEANING_SEPARATOR = '|';
    var ID_SEPARATOR = '@@';
    var i18nCommentsWarned = false;
    /**
     * Extract translatable messages from an html AST
     */

    function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {
      var visitor = new _Visitor$2(implicitTags, implicitAttrs);
      return visitor.extract(nodes, interpolationConfig);
    }

    function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {
      var visitor = new _Visitor$2(implicitTags, implicitAttrs);
      return visitor.merge(nodes, translations, interpolationConfig);
    }

    var ExtractionResult = function ExtractionResult(messages, errors) {
      _classCallCheck(this, ExtractionResult);

      this.messages = messages;
      this.errors = errors;
    };

    var _VisitorMode;

    (function (_VisitorMode) {
      _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
      _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
    })(_VisitorMode || (_VisitorMode = {}));
    /**
     * This Visitor is used:
     * 1. to extract all the translatable strings from an html AST (see `extract()`),
     * 2. to replace the translatable strings with the actual translations (see `merge()`)
     *
     * @internal
     */


    var _Visitor$2 =
    /*#__PURE__*/
    function () {
      function _Visitor$2(_implicitTags, _implicitAttrs) {
        _classCallCheck(this, _Visitor$2);

        this._implicitTags = _implicitTags;
        this._implicitAttrs = _implicitAttrs;
      }
      /**
       * Extracts the messages from the tree
       */


      _createClass(_Visitor$2, [{
        key: "extract",
        value: function extract(nodes, interpolationConfig) {
          var _this195 = this;

          this._init(_VisitorMode.Extract, interpolationConfig);

          nodes.forEach(function (node) {
            return node.visit(_this195, null);
          });

          if (this._inI18nBlock) {
            this._reportError(nodes[nodes.length - 1], 'Unclosed block');
          }

          return new ExtractionResult(this._messages, this._errors);
        }
        /**
         * Returns a tree where all translatable nodes are translated
         */

      }, {
        key: "merge",
        value: function merge(nodes, translations, interpolationConfig) {
          this._init(_VisitorMode.Merge, interpolationConfig);

          this._translations = translations; // Construct a single fake root element

          var wrapper = new Element$1('wrapper', [], nodes, undefined, undefined, undefined);
          var translatedNode = wrapper.visit(this, null);

          if (this._inI18nBlock) {
            this._reportError(nodes[nodes.length - 1], 'Unclosed block');
          }

          return new ParseTreeResult(translatedNode.children, this._errors);
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(icuCase, context) {
          // Parse cases for translatable html attributes
          var expression = visitAll$1(this, icuCase.expression, context);

          if (this._mode === _VisitorMode.Merge) {
            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);
          }
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(icu, context) {
          this._mayBeAddBlockChildren(icu);

          var wasInIcu = this._inIcu;

          if (!this._inIcu) {
            // nested ICU messages should not be extracted but top-level translated as a whole
            if (this._isInTranslatableSection) {
              this._addMessage([icu]);
            }

            this._inIcu = true;
          }

          var cases = visitAll$1(this, icu.cases, context);

          if (this._mode === _VisitorMode.Merge) {
            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);
          }

          this._inIcu = wasInIcu;
          return icu;
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {
          var isOpening = _isOpeningComment(comment);

          if (isOpening && this._isInTranslatableSection) {
            this._reportError(comment, 'Could not start a block inside a translatable section');

            return;
          }

          var isClosing = _isClosingComment(comment);

          if (isClosing && !this._inI18nBlock) {
            this._reportError(comment, 'Trying to close an unopened block');

            return;
          }

          if (!this._inI18nNode && !this._inIcu) {
            if (!this._inI18nBlock) {
              if (isOpening) {
                // deprecated from v5 you should use <ng-container i18n> instead of i18n comments
                if (!i18nCommentsWarned && console && console.warn) {
                  i18nCommentsWarned = true;
                  var details = comment.sourceSpan.details ? ", ".concat(comment.sourceSpan.details) : ''; // TODO(ocombe): use a log service once there is a public one available

                  console.warn("I18n comments are deprecated, use an <ng-container> element instead (".concat(comment.sourceSpan.start).concat(details, ")"));
                }

                this._inI18nBlock = true;
                this._blockStartDepth = this._depth;
                this._blockChildren = [];
                this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();

                this._openTranslatableSection(comment);
              }
            } else {
              if (isClosing) {
                if (this._depth == this._blockStartDepth) {
                  this._closeTranslatableSection(comment, this._blockChildren);

                  this._inI18nBlock = false;

                  var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc); // merge attributes in sections


                  var nodes = this._translateMessage(comment, message);

                  return visitAll$1(this, nodes);
                } else {
                  this._reportError(comment, 'I18N blocks should not cross element boundaries');

                  return;
                }
              }
            }
          }
        }
      }, {
        key: "visitText",
        value: function visitText(text, context) {
          if (this._isInTranslatableSection) {
            this._mayBeAddBlockChildren(text);
          }

          return text;
        }
      }, {
        key: "visitElement",
        value: function visitElement(el, context) {
          var _this196 = this;

          this._mayBeAddBlockChildren(el);

          this._depth++;
          var wasInI18nNode = this._inI18nNode;
          var wasInImplicitNode = this._inImplicitNode;
          var childNodes = [];
          var translatedChildNodes = undefined; // Extract:
          // - top level nodes with the (implicit) "i18n" attribute if not already in a section
          // - ICU messages

          var i18nAttr = _getI18nAttr(el);

          var i18nMeta = i18nAttr ? i18nAttr.value : '';
          var isImplicit = this._implicitTags.some(function (tag) {
            return el.name === tag;
          }) && !this._inIcu && !this._isInTranslatableSection;
          var isTopLevelImplicit = !wasInImplicitNode && isImplicit;
          this._inImplicitNode = wasInImplicitNode || isImplicit;

          if (!this._isInTranslatableSection && !this._inIcu) {
            if (i18nAttr || isTopLevelImplicit) {
              this._inI18nNode = true;

              var message = this._addMessage(el.children, i18nMeta);

              translatedChildNodes = this._translateMessage(el, message);
            }

            if (this._mode == _VisitorMode.Extract) {
              var isTranslatable = i18nAttr || isTopLevelImplicit;
              if (isTranslatable) this._openTranslatableSection(el);
              visitAll$1(this, el.children);
              if (isTranslatable) this._closeTranslatableSection(el, el.children);
            }
          } else {
            if (i18nAttr || isTopLevelImplicit) {
              this._reportError(el, 'Could not mark an element as translatable inside a translatable section');
            }

            if (this._mode == _VisitorMode.Extract) {
              // Descend into child nodes for extraction
              visitAll$1(this, el.children);
            }
          }

          if (this._mode === _VisitorMode.Merge) {
            var visitNodes = translatedChildNodes || el.children;
            visitNodes.forEach(function (child) {
              var visited = child.visit(_this196, context);

              if (visited && !_this196._isInTranslatableSection) {
                // Do not add the children from translatable sections (= i18n blocks here)
                // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)
                childNodes = childNodes.concat(visited);
              }
            });
          }

          this._visitAttributesOf(el);

          this._depth--;
          this._inI18nNode = wasInI18nNode;
          this._inImplicitNode = wasInImplicitNode;

          if (this._mode === _VisitorMode.Merge) {
            var translatedAttrs = this._translateAttributes(el);

            return new Element$1(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
          }

          return null;
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {
          throw new Error('unreachable code');
        }
      }, {
        key: "_init",
        value: function _init(mode, interpolationConfig) {
          this._mode = mode;
          this._inI18nBlock = false;
          this._inI18nNode = false;
          this._depth = 0;
          this._inIcu = false;
          this._msgCountAtSectionStart = undefined;
          this._errors = [];
          this._messages = [];
          this._inImplicitNode = false;
          this._createI18nMessage = createI18nMessageFactory(interpolationConfig);
        } // looks for translatable attributes

      }, {
        key: "_visitAttributesOf",
        value: function _visitAttributesOf(el) {
          var _this197 = this;

          var explicitAttrNameToValue = {};
          var implicitAttrNames = this._implicitAttrs[el.name] || [];
          el.attrs.filter(function (attr) {
            return attr.name.startsWith(_I18N_ATTR_PREFIX);
          }).forEach(function (attr) {
            return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = attr.value;
          });
          el.attrs.forEach(function (attr) {
            if (attr.name in explicitAttrNameToValue) {
              _this197._addMessage([attr], explicitAttrNameToValue[attr.name]);
            } else if (implicitAttrNames.some(function (name) {
              return attr.name === name;
            })) {
              _this197._addMessage([attr]);
            }
          });
        } // add a translatable message

      }, {
        key: "_addMessage",
        value: function _addMessage(ast, msgMeta) {
          if (ast.length == 0 || ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {
            // Do not create empty messages
            return null;
          }

          var _parseMessageMeta2 = _parseMessageMeta(msgMeta),
              meaning = _parseMessageMeta2.meaning,
              description = _parseMessageMeta2.description,
              id = _parseMessageMeta2.id;

          var message = this._createI18nMessage(ast, meaning, description, id);

          this._messages.push(message);

          return message;
        } // Translates the given message given the `TranslationBundle`
        // This is used for translating elements / blocks - see `_translateAttributes` for attributes
        // no-op when called in extraction mode (returns [])

      }, {
        key: "_translateMessage",
        value: function _translateMessage(el, message) {
          if (message && this._mode === _VisitorMode.Merge) {
            var nodes = this._translations.get(message);

            if (nodes) {
              return nodes;
            }

            this._reportError(el, "Translation unavailable for message id=\"".concat(this._translations.digest(message), "\""));
          }

          return [];
        } // translate the attributes of an element and remove i18n specific attributes

      }, {
        key: "_translateAttributes",
        value: function _translateAttributes(el) {
          var _this198 = this;

          var attributes = el.attrs;
          var i18nParsedMessageMeta = {};
          attributes.forEach(function (attr) {
            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {
              i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _parseMessageMeta(attr.value);
            }
          });
          var translatedAttributes = [];
          attributes.forEach(function (attr) {
            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {
              // strip i18n specific attributes
              return;
            }

            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {
              var _i18nParsedMessageMet = i18nParsedMessageMeta[attr.name],
                  meaning = _i18nParsedMessageMet.meaning,
                  description = _i18nParsedMessageMet.description,
                  id = _i18nParsedMessageMet.id;

              var message = _this198._createI18nMessage([attr], meaning, description, id);

              var nodes = _this198._translations.get(message);

              if (nodes) {
                if (nodes.length == 0) {
                  translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan));
                } else if (nodes[0] instanceof Text$3) {
                  var value = nodes[0].value;
                  translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan));
                } else {
                  _this198._reportError(el, "Unexpected translation for attribute \"".concat(attr.name, "\" (id=\"").concat(id || _this198._translations.digest(message), "\")"));
                }
              } else {
                _this198._reportError(el, "Translation unavailable for attribute \"".concat(attr.name, "\" (id=\"").concat(id || _this198._translations.digest(message), "\")"));
              }
            } else {
              translatedAttributes.push(attr);
            }
          });
          return translatedAttributes;
        }
        /**
         * Add the node as a child of the block when:
         * - we are in a block,
         * - we are not inside a ICU message (those are handled separately),
         * - the node is a "direct child" of the block
         */

      }, {
        key: "_mayBeAddBlockChildren",
        value: function _mayBeAddBlockChildren(node) {
          if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {
            this._blockChildren.push(node);
          }
        }
        /**
         * Marks the start of a section, see `_closeTranslatableSection`
         */

      }, {
        key: "_openTranslatableSection",
        value: function _openTranslatableSection(node) {
          if (this._isInTranslatableSection) {
            this._reportError(node, 'Unexpected section start');
          } else {
            this._msgCountAtSectionStart = this._messages.length;
          }
        }
        /**
         * A translatable section could be:
         * - the content of translatable element,
         * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments
         */

      }, {
        key: "_closeTranslatableSection",

        /**
         * Terminates a section.
         *
         * If a section has only one significant children (comments not significant) then we should not
         * keep the message from this children:
         *
         * `<p i18n="meaning|description">{ICU message}</p>` would produce two messages:
         * - one for the <p> content with meaning and description,
         * - another one for the ICU message.
         *
         * In this case the last message is discarded as it contains less information (the AST is
         * otherwise identical).
         *
         * Note that we should still keep messages extracted from attributes inside the section (ie in the
         * ICU message here)
         */
        value: function _closeTranslatableSection(node, directChildren) {
          if (!this._isInTranslatableSection) {
            this._reportError(node, 'Unexpected section end');

            return;
          }

          var startIndex = this._msgCountAtSectionStart;
          var significantChildren = directChildren.reduce(function (count, node) {
            return count + (node instanceof Comment ? 0 : 1);
          }, 0);

          if (significantChildren == 1) {
            for (var i = this._messages.length - 1; i >= startIndex; i--) {
              var ast = this._messages[i].nodes;

              if (!(ast.length == 1 && ast[0] instanceof Text$1)) {
                this._messages.splice(i, 1);

                break;
              }
            }
          }

          this._msgCountAtSectionStart = undefined;
        }
      }, {
        key: "_reportError",
        value: function _reportError(node, msg) {
          this._errors.push(new I18nError(node.sourceSpan, msg));
        }
      }, {
        key: "_isInTranslatableSection",
        get: function get() {
          return this._msgCountAtSectionStart !== void 0;
        }
      }]);

      return _Visitor$2;
    }();

    function _isOpeningComment(n) {
      return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));
    }

    function _isClosingComment(n) {
      return !!(n instanceof Comment && n.value && n.value === '/i18n');
    }

    function _getI18nAttr(p) {
      return p.attrs.find(function (attr) {
        return attr.name === _I18N_ATTR;
      }) || null;
    }

    function _parseMessageMeta(i18n) {
      if (!i18n) return {
        meaning: '',
        description: '',
        id: ''
      };
      var idIndex = i18n.indexOf(ID_SEPARATOR);
      var descIndex = i18n.indexOf(MEANING_SEPARATOR);

      var _ref22 = idIndex > -1 ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''],
          _ref23 = _slicedToArray(_ref22, 2),
          meaningAndDesc = _ref23[0],
          id = _ref23[1];

      var _ref24 = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc],
          _ref25 = _slicedToArray(_ref24, 2),
          meaning = _ref25[0],
          description = _ref25[1];

      return {
        meaning: meaning,
        description: description,
        id: id.trim()
      };
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var XmlTagDefinition =
    /*#__PURE__*/
    function () {
      function XmlTagDefinition() {
        _classCallCheck(this, XmlTagDefinition);

        this.closedByParent = false;
        this.contentType = TagContentType.PARSABLE_DATA;
        this.isVoid = false;
        this.ignoreFirstLf = false;
        this.canSelfClose = true;
      }

      _createClass(XmlTagDefinition, [{
        key: "requireExtraParent",
        value: function requireExtraParent(currentParent) {
          return false;
        }
      }, {
        key: "isClosedByChild",
        value: function isClosedByChild(name) {
          return false;
        }
      }]);

      return XmlTagDefinition;
    }();

    var _TAG_DEFINITION = new XmlTagDefinition();

    function getXmlTagDefinition(tagName) {
      return _TAG_DEFINITION;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var XmlParser =
    /*#__PURE__*/
    function (_Parser2) {
      _inherits(XmlParser, _Parser2);

      function XmlParser() {
        _classCallCheck(this, XmlParser);

        return _possibleConstructorReturn(this, _getPrototypeOf(XmlParser).call(this, getXmlTagDefinition));
      }

      _createClass(XmlParser, [{
        key: "parse",
        value: function parse(source, url, options) {
          return _get(_getPrototypeOf(XmlParser.prototype), "parse", this).call(this, source, url, options);
        }
      }]);

      return XmlParser;
    }(Parser);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _VERSION = '1.2';
    var _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2'; // TODO(vicb): make this a param (s/_/-/)

    var _DEFAULT_SOURCE_LANG = 'en';
    var _PLACEHOLDER_TAG$1 = 'x';
    var _MARKER_TAG = 'mrk';
    var _FILE_TAG = 'file';
    var _SOURCE_TAG$1 = 'source';
    var _SEGMENT_SOURCE_TAG = 'seg-source';
    var _ALT_TRANS_TAG = 'alt-trans';
    var _TARGET_TAG = 'target';
    var _UNIT_TAG = 'trans-unit';
    var _CONTEXT_GROUP_TAG = 'context-group';
    var _CONTEXT_TAG = 'context'; // http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html
    // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html

    var Xliff =
    /*#__PURE__*/
    function (_Serializer2) {
      _inherits(Xliff, _Serializer2);

      function Xliff() {
        _classCallCheck(this, Xliff);

        return _possibleConstructorReturn(this, _getPrototypeOf(Xliff).apply(this, arguments));
      }

      _createClass(Xliff, [{
        key: "write",
        value: function write(messages, locale) {
          var visitor = new _WriteVisitor();
          var transUnits = [];
          messages.forEach(function (message) {
            var _transUnit$children;

            var contextTags = [];
            message.sources.forEach(function (source) {
              var contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, {
                purpose: 'location'
              });
              contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, {
                'context-type': 'sourcefile'
              }, [new Text$2(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, {
                'context-type': 'linenumber'
              }, [new Text$2("".concat(source.startLine))]), new CR(8));
              contextTags.push(new CR(8), contextGroupTag);
            });
            var transUnit = new Tag(_UNIT_TAG, {
              id: message.id,
              datatype: 'html'
            });

            (_transUnit$children = transUnit.children).push.apply(_transUnit$children, [new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes))].concat(contextTags));

            if (message.description) {
              transUnit.children.push(new CR(8), new Tag('note', {
                priority: '1',
                from: 'description'
              }, [new Text$2(message.description)]));
            }

            if (message.meaning) {
              transUnit.children.push(new CR(8), new Tag('note', {
                priority: '1',
                from: 'meaning'
              }, [new Text$2(message.meaning)]));
            }

            transUnit.children.push(new CR(6));
            transUnits.push(new CR(6), transUnit);
          });
          var body = new Tag('body', {}, [].concat(transUnits, [new CR(4)]));
          var file = new Tag('file', {
            'source-language': locale || _DEFAULT_SOURCE_LANG,
            datatype: 'plaintext',
            original: 'ng2.template'
          }, [new CR(4), body, new CR(2)]);
          var xliff = new Tag('xliff', {
            version: _VERSION,
            xmlns: _XMLNS
          }, [new CR(2), file, new CR()]);
          return serialize([new Declaration({
            version: '1.0',
            encoding: 'UTF-8'
          }), new CR(), xliff, new CR()]);
        }
      }, {
        key: "load",
        value: function load(content, url) {
          // xliff to xml nodes
          var xliffParser = new XliffParser();

          var _xliffParser$parse = xliffParser.parse(content, url),
              locale = _xliffParser$parse.locale,
              msgIdToHtml = _xliffParser$parse.msgIdToHtml,
              errors = _xliffParser$parse.errors; // xml nodes to i18n nodes


          var i18nNodesByMsgId = {};
          var converter = new XmlToI18n();
          Object.keys(msgIdToHtml).forEach(function (msgId) {
            var _converter$convert = converter.convert(msgIdToHtml[msgId], url),
                i18nNodes = _converter$convert.i18nNodes,
                e = _converter$convert.errors;

            errors.push.apply(errors, _toConsumableArray(e));
            i18nNodesByMsgId[msgId] = i18nNodes;
          });

          if (errors.length) {
            throw new Error("xliff parse errors:\n".concat(errors.join('\n')));
          }

          return {
            locale: locale,
            i18nNodesByMsgId: i18nNodesByMsgId
          };
        }
      }, {
        key: "digest",
        value: function digest(message) {
          return _digest2(message);
        }
      }]);

      return Xliff;
    }(Serializer);

    var _WriteVisitor =
    /*#__PURE__*/
    function () {
      function _WriteVisitor() {
        _classCallCheck(this, _WriteVisitor);
      }

      _createClass(_WriteVisitor, [{
        key: "visitText",
        value: function visitText(text, context) {
          return [new Text$2(text.value)];
        }
      }, {
        key: "visitContainer",
        value: function visitContainer(container, context) {
          var _this199 = this;

          var nodes = [];
          container.children.forEach(function (node) {
            return nodes.push.apply(nodes, _toConsumableArray(node.visit(_this199)));
          });
          return nodes;
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu, context) {
          var _this200 = this;

          var nodes = [new Text$2("{".concat(icu.expressionPlaceholder, ", ").concat(icu.type, ", "))];
          Object.keys(icu.cases).forEach(function (c) {
            nodes.push.apply(nodes, [new Text$2("".concat(c, " {"))].concat(_toConsumableArray(icu.cases[c].visit(_this200)), [new Text$2("} ")]));
          });
          nodes.push(new Text$2("}"));
          return nodes;
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, context) {
          var ctype = getCtypeForTag(ph.tag);

          if (ph.isVoid) {
            // void tags have no children nor closing tags
            return [new Tag(_PLACEHOLDER_TAG$1, {
              id: ph.startName,
              ctype: ctype,
              'equiv-text': "<".concat(ph.tag, "/>")
            })];
          }

          var startTagPh = new Tag(_PLACEHOLDER_TAG$1, {
            id: ph.startName,
            ctype: ctype,
            'equiv-text': "<".concat(ph.tag, ">")
          });
          var closeTagPh = new Tag(_PLACEHOLDER_TAG$1, {
            id: ph.closeName,
            ctype: ctype,
            'equiv-text': "</".concat(ph.tag, ">")
          });
          return [startTagPh].concat(_toConsumableArray(this.serialize(ph.children)), [closeTagPh]);
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, context) {
          return [new Tag(_PLACEHOLDER_TAG$1, {
            id: ph.name,
            'equiv-text': "{{".concat(ph.value, "}}")
          })];
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          var equivText = "{".concat(ph.value.expression, ", ").concat(ph.value.type, ", ").concat(Object.keys(ph.value.cases).map(function (value) {
            return value + ' {...}';
          }).join(' '), "}");
          return [new Tag(_PLACEHOLDER_TAG$1, {
            id: ph.name,
            'equiv-text': equivText
          })];
        }
      }, {
        key: "serialize",
        value: function serialize(nodes) {
          var _ref26,
              _this201 = this;

          return (_ref26 = []).concat.apply(_ref26, _toConsumableArray(nodes.map(function (node) {
            return node.visit(_this201);
          })));
        }
      }]);

      return _WriteVisitor;
    }(); // TODO(vicb): add error management (structure)
    // Extract messages as xml nodes from the xliff file


    var XliffParser =
    /*#__PURE__*/
    function () {
      function XliffParser() {
        _classCallCheck(this, XliffParser);

        this._locale = null;
      }

      _createClass(XliffParser, [{
        key: "parse",
        value: function parse(xliff, url) {
          this._unitMlString = null;
          this._msgIdToHtml = {};
          var xml = new XmlParser().parse(xliff, url);
          this._errors = xml.errors;
          visitAll$1(this, xml.rootNodes, null);
          return {
            msgIdToHtml: this._msgIdToHtml,
            errors: this._errors,
            locale: this._locale
          };
        }
      }, {
        key: "visitElement",
        value: function visitElement(element, context) {
          switch (element.name) {
            case _UNIT_TAG:
              this._unitMlString = null;
              var idAttr = element.attrs.find(function (attr) {
                return attr.name === 'id';
              });

              if (!idAttr) {
                this._addError(element, "<".concat(_UNIT_TAG, "> misses the \"id\" attribute"));
              } else {
                var id = idAttr.value;

                if (this._msgIdToHtml.hasOwnProperty(id)) {
                  this._addError(element, "Duplicated translations for msg ".concat(id));
                } else {
                  visitAll$1(this, element.children, null);

                  if (typeof this._unitMlString === 'string') {
                    this._msgIdToHtml[id] = this._unitMlString;
                  } else {
                    this._addError(element, "Message ".concat(id, " misses a translation"));
                  }
                }
              }

              break;
            // ignore those tags

            case _SOURCE_TAG$1:
            case _SEGMENT_SOURCE_TAG:
            case _ALT_TRANS_TAG:
              break;

            case _TARGET_TAG:
              var innerTextStart = element.startSourceSpan.end.offset;
              var innerTextEnd = element.endSourceSpan.start.offset;
              var content = element.startSourceSpan.start.file.content;
              var innerText = content.slice(innerTextStart, innerTextEnd);
              this._unitMlString = innerText;
              break;

            case _FILE_TAG:
              var localeAttr = element.attrs.find(function (attr) {
                return attr.name === 'target-language';
              });

              if (localeAttr) {
                this._locale = localeAttr.value;
              }

              visitAll$1(this, element.children, null);
              break;

            default:
              // TODO(vicb): assert file structure, xliff version
              // For now only recurse on unhandled nodes
              visitAll$1(this, element.children, null);
          }
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {}
      }, {
        key: "visitText",
        value: function visitText(text, context) {}
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {}
      }, {
        key: "visitExpansion",
        value: function visitExpansion(expansion, context) {}
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(expansionCase, context) {}
      }, {
        key: "_addError",
        value: function _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
        }
      }]);

      return XliffParser;
    }(); // Convert ml nodes (xliff syntax) to i18n nodes


    var XmlToI18n =
    /*#__PURE__*/
    function () {
      function XmlToI18n() {
        _classCallCheck(this, XmlToI18n);
      }

      _createClass(XmlToI18n, [{
        key: "convert",
        value: function convert(message, url) {
          var _ref27;

          var xmlIcu = new XmlParser().parse(message, url, {
            tokenizeExpansionForms: true
          });
          this._errors = xmlIcu.errors;
          var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : (_ref27 = []).concat.apply(_ref27, _toConsumableArray(visitAll$1(this, xmlIcu.rootNodes)));
          return {
            i18nNodes: i18nNodes,
            errors: this._errors
          };
        }
      }, {
        key: "visitText",
        value: function visitText(text, context) {
          return new Text$1(text.value, text.sourceSpan);
        }
      }, {
        key: "visitElement",
        value: function visitElement(el, context) {
          if (el.name === _PLACEHOLDER_TAG$1) {
            var nameAttr = el.attrs.find(function (attr) {
              return attr.name === 'id';
            });

            if (nameAttr) {
              return new Placeholder('', nameAttr.value, el.sourceSpan);
            }

            this._addError(el, "<".concat(_PLACEHOLDER_TAG$1, "> misses the \"id\" attribute"));

            return null;
          }

          if (el.name === _MARKER_TAG) {
            var _ref28;

            return (_ref28 = []).concat.apply(_ref28, _toConsumableArray(visitAll$1(this, el.children)));
          }

          this._addError(el, "Unexpected tag");

          return null;
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(icu, context) {
          var caseMap = {};
          visitAll$1(this, icu.cases).forEach(function (c) {
            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
          });
          return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(icuCase, context) {
          return {
            value: icuCase.value,
            nodes: visitAll$1(this, icuCase.expression)
          };
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {}
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {}
      }, {
        key: "_addError",
        value: function _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
        }
      }]);

      return XmlToI18n;
    }();

    function getCtypeForTag(tag) {
      switch (tag.toLowerCase()) {
        case 'br':
          return 'lb';

        case 'img':
          return 'image';

        default:
          return "x-".concat(tag);
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _VERSION$1 = '2.0';
    var _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0'; // TODO(vicb): make this a param (s/_/-/)

    var _DEFAULT_SOURCE_LANG$1 = 'en';
    var _PLACEHOLDER_TAG$2 = 'ph';
    var _PLACEHOLDER_SPANNING_TAG = 'pc';
    var _MARKER_TAG$1 = 'mrk';
    var _XLIFF_TAG = 'xliff';
    var _SOURCE_TAG$2 = 'source';
    var _TARGET_TAG$1 = 'target';
    var _UNIT_TAG$1 = 'unit'; // http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html

    var Xliff2 =
    /*#__PURE__*/
    function (_Serializer3) {
      _inherits(Xliff2, _Serializer3);

      function Xliff2() {
        _classCallCheck(this, Xliff2);

        return _possibleConstructorReturn(this, _getPrototypeOf(Xliff2).apply(this, arguments));
      }

      _createClass(Xliff2, [{
        key: "write",
        value: function write(messages, locale) {
          var visitor = new _WriteVisitor$1();
          var units = [];
          messages.forEach(function (message) {
            var unit = new Tag(_UNIT_TAG$1, {
              id: message.id
            });
            var notes = new Tag('notes');

            if (message.description || message.meaning) {
              if (message.description) {
                notes.children.push(new CR(8), new Tag('note', {
                  category: 'description'
                }, [new Text$2(message.description)]));
              }

              if (message.meaning) {
                notes.children.push(new CR(8), new Tag('note', {
                  category: 'meaning'
                }, [new Text$2(message.meaning)]));
              }
            }

            message.sources.forEach(function (source) {
              notes.children.push(new CR(8), new Tag('note', {
                category: 'location'
              }, [new Text$2("".concat(source.filePath, ":").concat(source.startLine).concat(source.endLine !== source.startLine ? ',' + source.endLine : ''))]));
            });
            notes.children.push(new CR(6));
            unit.children.push(new CR(6), notes);
            var segment = new Tag('segment');
            segment.children.push(new CR(8), new Tag(_SOURCE_TAG$2, {}, visitor.serialize(message.nodes)), new CR(6));
            unit.children.push(new CR(6), segment, new CR(4));
            units.push(new CR(4), unit);
          });
          var file = new Tag('file', {
            'original': 'ng.template',
            id: 'ngi18n'
          }, [].concat(units, [new CR(2)]));
          var xliff = new Tag(_XLIFF_TAG, {
            version: _VERSION$1,
            xmlns: _XMLNS$1,
            srcLang: locale || _DEFAULT_SOURCE_LANG$1
          }, [new CR(2), file, new CR()]);
          return serialize([new Declaration({
            version: '1.0',
            encoding: 'UTF-8'
          }), new CR(), xliff, new CR()]);
        }
      }, {
        key: "load",
        value: function load(content, url) {
          // xliff to xml nodes
          var xliff2Parser = new Xliff2Parser();

          var _xliff2Parser$parse = xliff2Parser.parse(content, url),
              locale = _xliff2Parser$parse.locale,
              msgIdToHtml = _xliff2Parser$parse.msgIdToHtml,
              errors = _xliff2Parser$parse.errors; // xml nodes to i18n nodes


          var i18nNodesByMsgId = {};
          var converter = new XmlToI18n$1();
          Object.keys(msgIdToHtml).forEach(function (msgId) {
            var _converter$convert2 = converter.convert(msgIdToHtml[msgId], url),
                i18nNodes = _converter$convert2.i18nNodes,
                e = _converter$convert2.errors;

            errors.push.apply(errors, _toConsumableArray(e));
            i18nNodesByMsgId[msgId] = i18nNodes;
          });

          if (errors.length) {
            throw new Error("xliff2 parse errors:\n".concat(errors.join('\n')));
          }

          return {
            locale: locale,
            i18nNodesByMsgId: i18nNodesByMsgId
          };
        }
      }, {
        key: "digest",
        value: function digest(message) {
          return decimalDigest(message);
        }
      }]);

      return Xliff2;
    }(Serializer);

    var _WriteVisitor$1 =
    /*#__PURE__*/
    function () {
      function _WriteVisitor$1() {
        _classCallCheck(this, _WriteVisitor$1);
      }

      _createClass(_WriteVisitor$1, [{
        key: "visitText",
        value: function visitText(text, context) {
          return [new Text$2(text.value)];
        }
      }, {
        key: "visitContainer",
        value: function visitContainer(container, context) {
          var _this202 = this;

          var nodes = [];
          container.children.forEach(function (node) {
            return nodes.push.apply(nodes, _toConsumableArray(node.visit(_this202)));
          });
          return nodes;
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu, context) {
          var _this203 = this;

          var nodes = [new Text$2("{".concat(icu.expressionPlaceholder, ", ").concat(icu.type, ", "))];
          Object.keys(icu.cases).forEach(function (c) {
            nodes.push.apply(nodes, [new Text$2("".concat(c, " {"))].concat(_toConsumableArray(icu.cases[c].visit(_this203)), [new Text$2("} ")]));
          });
          nodes.push(new Text$2("}"));
          return nodes;
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, context) {
          var _ref29,
              _this204 = this;

          var type = getTypeForTag(ph.tag);

          if (ph.isVoid) {
            var tagPh = new Tag(_PLACEHOLDER_TAG$2, {
              id: (this._nextPlaceholderId++).toString(),
              equiv: ph.startName,
              type: type,
              disp: "<".concat(ph.tag, "/>")
            });
            return [tagPh];
          }

          var tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {
            id: (this._nextPlaceholderId++).toString(),
            equivStart: ph.startName,
            equivEnd: ph.closeName,
            type: type,
            dispStart: "<".concat(ph.tag, ">"),
            dispEnd: "</".concat(ph.tag, ">")
          });

          var nodes = (_ref29 = []).concat.apply(_ref29, _toConsumableArray(ph.children.map(function (node) {
            return node.visit(_this204);
          })));

          if (nodes.length) {
            nodes.forEach(function (node) {
              return tagPc.children.push(node);
            });
          } else {
            tagPc.children.push(new Text$2(''));
          }

          return [tagPc];
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, context) {
          var idStr = (this._nextPlaceholderId++).toString();
          return [new Tag(_PLACEHOLDER_TAG$2, {
            id: idStr,
            equiv: ph.name,
            disp: "{{".concat(ph.value, "}}")
          })];
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          var cases = Object.keys(ph.value.cases).map(function (value) {
            return value + ' {...}';
          }).join(' ');
          var idStr = (this._nextPlaceholderId++).toString();
          return [new Tag(_PLACEHOLDER_TAG$2, {
            id: idStr,
            equiv: ph.name,
            disp: "{".concat(ph.value.expression, ", ").concat(ph.value.type, ", ").concat(cases, "}")
          })];
        }
      }, {
        key: "serialize",
        value: function serialize(nodes) {
          var _ref30,
              _this205 = this;

          this._nextPlaceholderId = 0;
          return (_ref30 = []).concat.apply(_ref30, _toConsumableArray(nodes.map(function (node) {
            return node.visit(_this205);
          })));
        }
      }]);

      return _WriteVisitor$1;
    }(); // Extract messages as xml nodes from the xliff file


    var Xliff2Parser =
    /*#__PURE__*/
    function () {
      function Xliff2Parser() {
        _classCallCheck(this, Xliff2Parser);

        this._locale = null;
      }

      _createClass(Xliff2Parser, [{
        key: "parse",
        value: function parse(xliff, url) {
          this._unitMlString = null;
          this._msgIdToHtml = {};
          var xml = new XmlParser().parse(xliff, url);
          this._errors = xml.errors;
          visitAll$1(this, xml.rootNodes, null);
          return {
            msgIdToHtml: this._msgIdToHtml,
            errors: this._errors,
            locale: this._locale
          };
        }
      }, {
        key: "visitElement",
        value: function visitElement(element, context) {
          switch (element.name) {
            case _UNIT_TAG$1:
              this._unitMlString = null;
              var idAttr = element.attrs.find(function (attr) {
                return attr.name === 'id';
              });

              if (!idAttr) {
                this._addError(element, "<".concat(_UNIT_TAG$1, "> misses the \"id\" attribute"));
              } else {
                var id = idAttr.value;

                if (this._msgIdToHtml.hasOwnProperty(id)) {
                  this._addError(element, "Duplicated translations for msg ".concat(id));
                } else {
                  visitAll$1(this, element.children, null);

                  if (typeof this._unitMlString === 'string') {
                    this._msgIdToHtml[id] = this._unitMlString;
                  } else {
                    this._addError(element, "Message ".concat(id, " misses a translation"));
                  }
                }
              }

              break;

            case _SOURCE_TAG$2:
              // ignore source message
              break;

            case _TARGET_TAG$1:
              var innerTextStart = element.startSourceSpan.end.offset;
              var innerTextEnd = element.endSourceSpan.start.offset;
              var content = element.startSourceSpan.start.file.content;
              var innerText = content.slice(innerTextStart, innerTextEnd);
              this._unitMlString = innerText;
              break;

            case _XLIFF_TAG:
              var localeAttr = element.attrs.find(function (attr) {
                return attr.name === 'trgLang';
              });

              if (localeAttr) {
                this._locale = localeAttr.value;
              }

              var versionAttr = element.attrs.find(function (attr) {
                return attr.name === 'version';
              });

              if (versionAttr) {
                var version = versionAttr.value;

                if (version !== '2.0') {
                  this._addError(element, "The XLIFF file version ".concat(version, " is not compatible with XLIFF 2.0 serializer"));
                } else {
                  visitAll$1(this, element.children, null);
                }
              }

              break;

            default:
              visitAll$1(this, element.children, null);
          }
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {}
      }, {
        key: "visitText",
        value: function visitText(text, context) {}
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {}
      }, {
        key: "visitExpansion",
        value: function visitExpansion(expansion, context) {}
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(expansionCase, context) {}
      }, {
        key: "_addError",
        value: function _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
        }
      }]);

      return Xliff2Parser;
    }(); // Convert ml nodes (xliff syntax) to i18n nodes


    var XmlToI18n$1 =
    /*#__PURE__*/
    function () {
      function XmlToI18n$1() {
        _classCallCheck(this, XmlToI18n$1);
      }

      _createClass(XmlToI18n$1, [{
        key: "convert",
        value: function convert(message, url) {
          var _ref31;

          var xmlIcu = new XmlParser().parse(message, url, {
            tokenizeExpansionForms: true
          });
          this._errors = xmlIcu.errors;
          var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : (_ref31 = []).concat.apply(_ref31, _toConsumableArray(visitAll$1(this, xmlIcu.rootNodes)));
          return {
            i18nNodes: i18nNodes,
            errors: this._errors
          };
        }
      }, {
        key: "visitText",
        value: function visitText(text, context) {
          return new Text$1(text.value, text.sourceSpan);
        }
      }, {
        key: "visitElement",
        value: function visitElement(el, context) {
          var _this206 = this,
              _ref32;

          switch (el.name) {
            case _PLACEHOLDER_TAG$2:
              var nameAttr = el.attrs.find(function (attr) {
                return attr.name === 'equiv';
              });

              if (nameAttr) {
                return [new Placeholder('', nameAttr.value, el.sourceSpan)];
              }

              this._addError(el, "<".concat(_PLACEHOLDER_TAG$2, "> misses the \"equiv\" attribute"));

              break;

            case _PLACEHOLDER_SPANNING_TAG:
              var startAttr = el.attrs.find(function (attr) {
                return attr.name === 'equivStart';
              });
              var endAttr = el.attrs.find(function (attr) {
                return attr.name === 'equivEnd';
              });

              if (!startAttr) {
                this._addError(el, "<".concat(_PLACEHOLDER_TAG$2, "> misses the \"equivStart\" attribute"));
              } else if (!endAttr) {
                this._addError(el, "<".concat(_PLACEHOLDER_TAG$2, "> misses the \"equivEnd\" attribute"));
              } else {
                var startId = startAttr.value;
                var endId = endAttr.value;
                var nodes = [];
                return nodes.concat.apply(nodes, [new Placeholder('', startId, el.sourceSpan)].concat(_toConsumableArray(el.children.map(function (node) {
                  return node.visit(_this206, null);
                })), [new Placeholder('', endId, el.sourceSpan)]));
              }

              break;

            case _MARKER_TAG$1:
              return (_ref32 = []).concat.apply(_ref32, _toConsumableArray(visitAll$1(this, el.children)));

            default:
              this._addError(el, "Unexpected tag");

          }

          return null;
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(icu, context) {
          var caseMap = {};
          visitAll$1(this, icu.cases).forEach(function (c) {
            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
          });
          return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(icuCase, context) {
          var _ref33;

          return {
            value: icuCase.value,
            nodes: (_ref33 = []).concat.apply(_ref33, _toConsumableArray(visitAll$1(this, icuCase.expression)))
          };
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {}
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {}
      }, {
        key: "_addError",
        value: function _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
        }
      }]);

      return XmlToI18n$1;
    }();

    function getTypeForTag(tag) {
      switch (tag.toLowerCase()) {
        case 'br':
        case 'b':
        case 'i':
        case 'u':
          return 'fmt';

        case 'img':
          return 'image';

        case 'a':
          return 'link';

        default:
          return 'other';
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _TRANSLATIONS_TAG = 'translationbundle';
    var _TRANSLATION_TAG = 'translation';
    var _PLACEHOLDER_TAG$3 = 'ph';

    var Xtb =
    /*#__PURE__*/
    function (_Serializer4) {
      _inherits(Xtb, _Serializer4);

      function Xtb() {
        _classCallCheck(this, Xtb);

        return _possibleConstructorReturn(this, _getPrototypeOf(Xtb).apply(this, arguments));
      }

      _createClass(Xtb, [{
        key: "write",
        value: function write(messages, locale) {
          throw new Error('Unsupported');
        }
      }, {
        key: "load",
        value: function load(content, url) {
          // xtb to xml nodes
          var xtbParser = new XtbParser();

          var _xtbParser$parse = xtbParser.parse(content, url),
              locale = _xtbParser$parse.locale,
              msgIdToHtml = _xtbParser$parse.msgIdToHtml,
              errors = _xtbParser$parse.errors; // xml nodes to i18n nodes


          var i18nNodesByMsgId = {};
          var converter = new XmlToI18n$2(); // Because we should be able to load xtb files that rely on features not supported by angular,
          // we need to delay the conversion of html to i18n nodes so that non angular messages are not
          // converted

          Object.keys(msgIdToHtml).forEach(function (msgId) {
            var valueFn = function valueFn() {
              var _converter$convert3 = converter.convert(msgIdToHtml[msgId], url),
                  i18nNodes = _converter$convert3.i18nNodes,
                  errors = _converter$convert3.errors;

              if (errors.length) {
                throw new Error("xtb parse errors:\n".concat(errors.join('\n')));
              }

              return i18nNodes;
            };

            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);
          });

          if (errors.length) {
            throw new Error("xtb parse errors:\n".concat(errors.join('\n')));
          }

          return {
            locale: locale,
            i18nNodesByMsgId: i18nNodesByMsgId
          };
        }
      }, {
        key: "digest",
        value: function digest(message) {
          return digest$1(message);
        }
      }, {
        key: "createNameMapper",
        value: function createNameMapper(message) {
          return new SimplePlaceholderMapper(message, toPublicName);
        }
      }]);

      return Xtb;
    }(Serializer);

    function createLazyProperty(messages, id, valueFn) {
      Object.defineProperty(messages, id, {
        configurable: true,
        enumerable: true,
        get: function get() {
          var value = valueFn();
          Object.defineProperty(messages, id, {
            enumerable: true,
            value: value
          });
          return value;
        },
        set: function set(_) {
          throw new Error('Could not overwrite an XTB translation');
        }
      });
    } // Extract messages as xml nodes from the xtb file


    var XtbParser =
    /*#__PURE__*/
    function () {
      function XtbParser() {
        _classCallCheck(this, XtbParser);

        this._locale = null;
      }

      _createClass(XtbParser, [{
        key: "parse",
        value: function parse(xtb, url) {
          this._bundleDepth = 0;
          this._msgIdToHtml = {}; // We can not parse the ICU messages at this point as some messages might not originate
          // from Angular that could not be lex'd.

          var xml = new XmlParser().parse(xtb, url);
          this._errors = xml.errors;
          visitAll$1(this, xml.rootNodes);
          return {
            msgIdToHtml: this._msgIdToHtml,
            errors: this._errors,
            locale: this._locale
          };
        }
      }, {
        key: "visitElement",
        value: function visitElement(element, context) {
          switch (element.name) {
            case _TRANSLATIONS_TAG:
              this._bundleDepth++;

              if (this._bundleDepth > 1) {
                this._addError(element, "<".concat(_TRANSLATIONS_TAG, "> elements can not be nested"));
              }

              var langAttr = element.attrs.find(function (attr) {
                return attr.name === 'lang';
              });

              if (langAttr) {
                this._locale = langAttr.value;
              }

              visitAll$1(this, element.children, null);
              this._bundleDepth--;
              break;

            case _TRANSLATION_TAG:
              var idAttr = element.attrs.find(function (attr) {
                return attr.name === 'id';
              });

              if (!idAttr) {
                this._addError(element, "<".concat(_TRANSLATION_TAG, "> misses the \"id\" attribute"));
              } else {
                var id = idAttr.value;

                if (this._msgIdToHtml.hasOwnProperty(id)) {
                  this._addError(element, "Duplicated translations for msg ".concat(id));
                } else {
                  var innerTextStart = element.startSourceSpan.end.offset;
                  var innerTextEnd = element.endSourceSpan.start.offset;
                  var content = element.startSourceSpan.start.file.content;
                  var innerText = content.slice(innerTextStart, innerTextEnd);
                  this._msgIdToHtml[id] = innerText;
                }
              }

              break;

            default:
              this._addError(element, 'Unexpected tag');

          }
        }
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {}
      }, {
        key: "visitText",
        value: function visitText(text, context) {}
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {}
      }, {
        key: "visitExpansion",
        value: function visitExpansion(expansion, context) {}
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(expansionCase, context) {}
      }, {
        key: "_addError",
        value: function _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
        }
      }]);

      return XtbParser;
    }(); // Convert ml nodes (xtb syntax) to i18n nodes


    var XmlToI18n$2 =
    /*#__PURE__*/
    function () {
      function XmlToI18n$2() {
        _classCallCheck(this, XmlToI18n$2);
      }

      _createClass(XmlToI18n$2, [{
        key: "convert",
        value: function convert(message, url) {
          var xmlIcu = new XmlParser().parse(message, url, {
            tokenizeExpansionForms: true
          });
          this._errors = xmlIcu.errors;
          var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : visitAll$1(this, xmlIcu.rootNodes);
          return {
            i18nNodes: i18nNodes,
            errors: this._errors
          };
        }
      }, {
        key: "visitText",
        value: function visitText(text, context) {
          return new Text$1(text.value, text.sourceSpan);
        }
      }, {
        key: "visitExpansion",
        value: function visitExpansion(icu, context) {
          var caseMap = {};
          visitAll$1(this, icu.cases).forEach(function (c) {
            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
          });
          return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
        }
      }, {
        key: "visitExpansionCase",
        value: function visitExpansionCase(icuCase, context) {
          return {
            value: icuCase.value,
            nodes: visitAll$1(this, icuCase.expression)
          };
        }
      }, {
        key: "visitElement",
        value: function visitElement(el, context) {
          if (el.name === _PLACEHOLDER_TAG$3) {
            var nameAttr = el.attrs.find(function (attr) {
              return attr.name === 'name';
            });

            if (nameAttr) {
              return new Placeholder('', nameAttr.value, el.sourceSpan);
            }

            this._addError(el, "<".concat(_PLACEHOLDER_TAG$3, "> misses the \"name\" attribute"));
          } else {
            this._addError(el, "Unexpected tag");
          }

          return null;
        }
      }, {
        key: "visitComment",
        value: function visitComment(comment, context) {}
      }, {
        key: "visitAttribute",
        value: function visitAttribute(attribute, context) {}
      }, {
        key: "_addError",
        value: function _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
        }
      }]);

      return XmlToI18n$2;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * A container for translated messages
     */


    var TranslationBundle =
    /*#__PURE__*/
    function () {
      function TranslationBundle() {
        var _i18nNodesByMsgId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var locale = arguments.length > 1 ? arguments[1] : undefined;
        var digest = arguments.length > 2 ? arguments[2] : undefined;
        var mapperFactory = arguments.length > 3 ? arguments[3] : undefined;
        var missingTranslationStrategy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : MissingTranslationStrategy.Warning;
        var console = arguments.length > 5 ? arguments[5] : undefined;

        _classCallCheck(this, TranslationBundle);

        this._i18nNodesByMsgId = _i18nNodesByMsgId;
        this.digest = digest;
        this.mapperFactory = mapperFactory;
        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);
      } // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.


      _createClass(TranslationBundle, [{
        key: "get",
        // Returns the translation as HTML nodes from the given source message.
        value: function get(srcMsg) {
          var html = this._i18nToHtml.convert(srcMsg);

          if (html.errors.length) {
            throw new Error(html.errors.join('\n'));
          }

          return html.nodes;
        }
      }, {
        key: "has",
        value: function has(srcMsg) {
          return this.digest(srcMsg) in this._i18nNodesByMsgId;
        }
      }], [{
        key: "load",
        value: function load(content, url, serializer, missingTranslationStrategy, console) {
          var _serializer$load = serializer.load(content, url),
              locale = _serializer$load.locale,
              i18nNodesByMsgId = _serializer$load.i18nNodesByMsgId;

          var digestFn = function digestFn(m) {
            return serializer.digest(m);
          };

          var mapperFactory = function mapperFactory(m) {
            return serializer.createNameMapper(m);
          };

          return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);
        }
      }]);

      return TranslationBundle;
    }();

    var I18nToHtmlVisitor =
    /*#__PURE__*/
    function () {
      function I18nToHtmlVisitor() {
        var _i18nNodesByMsgId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var _locale = arguments.length > 1 ? arguments[1] : undefined;

        var _digest = arguments.length > 2 ? arguments[2] : undefined;

        var _mapperFactory = arguments.length > 3 ? arguments[3] : undefined;

        var _missingTranslationStrategy = arguments.length > 4 ? arguments[4] : undefined;

        var _console = arguments.length > 5 ? arguments[5] : undefined;

        _classCallCheck(this, I18nToHtmlVisitor);

        this._i18nNodesByMsgId = _i18nNodesByMsgId;
        this._locale = _locale;
        this._digest = _digest;
        this._mapperFactory = _mapperFactory;
        this._missingTranslationStrategy = _missingTranslationStrategy;
        this._console = _console;
        this._contextStack = [];
        this._errors = [];
      }

      _createClass(I18nToHtmlVisitor, [{
        key: "convert",
        value: function convert(srcMsg) {
          this._contextStack.length = 0;
          this._errors.length = 0; // i18n to text

          var text = this._convertToText(srcMsg); // text to html


          var url = srcMsg.nodes[0].sourceSpan.start.file.url;
          var html = new HtmlParser().parse(text, url, {
            tokenizeExpansionForms: true
          });
          return {
            nodes: html.rootNodes,
            errors: [].concat(_toConsumableArray(this._errors), _toConsumableArray(html.errors))
          };
        }
      }, {
        key: "visitText",
        value: function visitText(text, context) {
          // `convert()` uses an `HtmlParser` to return `html.Node`s
          // we should then make sure that any special characters are escaped
          return escapeXml(text.value);
        }
      }, {
        key: "visitContainer",
        value: function visitContainer(container, context) {
          var _this207 = this;

          return container.children.map(function (n) {
            return n.visit(_this207);
          }).join('');
        }
      }, {
        key: "visitIcu",
        value: function visitIcu(icu, context) {
          var _this208 = this;

          var cases = Object.keys(icu.cases).map(function (k) {
            return "".concat(k, " {").concat(icu.cases[k].visit(_this208), "}");
          }); // TODO(vicb): Once all format switch to using expression placeholders
          // we should throw when the placeholder is not in the source message

          var exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ? this._srcMsg.placeholders[icu.expression] : icu.expression;
          return "{".concat(exp, ", ").concat(icu.type, ", ").concat(cases.join(' '), "}");
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, context) {
          var phName = this._mapper(ph.name);

          if (this._srcMsg.placeholders.hasOwnProperty(phName)) {
            return this._srcMsg.placeholders[phName];
          }

          if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {
            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);
          }

          this._addError(ph, "Unknown placeholder \"".concat(ph.name, "\""));

          return '';
        } // Loaded message contains only placeholders (vs tag and icu placeholders).
        // However when a translation can not be found, we need to serialize the source message
        // which can contain tag placeholders

      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, context) {
          var _this209 = this;

          var tag = "".concat(ph.tag);
          var attrs = Object.keys(ph.attrs).map(function (name) {
            return "".concat(name, "=\"").concat(ph.attrs[name], "\"");
          }).join(' ');

          if (ph.isVoid) {
            return "<".concat(tag, " ").concat(attrs, "/>");
          }

          var children = ph.children.map(function (c) {
            return c.visit(_this209);
          }).join('');
          return "<".concat(tag, " ").concat(attrs, ">").concat(children, "</").concat(tag, ">");
        } // Loaded message contains only placeholders (vs tag and icu placeholders).
        // However when a translation can not be found, we need to serialize the source message
        // which can contain tag placeholders

      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, context) {
          // An ICU placeholder references the source message to be serialized
          return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);
        }
        /**
         * Convert a source message to a translated text string:
         * - text nodes are replaced with their translation,
         * - placeholders are replaced with their content,
         * - ICU nodes are converted to ICU expressions.
         */

      }, {
        key: "_convertToText",
        value: function _convertToText(srcMsg) {
          var _this210 = this;

          var id = this._digest(srcMsg);

          var mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;
          var nodes;

          this._contextStack.push({
            msg: this._srcMsg,
            mapper: this._mapper
          });

          this._srcMsg = srcMsg;

          if (this._i18nNodesByMsgId.hasOwnProperty(id)) {
            // When there is a translation use its nodes as the source
            // And create a mapper to convert serialized placeholder names to internal names
            nodes = this._i18nNodesByMsgId[id];

            this._mapper = function (name) {
              return mapper ? mapper.toInternalName(name) : name;
            };
          } else {
            // When no translation has been found
            // - report an error / a warning / nothing,
            // - use the nodes from the original message
            // - placeholders are already internal and need no mapper
            if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {
              var ctx = this._locale ? " for locale \"".concat(this._locale, "\"") : '';

              this._addError(srcMsg.nodes[0], "Missing translation for message \"".concat(id, "\"").concat(ctx));
            } else if (this._console && this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {
              var _ctx2 = this._locale ? " for locale \"".concat(this._locale, "\"") : '';

              this._console.warn("Missing translation for message \"".concat(id, "\"").concat(_ctx2));
            }

            nodes = srcMsg.nodes;

            this._mapper = function (name) {
              return name;
            };
          }

          var text = nodes.map(function (node) {
            return node.visit(_this210);
          }).join('');

          var context = this._contextStack.pop();

          this._srcMsg = context.msg;
          this._mapper = context.mapper;
          return text;
        }
      }, {
        key: "_addError",
        value: function _addError(el, msg) {
          this._errors.push(new I18nError(el.sourceSpan, msg));
        }
      }]);

      return I18nToHtmlVisitor;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var I18NHtmlParser =
    /*#__PURE__*/
    function () {
      function I18NHtmlParser(_htmlParser, translations, translationsFormat) {
        var missingTranslation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MissingTranslationStrategy.Warning;
        var console = arguments.length > 4 ? arguments[4] : undefined;

        _classCallCheck(this, I18NHtmlParser);

        this._htmlParser = _htmlParser;

        if (translations) {
          var _serializer = createSerializer(translationsFormat);

          this._translationBundle = TranslationBundle.load(translations, 'i18n', _serializer, missingTranslation, console);
        } else {
          this._translationBundle = new TranslationBundle({}, null, _digest2, undefined, missingTranslation, console);
        }
      }

      _createClass(I18NHtmlParser, [{
        key: "parse",
        value: function parse(source, url) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;

          var parseResult = this._htmlParser.parse(source, url, Object.assign({
            interpolationConfig: interpolationConfig
          }, options));

          if (parseResult.errors.length) {
            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);
          }

          return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});
        }
      }]);

      return I18NHtmlParser;
    }();

    function createSerializer(format) {
      format = (format || 'xlf').toLowerCase();

      switch (format) {
        case 'xmb':
          return new Xmb();

        case 'xtb':
          return new Xtb();

        case 'xliff2':
        case 'xlf2':
          return new Xliff2();

        case 'xliff':
        case 'xlf':
        default:
          return new Xliff();
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var QUOTED_KEYS = '$quoted$';

    function convertValueToOutputAst(ctx, value) {
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return visitValue(value, new _ValueOutputAstTransformer(ctx), type);
    }

    var _ValueOutputAstTransformer =
    /*#__PURE__*/
    function () {
      function _ValueOutputAstTransformer(ctx) {
        _classCallCheck(this, _ValueOutputAstTransformer);

        this.ctx = ctx;
      }

      _createClass(_ValueOutputAstTransformer, [{
        key: "visitArray",
        value: function visitArray(arr, type) {
          var _this211 = this;

          return literalArr(arr.map(function (value) {
            return visitValue(value, _this211, null);
          }), type);
        }
      }, {
        key: "visitStringMap",
        value: function visitStringMap(map, type) {
          var _this212 = this;

          var entries = [];
          var quotedSet = new Set(map && map[QUOTED_KEYS]);
          Object.keys(map).forEach(function (key) {
            entries.push(new LiteralMapEntry(key, visitValue(map[key], _this212, null), quotedSet.has(key)));
          });
          return new LiteralMapExpr(entries, type);
        }
      }, {
        key: "visitPrimitive",
        value: function visitPrimitive(value, type) {
          return literal(value, type);
        }
      }, {
        key: "visitOther",
        value: function visitOther(value, type) {
          if (value instanceof Expression) {
            return value;
          } else {
            return this.ctx.importExpr(value);
          }
        }
      }]);

      return _ValueOutputAstTransformer;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function mapEntry$1(key, value) {
      return {
        key: key,
        value: value,
        quoted: false
      };
    }

    var InjectableCompiler =
    /*#__PURE__*/
    function () {
      function InjectableCompiler(reflector, alwaysGenerateDef) {
        _classCallCheck(this, InjectableCompiler);

        this.reflector = reflector;
        this.alwaysGenerateDef = alwaysGenerateDef;
        this.tokenInjector = reflector.resolveExternalReference(Identifiers.Injector);
      }

      _createClass(InjectableCompiler, [{
        key: "depsArray",
        value: function depsArray(deps, ctx) {
          var _this213 = this;

          return deps.map(function (dep) {
            var token = dep;
            var args = [token];
            var flags = 0
            /* Default */
            ;

            if (Array.isArray(dep)) {
              for (var i = 0; i < dep.length; i++) {
                var v = dep[i];

                if (v) {
                  if (v.ngMetadataName === 'Optional') {
                    flags |= 8
                    /* Optional */
                    ;
                  } else if (v.ngMetadataName === 'SkipSelf') {
                    flags |= 4
                    /* SkipSelf */
                    ;
                  } else if (v.ngMetadataName === 'Self') {
                    flags |= 2
                    /* Self */
                    ;
                  } else if (v.ngMetadataName === 'Inject') {
                    token = v.token;
                  } else {
                    token = v;
                  }
                }
              }
            }

            var tokenExpr;

            if (typeof token === 'string') {
              tokenExpr = literal(token);
            } else if (token === _this213.tokenInjector) {
              tokenExpr = importExpr(Identifiers.INJECTOR);
            } else {
              tokenExpr = ctx.importExpr(token);
            }

            if (flags !== 0
            /* Default */
            ) {
                args = [tokenExpr, literal(flags)];
              } else {
              args = [tokenExpr];
            }

            return importExpr(Identifiers.inject).callFn(args);
          });
        }
      }, {
        key: "factoryFor",
        value: function factoryFor(injectable, ctx) {
          var retValue;

          if (injectable.useExisting) {
            retValue = importExpr(Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);
          } else if (injectable.useFactory) {
            var deps = injectable.deps || [];

            if (deps.length > 0) {
              retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));
            } else {
              return ctx.importExpr(injectable.useFactory);
            }
          } else if (injectable.useValue) {
            retValue = convertValueToOutputAst(ctx, injectable.useValue);
          } else {
            var clazz = injectable.useClass || injectable.symbol;
            var depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);
            retValue = new InstantiateExpr(ctx.importExpr(clazz), depArgs);
          }

          return fn([], [new ReturnStatement(retValue)], undefined, undefined, injectable.symbol.name + '_Factory');
        }
      }, {
        key: "injectableDef",
        value: function injectableDef(injectable, ctx) {
          var providedIn = NULL_EXPR;

          if (injectable.providedIn !== undefined) {
            if (injectable.providedIn === null) {
              providedIn = NULL_EXPR;
            } else if (typeof injectable.providedIn === 'string') {
              providedIn = literal(injectable.providedIn);
            } else {
              providedIn = ctx.importExpr(injectable.providedIn);
            }
          }

          var def = [mapEntry$1('factory', this.factoryFor(injectable, ctx)), mapEntry$1('token', ctx.importExpr(injectable.type.reference)), mapEntry$1('providedIn', providedIn)];
          return importExpr(Identifiers.ɵɵdefineInjectable).callFn([literalMap(def)]);
        }
      }, {
        key: "compile",
        value: function compile(injectable, ctx) {
          if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {
            var className = identifierName(injectable.type);
            var clazz = new ClassStmt(className, null, [new ClassField('ɵprov', INFERRED_TYPE, [StmtModifier.Static], this.injectableDef(injectable, ctx))], [], new ClassMethod(null, [], []), []);
            ctx.statements.push(clazz);
          }
        }
      }]);

      return InjectableCompiler;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var STRIP_SRC_FILE_SUFFIXES = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
    var GENERATED_FILE = /\.ngfactory\.|\.ngsummary\./;
    var JIT_SUMMARY_FILE = /\.ngsummary\./;
    var JIT_SUMMARY_NAME = /NgSummary$/;

    function ngfactoryFilePath(filePath) {
      var forceSourceFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);
      return "".concat(urlWithSuffix[0], ".ngfactory").concat(normalizeGenFileSuffix(urlWithSuffix[1]));
    }

    function stripGeneratedFileSuffix(filePath) {
      return filePath.replace(GENERATED_FILE, '.');
    }

    function isGeneratedFile(filePath) {
      return GENERATED_FILE.test(filePath);
    }

    function splitTypescriptSuffix(path) {
      var forceSourceFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (path.endsWith('.d.ts')) {
        return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];
      }

      var lastDot = path.lastIndexOf('.');

      if (lastDot !== -1) {
        return [path.substring(0, lastDot), path.substring(lastDot)];
      }

      return [path, ''];
    }

    function normalizeGenFileSuffix(srcFileSuffix) {
      return srcFileSuffix === '.tsx' ? '.ts' : srcFileSuffix;
    }

    function summaryFileName(fileName) {
      var fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');
      return "".concat(fileNameWithoutSuffix, ".ngsummary.json");
    }

    function summaryForJitFileName(fileName) {
      var forceSourceFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);
      return "".concat(urlWithSuffix[0], ".ngsummary").concat(urlWithSuffix[1]);
    }

    function stripSummaryForJitFileSuffix(filePath) {
      return filePath.replace(JIT_SUMMARY_FILE, '.');
    }

    function summaryForJitName(symbolName) {
      return "".concat(symbolName, "NgSummary");
    }

    function stripSummaryForJitNameSuffix(symbolName) {
      return symbolName.replace(JIT_SUMMARY_NAME, '');
    }

    var LOWERED_SYMBOL = /\u0275\d+/;

    function isLoweredSymbol(name) {
      return LOWERED_SYMBOL.test(name);
    }

    function createLoweredSymbol(id) {
      return "\u0275".concat(id);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var LifecycleHooks;

    (function (LifecycleHooks) {
      LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
      LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
      LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
      LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
      LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
      LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
      LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
      LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
    })(LifecycleHooks || (LifecycleHooks = {}));

    var LIFECYCLE_HOOKS_VALUES = [LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges, LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit, LifecycleHooks.AfterViewChecked];

    function hasLifecycleHook(reflector, hook, token) {
      return reflector.hasLifecycleHook(token, getHookName(hook));
    }

    function getAllLifecycleHooks(reflector, token) {
      return LIFECYCLE_HOOKS_VALUES.filter(function (hook) {
        return hasLifecycleHook(reflector, hook, token);
      });
    }

    function getHookName(hook) {
      switch (hook) {
        case LifecycleHooks.OnInit:
          return 'ngOnInit';

        case LifecycleHooks.OnDestroy:
          return 'ngOnDestroy';

        case LifecycleHooks.DoCheck:
          return 'ngDoCheck';

        case LifecycleHooks.OnChanges:
          return 'ngOnChanges';

        case LifecycleHooks.AfterContentInit:
          return 'ngAfterContentInit';

        case LifecycleHooks.AfterContentChecked:
          return 'ngAfterContentChecked';

        case LifecycleHooks.AfterViewInit:
          return 'ngAfterViewInit';

        case LifecycleHooks.AfterViewChecked:
          return 'ngAfterViewChecked';

        default:
          // This default case is not needed by TypeScript compiler, as the switch is exhaustive.
          // However Closure Compiler does not understand that and reports an error in typed mode.
          // The `throw new Error` below works around the problem, and the unexpected: never variable
          // makes sure tsc still checks this code is unreachable.
          var unexpected = hook;
          throw new Error("unexpected ".concat(unexpected));
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var ERROR_COMPONENT_TYPE = 'ngComponentType'; // Design notes:
    // - don't lazily create metadata:
    //   For some metadata, we need to do async work sometimes,
    //   so the user has to kick off this loading.
    //   But we want to report errors even when the async work is
    //   not required to check that the user would have been able
    //   to wait correctly.

    var CompileMetadataResolver =
    /*#__PURE__*/
    function () {
      function CompileMetadataResolver(_config, _htmlParser, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {
        _classCallCheck(this, CompileMetadataResolver);

        this._config = _config;
        this._htmlParser = _htmlParser;
        this._ngModuleResolver = _ngModuleResolver;
        this._directiveResolver = _directiveResolver;
        this._pipeResolver = _pipeResolver;
        this._summaryResolver = _summaryResolver;
        this._schemaRegistry = _schemaRegistry;
        this._directiveNormalizer = _directiveNormalizer;
        this._console = _console;
        this._staticSymbolCache = _staticSymbolCache;
        this._reflector = _reflector;
        this._errorCollector = _errorCollector;
        this._nonNormalizedDirectiveCache = new Map();
        this._directiveCache = new Map();
        this._summaryCache = new Map();
        this._pipeCache = new Map();
        this._ngModuleCache = new Map();
        this._ngModuleOfTypes = new Map();
        this._shallowModuleCache = new Map();
      }

      _createClass(CompileMetadataResolver, [{
        key: "getReflector",
        value: function getReflector() {
          return this._reflector;
        }
      }, {
        key: "clearCacheFor",
        value: function clearCacheFor(type) {
          var dirMeta = this._directiveCache.get(type);

          this._directiveCache.delete(type);

          this._nonNormalizedDirectiveCache.delete(type);

          this._summaryCache.delete(type);

          this._pipeCache.delete(type);

          this._ngModuleOfTypes.delete(type); // Clear all of the NgModule as they contain transitive information!


          this._ngModuleCache.clear();

          if (dirMeta) {
            this._directiveNormalizer.clearCacheFor(dirMeta);
          }
        }
      }, {
        key: "clearCache",
        value: function clearCache() {
          this._directiveCache.clear();

          this._nonNormalizedDirectiveCache.clear();

          this._summaryCache.clear();

          this._pipeCache.clear();

          this._ngModuleCache.clear();

          this._ngModuleOfTypes.clear();

          this._directiveNormalizer.clearCache();
        }
      }, {
        key: "_createProxyClass",
        value: function _createProxyClass(baseType, name) {
          var delegate = null;

          var proxyClass = function proxyClass() {
            if (!delegate) {
              throw new Error("Illegal state: Class ".concat(name, " for type ").concat(stringify(baseType), " is not compiled yet!"));
            }

            return delegate.apply(this, arguments);
          };

          proxyClass.setDelegate = function (d) {
            delegate = d;
            proxyClass.prototype = d.prototype;
          }; // Make stringify work correctly


          proxyClass.overriddenName = name;
          return proxyClass;
        }
      }, {
        key: "getGeneratedClass",
        value: function getGeneratedClass(dirType, name) {
          if (dirType instanceof StaticSymbol) {
            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);
          } else {
            return this._createProxyClass(dirType, name);
          }
        }
      }, {
        key: "getComponentViewClass",
        value: function getComponentViewClass(dirType) {
          return this.getGeneratedClass(dirType, viewClassName(dirType, 0));
        }
      }, {
        key: "getHostComponentViewClass",
        value: function getHostComponentViewClass(dirType) {
          return this.getGeneratedClass(dirType, hostViewClassName(dirType));
        }
      }, {
        key: "getHostComponentType",
        value: function getHostComponentType(dirType) {
          var name = "".concat(identifierName({
            reference: dirType
          }), "_Host");

          if (dirType instanceof StaticSymbol) {
            return this._staticSymbolCache.get(dirType.filePath, name);
          }

          return this._createProxyClass(dirType, name);
        }
      }, {
        key: "getRendererType",
        value: function getRendererType(dirType) {
          if (dirType instanceof StaticSymbol) {
            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));
          } else {
            // returning an object as proxy,
            // that we fill later during runtime compilation.
            return {};
          }
        }
      }, {
        key: "getComponentFactory",
        value: function getComponentFactory(selector, dirType, inputs, outputs) {
          if (dirType instanceof StaticSymbol) {
            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));
          } else {
            var hostView = this.getHostComponentViewClass(dirType); // Note: ngContentSelectors will be filled later once the template is
            // loaded.

            var createComponentFactory = this._reflector.resolveExternalReference(Identifiers.createComponentFactory);

            return createComponentFactory(selector, dirType, hostView, inputs, outputs, []);
          }
        }
      }, {
        key: "initComponentFactory",
        value: function initComponentFactory(factory, ngContentSelectors) {
          if (!(factory instanceof StaticSymbol)) {
            var _factory$ngContentSel;

            (_factory$ngContentSel = factory.ngContentSelectors).push.apply(_factory$ngContentSel, _toConsumableArray(ngContentSelectors));
          }
        }
      }, {
        key: "_loadSummary",
        value: function _loadSummary(type, kind) {
          var typeSummary = this._summaryCache.get(type);

          if (!typeSummary) {
            var summary = this._summaryResolver.resolveSummary(type);

            typeSummary = summary ? summary.type : null;

            this._summaryCache.set(type, typeSummary || null);
          }

          return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;
        }
      }, {
        key: "getHostComponentMetadata",
        value: function getHostComponentMetadata(compMeta, hostViewType) {
          var hostType = this.getHostComponentType(compMeta.type.reference);

          if (!hostViewType) {
            hostViewType = this.getHostComponentViewClass(hostType);
          } // Note: ! is ok here as this method should only be called with normalized directive
          // metadata, which always fills in the selector.


          var template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();
          var templateUrl = '';

          var htmlAst = this._htmlParser.parse(template, templateUrl);

          return CompileDirectiveMetadata.create({
            isHost: true,
            type: {
              reference: hostType,
              diDeps: [],
              lifecycleHooks: []
            },
            template: new CompileTemplateMetadata({
              encapsulation: ViewEncapsulation.None,
              template: template,
              templateUrl: templateUrl,
              htmlAst: htmlAst,
              styles: [],
              styleUrls: [],
              ngContentSelectors: [],
              animations: [],
              isInline: true,
              externalStylesheets: [],
              interpolation: null,
              preserveWhitespaces: false
            }),
            exportAs: null,
            changeDetection: ChangeDetectionStrategy.Default,
            inputs: [],
            outputs: [],
            host: {},
            isComponent: true,
            selector: '*',
            providers: [],
            viewProviders: [],
            queries: [],
            guards: {},
            viewQueries: [],
            componentViewType: hostViewType,
            rendererType: {
              id: '__Host__',
              encapsulation: ViewEncapsulation.None,
              styles: [],
              data: {}
            },
            entryComponents: [],
            componentFactory: null
          });
        }
      }, {
        key: "loadDirectiveMetadata",
        value: function loadDirectiveMetadata(ngModuleType, directiveType, isSync) {
          var _this214 = this;

          if (this._directiveCache.has(directiveType)) {
            return null;
          }

          directiveType = resolveForwardRef(directiveType);

          var _this$getNonNormalize = this.getNonNormalizedDirectiveMetadata(directiveType),
              annotation = _this$getNonNormalize.annotation,
              metadata = _this$getNonNormalize.metadata;

          var createDirectiveMetadata = function createDirectiveMetadata(templateMetadata) {
            var normalizedDirMeta = new CompileDirectiveMetadata({
              isHost: false,
              type: metadata.type,
              isComponent: metadata.isComponent,
              selector: metadata.selector,
              exportAs: metadata.exportAs,
              changeDetection: metadata.changeDetection,
              inputs: metadata.inputs,
              outputs: metadata.outputs,
              hostListeners: metadata.hostListeners,
              hostProperties: metadata.hostProperties,
              hostAttributes: metadata.hostAttributes,
              providers: metadata.providers,
              viewProviders: metadata.viewProviders,
              queries: metadata.queries,
              guards: metadata.guards,
              viewQueries: metadata.viewQueries,
              entryComponents: metadata.entryComponents,
              componentViewType: metadata.componentViewType,
              rendererType: metadata.rendererType,
              componentFactory: metadata.componentFactory,
              template: templateMetadata
            });

            if (templateMetadata) {
              _this214.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);
            }

            _this214._directiveCache.set(directiveType, normalizedDirMeta);

            _this214._summaryCache.set(directiveType, normalizedDirMeta.toSummary());

            return null;
          };

          if (metadata.isComponent) {
            var template = metadata.template;

            var templateMeta = this._directiveNormalizer.normalizeTemplate({
              ngModuleType: ngModuleType,
              componentType: directiveType,
              moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),
              encapsulation: template.encapsulation,
              template: template.template,
              templateUrl: template.templateUrl,
              styles: template.styles,
              styleUrls: template.styleUrls,
              animations: template.animations,
              interpolation: template.interpolation,
              preserveWhitespaces: template.preserveWhitespaces
            });

            if (isPromise(templateMeta) && isSync) {
              this._reportError(componentStillLoadingError(directiveType), directiveType);

              return null;
            }

            return SyncAsync.then(templateMeta, createDirectiveMetadata);
          } else {
            // directive
            createDirectiveMetadata(null);
            return null;
          }
        }
      }, {
        key: "getNonNormalizedDirectiveMetadata",
        value: function getNonNormalizedDirectiveMetadata(directiveType) {
          var _this215 = this;

          directiveType = resolveForwardRef(directiveType);

          if (!directiveType) {
            return null;
          }

          var cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);

          if (cacheEntry) {
            return cacheEntry;
          }

          var dirMeta = this._directiveResolver.resolve(directiveType, false);

          if (!dirMeta) {
            return null;
          }

          var nonNormalizedTemplateMetadata = undefined;

          if (createComponent.isTypeOf(dirMeta)) {
            // component
            var compMeta = dirMeta;
            assertArrayOfStrings('styles', compMeta.styles);
            assertArrayOfStrings('styleUrls', compMeta.styleUrls);
            assertInterpolationSymbols('interpolation', compMeta.interpolation);
            var animations = compMeta.animations;
            nonNormalizedTemplateMetadata = new CompileTemplateMetadata({
              encapsulation: noUndefined(compMeta.encapsulation),
              template: noUndefined(compMeta.template),
              templateUrl: noUndefined(compMeta.templateUrl),
              htmlAst: null,
              styles: compMeta.styles || [],
              styleUrls: compMeta.styleUrls || [],
              animations: animations || [],
              interpolation: noUndefined(compMeta.interpolation),
              isInline: !!compMeta.template,
              externalStylesheets: [],
              ngContentSelectors: [],
              preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces)
            });
          }

          var changeDetectionStrategy = null;
          var viewProviders = [];
          var entryComponentMetadata = [];
          var selector = dirMeta.selector;

          if (createComponent.isTypeOf(dirMeta)) {
            // Component
            var _compMeta = dirMeta;
            changeDetectionStrategy = _compMeta.changeDetection;

            if (_compMeta.viewProviders) {
              viewProviders = this._getProvidersMetadata(_compMeta.viewProviders, entryComponentMetadata, "viewProviders for \"".concat(stringifyType(directiveType), "\""), [], directiveType);
            }

            if (_compMeta.entryComponents) {
              entryComponentMetadata = flattenAndDedupeArray(_compMeta.entryComponents).map(function (type) {
                return _this215._getEntryComponentMetadata(type);
              }).concat(entryComponentMetadata);
            }

            if (!selector) {
              selector = this._schemaRegistry.getDefaultComponentElementName();
            }
          } else {
            // Directive
            if (!selector) {
              selector = null;
            }
          }

          var providers = [];

          if (dirMeta.providers != null) {
            providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, "providers for \"".concat(stringifyType(directiveType), "\""), [], directiveType);
          }

          var queries = [];
          var viewQueries = [];

          if (dirMeta.queries != null) {
            queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);
            viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);
          }

          var metadata = CompileDirectiveMetadata.create({
            isHost: false,
            selector: selector,
            exportAs: noUndefined(dirMeta.exportAs),
            isComponent: !!nonNormalizedTemplateMetadata,
            type: this._getTypeMetadata(directiveType),
            template: nonNormalizedTemplateMetadata,
            changeDetection: changeDetectionStrategy,
            inputs: dirMeta.inputs || [],
            outputs: dirMeta.outputs || [],
            host: dirMeta.host || {},
            providers: providers || [],
            viewProviders: viewProviders || [],
            queries: queries || [],
            guards: dirMeta.guards || {},
            viewQueries: viewQueries || [],
            entryComponents: entryComponentMetadata,
            componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) : null,
            rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,
            componentFactory: null
          });

          if (nonNormalizedTemplateMetadata) {
            metadata.componentFactory = this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);
          }

          cacheEntry = {
            metadata: metadata,
            annotation: dirMeta
          };

          this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);

          return cacheEntry;
        }
        /**
         * Gets the metadata for the given directive.
         * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
         */

      }, {
        key: "getDirectiveMetadata",
        value: function getDirectiveMetadata(directiveType) {
          var dirMeta = this._directiveCache.get(directiveType);

          if (!dirMeta) {
            this._reportError(syntaxError("Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive ".concat(stringifyType(directiveType), ".")), directiveType);
          }

          return dirMeta;
        }
      }, {
        key: "getDirectiveSummary",
        value: function getDirectiveSummary(dirType) {
          var dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);

          if (!dirSummary) {
            this._reportError(syntaxError("Illegal state: Could not load the summary for directive ".concat(stringifyType(dirType), ".")), dirType);
          }

          return dirSummary;
        }
      }, {
        key: "isDirective",
        value: function isDirective(type) {
          return !!this._loadSummary(type, CompileSummaryKind.Directive) || this._directiveResolver.isDirective(type);
        }
      }, {
        key: "isAbstractDirective",
        value: function isAbstractDirective(type) {
          var summary = this._loadSummary(type, CompileSummaryKind.Directive);

          if (summary && !summary.isComponent) {
            return !summary.selector;
          }

          var meta = this._directiveResolver.resolve(type, false);

          if (meta && !createComponent.isTypeOf(meta)) {
            return !meta.selector;
          }

          return false;
        }
      }, {
        key: "isPipe",
        value: function isPipe(type) {
          return !!this._loadSummary(type, CompileSummaryKind.Pipe) || this._pipeResolver.isPipe(type);
        }
      }, {
        key: "isNgModule",
        value: function isNgModule(type) {
          return !!this._loadSummary(type, CompileSummaryKind.NgModule) || this._ngModuleResolver.isNgModule(type);
        }
      }, {
        key: "getNgModuleSummary",
        value: function getNgModuleSummary(moduleType) {
          var alreadyCollecting = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          var moduleSummary = this._loadSummary(moduleType, CompileSummaryKind.NgModule);

          if (!moduleSummary) {
            var moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);
            moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;

            if (moduleSummary) {
              this._summaryCache.set(moduleType, moduleSummary);
            }
          }

          return moduleSummary;
        }
        /**
         * Loads the declared directives and pipes of an NgModule.
         */

      }, {
        key: "loadNgModuleDirectiveAndPipeMetadata",
        value: function loadNgModuleDirectiveAndPipeMetadata(moduleType, isSync) {
          var _this216 = this;

          var throwIfNotFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);
          var loading = [];

          if (ngModule) {
            ngModule.declaredDirectives.forEach(function (id) {
              var promise = _this216.loadDirectiveMetadata(moduleType, id.reference, isSync);

              if (promise) {
                loading.push(promise);
              }
            });
            ngModule.declaredPipes.forEach(function (id) {
              return _this216._loadPipeMetadata(id.reference);
            });
          }

          return Promise.all(loading);
        }
      }, {
        key: "getShallowModuleMetadata",
        value: function getShallowModuleMetadata(moduleType) {
          var compileMeta = this._shallowModuleCache.get(moduleType);

          if (compileMeta) {
            return compileMeta;
          }

          var ngModuleMeta = findLast(this._reflector.shallowAnnotations(moduleType), createNgModule.isTypeOf);
          compileMeta = {
            type: this._getTypeMetadata(moduleType),
            rawExports: ngModuleMeta.exports,
            rawImports: ngModuleMeta.imports,
            rawProviders: ngModuleMeta.providers
          };

          this._shallowModuleCache.set(moduleType, compileMeta);

          return compileMeta;
        }
      }, {
        key: "getNgModuleMetadata",
        value: function getNgModuleMetadata(moduleType) {
          var _this217 = this;

          var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var alreadyCollecting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          moduleType = resolveForwardRef(moduleType);

          var compileMeta = this._ngModuleCache.get(moduleType);

          if (compileMeta) {
            return compileMeta;
          }

          var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);

          if (!meta) {
            return null;
          }

          var declaredDirectives = [];
          var exportedNonModuleIdentifiers = [];
          var declaredPipes = [];
          var importedModules = [];
          var exportedModules = [];
          var providers = [];
          var entryComponents = [];
          var bootstrapComponents = [];
          var schemas = [];

          if (meta.imports) {
            flattenAndDedupeArray(meta.imports).forEach(function (importedType) {
              var importedModuleType = undefined;

              if (isValidType(importedType)) {
                importedModuleType = importedType;
              } else if (importedType && importedType.ngModule) {
                var moduleWithProviders = importedType;
                importedModuleType = moduleWithProviders.ngModule;

                if (moduleWithProviders.providers) {
                  providers.push.apply(providers, _toConsumableArray(_this217._getProvidersMetadata(moduleWithProviders.providers, entryComponents, "provider for the NgModule '".concat(stringifyType(importedModuleType), "'"), [], importedType)));
                }
              }

              if (importedModuleType) {
                if (_this217._checkSelfImport(moduleType, importedModuleType)) return;
                if (!alreadyCollecting) alreadyCollecting = new Set();

                if (alreadyCollecting.has(importedModuleType)) {
                  _this217._reportError(syntaxError("".concat(_this217._getTypeDescriptor(importedModuleType), " '").concat(stringifyType(importedType), "' is imported recursively by the module '").concat(stringifyType(moduleType), "'.")), moduleType);

                  return;
                }

                alreadyCollecting.add(importedModuleType);

                var importedModuleSummary = _this217.getNgModuleSummary(importedModuleType, alreadyCollecting);

                alreadyCollecting.delete(importedModuleType);

                if (!importedModuleSummary) {
                  _this217._reportError(syntaxError("Unexpected ".concat(_this217._getTypeDescriptor(importedType), " '").concat(stringifyType(importedType), "' imported by the module '").concat(stringifyType(moduleType), "'. Please add a @NgModule annotation.")), moduleType);

                  return;
                }

                importedModules.push(importedModuleSummary);
              } else {
                _this217._reportError(syntaxError("Unexpected value '".concat(stringifyType(importedType), "' imported by the module '").concat(stringifyType(moduleType), "'")), moduleType);

                return;
              }
            });
          }

          if (meta.exports) {
            flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {
              if (!isValidType(exportedType)) {
                _this217._reportError(syntaxError("Unexpected value '".concat(stringifyType(exportedType), "' exported by the module '").concat(stringifyType(moduleType), "'")), moduleType);

                return;
              }

              if (!alreadyCollecting) alreadyCollecting = new Set();

              if (alreadyCollecting.has(exportedType)) {
                _this217._reportError(syntaxError("".concat(_this217._getTypeDescriptor(exportedType), " '").concat(stringify(exportedType), "' is exported recursively by the module '").concat(stringifyType(moduleType), "'")), moduleType);

                return;
              }

              alreadyCollecting.add(exportedType);

              var exportedModuleSummary = _this217.getNgModuleSummary(exportedType, alreadyCollecting);

              alreadyCollecting.delete(exportedType);

              if (exportedModuleSummary) {
                exportedModules.push(exportedModuleSummary);
              } else {
                exportedNonModuleIdentifiers.push(_this217._getIdentifierMetadata(exportedType));
              }
            });
          } // Note: This will be modified later, so we rely on
          // getting a new instance every time!


          var transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);

          if (meta.declarations) {
            flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {
              if (!isValidType(declaredType)) {
                _this217._reportError(syntaxError("Unexpected value '".concat(stringifyType(declaredType), "' declared by the module '").concat(stringifyType(moduleType), "'")), moduleType);

                return;
              }

              var declaredIdentifier = _this217._getIdentifierMetadata(declaredType);

              if (_this217.isDirective(declaredType)) {
                if (_this217.isAbstractDirective(declaredType)) {
                  _this217._reportError(syntaxError("Directive ".concat(stringifyType(declaredType), " has no selector, please add it!")), declaredType);
                }

                transitiveModule.addDirective(declaredIdentifier);
                declaredDirectives.push(declaredIdentifier);

                _this217._addTypeToModule(declaredType, moduleType);
              } else if (_this217.isPipe(declaredType)) {
                transitiveModule.addPipe(declaredIdentifier);
                transitiveModule.pipes.push(declaredIdentifier);
                declaredPipes.push(declaredIdentifier);

                _this217._addTypeToModule(declaredType, moduleType);
              } else {
                _this217._reportError(syntaxError("Unexpected ".concat(_this217._getTypeDescriptor(declaredType), " '").concat(stringifyType(declaredType), "' declared by the module '").concat(stringifyType(moduleType), "'. Please add a @Pipe/@Directive/@Component annotation.")), moduleType);

                return;
              }
            });
          }

          var exportedDirectives = [];
          var exportedPipes = [];
          exportedNonModuleIdentifiers.forEach(function (exportedId) {
            if (transitiveModule.directivesSet.has(exportedId.reference)) {
              exportedDirectives.push(exportedId);
              transitiveModule.addExportedDirective(exportedId);
            } else if (transitiveModule.pipesSet.has(exportedId.reference)) {
              exportedPipes.push(exportedId);
              transitiveModule.addExportedPipe(exportedId);
            } else {
              _this217._reportError(syntaxError("Can't export ".concat(_this217._getTypeDescriptor(exportedId.reference), " ").concat(stringifyType(exportedId.reference), " from ").concat(stringifyType(moduleType), " as it was neither declared nor imported!")), moduleType);

              return;
            }
          }); // The providers of the module have to go last
          // so that they overwrite any other provider we already added.

          if (meta.providers) {
            providers.push.apply(providers, _toConsumableArray(this._getProvidersMetadata(meta.providers, entryComponents, "provider for the NgModule '".concat(stringifyType(moduleType), "'"), [], moduleType)));
          }

          if (meta.entryComponents) {
            entryComponents.push.apply(entryComponents, _toConsumableArray(flattenAndDedupeArray(meta.entryComponents).map(function (type) {
              return _this217._getEntryComponentMetadata(type);
            })));
          }

          if (meta.bootstrap) {
            flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {
              if (!isValidType(type)) {
                _this217._reportError(syntaxError("Unexpected value '".concat(stringifyType(type), "' used in the bootstrap property of module '").concat(stringifyType(moduleType), "'")), moduleType);

                return;
              }

              bootstrapComponents.push(_this217._getIdentifierMetadata(type));
            });
          }

          entryComponents.push.apply(entryComponents, _toConsumableArray(bootstrapComponents.map(function (type) {
            return _this217._getEntryComponentMetadata(type.reference);
          })));

          if (meta.schemas) {
            schemas.push.apply(schemas, _toConsumableArray(flattenAndDedupeArray(meta.schemas)));
          }

          compileMeta = new CompileNgModuleMetadata({
            type: this._getTypeMetadata(moduleType),
            providers: providers,
            entryComponents: entryComponents,
            bootstrapComponents: bootstrapComponents,
            schemas: schemas,
            declaredDirectives: declaredDirectives,
            exportedDirectives: exportedDirectives,
            declaredPipes: declaredPipes,
            exportedPipes: exportedPipes,
            importedModules: importedModules,
            exportedModules: exportedModules,
            transitiveModule: transitiveModule,
            id: meta.id || null
          });
          entryComponents.forEach(function (id) {
            return transitiveModule.addEntryComponent(id);
          });
          providers.forEach(function (provider) {
            return transitiveModule.addProvider(provider, compileMeta.type);
          });
          transitiveModule.addModule(compileMeta.type);

          this._ngModuleCache.set(moduleType, compileMeta);

          return compileMeta;
        }
      }, {
        key: "_checkSelfImport",
        value: function _checkSelfImport(moduleType, importedModuleType) {
          if (moduleType === importedModuleType) {
            this._reportError(syntaxError("'".concat(stringifyType(moduleType), "' module can't import itself")), moduleType);

            return true;
          }

          return false;
        }
      }, {
        key: "_getTypeDescriptor",
        value: function _getTypeDescriptor(type) {
          if (isValidType(type)) {
            if (this.isDirective(type)) {
              return 'directive';
            }

            if (this.isPipe(type)) {
              return 'pipe';
            }

            if (this.isNgModule(type)) {
              return 'module';
            }
          }

          if (type.provide) {
            return 'provider';
          }

          return 'value';
        }
      }, {
        key: "_addTypeToModule",
        value: function _addTypeToModule(type, moduleType) {
          var oldModule = this._ngModuleOfTypes.get(type);

          if (oldModule && oldModule !== moduleType) {
            this._reportError(syntaxError("Type ".concat(stringifyType(type), " is part of the declarations of 2 modules: ").concat(stringifyType(oldModule), " and ").concat(stringifyType(moduleType), "! ") + "Please consider moving ".concat(stringifyType(type), " to a higher module that imports ").concat(stringifyType(oldModule), " and ").concat(stringifyType(moduleType), ". ") + "You can also create a new NgModule that exports and includes ".concat(stringifyType(type), " then import that NgModule in ").concat(stringifyType(oldModule), " and ").concat(stringifyType(moduleType), ".")), moduleType);

            return;
          }

          this._ngModuleOfTypes.set(type, moduleType);
        }
      }, {
        key: "_getTransitiveNgModuleMetadata",
        value: function _getTransitiveNgModuleMetadata(importedModules, exportedModules) {
          // collect `providers` / `entryComponents` from all imported and all exported modules
          var result = new TransitiveCompileNgModuleMetadata();
          var modulesByToken = new Map();
          importedModules.concat(exportedModules).forEach(function (modSummary) {
            modSummary.modules.forEach(function (mod) {
              return result.addModule(mod);
            });
            modSummary.entryComponents.forEach(function (comp) {
              return result.addEntryComponent(comp);
            });
            var addedTokens = new Set();
            modSummary.providers.forEach(function (entry) {
              var tokenRef = tokenReference(entry.provider.token);
              var prevModules = modulesByToken.get(tokenRef);

              if (!prevModules) {
                prevModules = new Set();
                modulesByToken.set(tokenRef, prevModules);
              }

              var moduleRef = entry.module.reference; // Note: the providers of one module may still contain multiple providers
              // per token (e.g. for multi providers), and we need to preserve these.

              if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {
                prevModules.add(moduleRef);
                addedTokens.add(tokenRef);
                result.addProvider(entry.provider, entry.module);
              }
            });
          });
          exportedModules.forEach(function (modSummary) {
            modSummary.exportedDirectives.forEach(function (id) {
              return result.addExportedDirective(id);
            });
            modSummary.exportedPipes.forEach(function (id) {
              return result.addExportedPipe(id);
            });
          });
          importedModules.forEach(function (modSummary) {
            modSummary.exportedDirectives.forEach(function (id) {
              return result.addDirective(id);
            });
            modSummary.exportedPipes.forEach(function (id) {
              return result.addPipe(id);
            });
          });
          return result;
        }
      }, {
        key: "_getIdentifierMetadata",
        value: function _getIdentifierMetadata(type) {
          type = resolveForwardRef(type);
          return {
            reference: type
          };
        }
      }, {
        key: "isInjectable",
        value: function isInjectable(type) {
          var annotations = this._reflector.tryAnnotations(type);

          return annotations.some(function (ann) {
            return createInjectable.isTypeOf(ann);
          });
        }
      }, {
        key: "getInjectableSummary",
        value: function getInjectableSummary(type) {
          return {
            summaryKind: CompileSummaryKind.Injectable,
            type: this._getTypeMetadata(type, null, false)
          };
        }
      }, {
        key: "getInjectableMetadata",
        value: function getInjectableMetadata(type) {
          var dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var throwOnUnknownDeps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          var typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);

          var typeMetadata = typeSummary ? typeSummary.type : this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);

          var annotations = this._reflector.annotations(type).filter(function (ann) {
            return createInjectable.isTypeOf(ann);
          });

          if (annotations.length === 0) {
            return null;
          }

          var meta = annotations[annotations.length - 1];
          return {
            symbol: type,
            type: typeMetadata,
            providedIn: meta.providedIn,
            useValue: meta.useValue,
            useClass: meta.useClass,
            useExisting: meta.useExisting,
            useFactory: meta.useFactory,
            deps: meta.deps
          };
        }
      }, {
        key: "_getTypeMetadata",
        value: function _getTypeMetadata(type) {
          var dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var throwOnUnknownDeps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          var identifier = this._getIdentifierMetadata(type);

          return {
            reference: identifier.reference,
            diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),
            lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference)
          };
        }
      }, {
        key: "_getFactoryMetadata",
        value: function _getFactoryMetadata(factory) {
          var dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          factory = resolveForwardRef(factory);
          return {
            reference: factory,
            diDeps: this._getDependenciesMetadata(factory, dependencies)
          };
        }
        /**
         * Gets the metadata for the given pipe.
         * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
         */

      }, {
        key: "getPipeMetadata",
        value: function getPipeMetadata(pipeType) {
          var pipeMeta = this._pipeCache.get(pipeType);

          if (!pipeMeta) {
            this._reportError(syntaxError("Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe ".concat(stringifyType(pipeType), ".")), pipeType);
          }

          return pipeMeta || null;
        }
      }, {
        key: "getPipeSummary",
        value: function getPipeSummary(pipeType) {
          var pipeSummary = this._loadSummary(pipeType, CompileSummaryKind.Pipe);

          if (!pipeSummary) {
            this._reportError(syntaxError("Illegal state: Could not load the summary for pipe ".concat(stringifyType(pipeType), ".")), pipeType);
          }

          return pipeSummary;
        }
      }, {
        key: "getOrLoadPipeMetadata",
        value: function getOrLoadPipeMetadata(pipeType) {
          var pipeMeta = this._pipeCache.get(pipeType);

          if (!pipeMeta) {
            pipeMeta = this._loadPipeMetadata(pipeType);
          }

          return pipeMeta;
        }
      }, {
        key: "_loadPipeMetadata",
        value: function _loadPipeMetadata(pipeType) {
          pipeType = resolveForwardRef(pipeType);

          var pipeAnnotation = this._pipeResolver.resolve(pipeType);

          var pipeMeta = new CompilePipeMetadata({
            type: this._getTypeMetadata(pipeType),
            name: pipeAnnotation.name,
            pure: !!pipeAnnotation.pure
          });

          this._pipeCache.set(pipeType, pipeMeta);

          this._summaryCache.set(pipeType, pipeMeta.toSummary());

          return pipeMeta;
        }
      }, {
        key: "_getDependenciesMetadata",
        value: function _getDependenciesMetadata(typeOrFunc, dependencies) {
          var _this218 = this;

          var throwOnUnknownDeps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var hasUnknownDeps = false;
          var params = dependencies || this._reflector.parameters(typeOrFunc) || [];
          var dependenciesMetadata = params.map(function (param) {
            var isAttribute = false;
            var isHost = false;
            var isSelf = false;
            var isSkipSelf = false;
            var isOptional = false;
            var token = null;

            if (Array.isArray(param)) {
              param.forEach(function (paramEntry) {
                if (createHost.isTypeOf(paramEntry)) {
                  isHost = true;
                } else if (createSelf.isTypeOf(paramEntry)) {
                  isSelf = true;
                } else if (createSkipSelf.isTypeOf(paramEntry)) {
                  isSkipSelf = true;
                } else if (createOptional.isTypeOf(paramEntry)) {
                  isOptional = true;
                } else if (createAttribute.isTypeOf(paramEntry)) {
                  isAttribute = true;
                  token = paramEntry.attributeName;
                } else if (createInject.isTypeOf(paramEntry)) {
                  token = paramEntry.token;
                } else if (createInjectionToken.isTypeOf(paramEntry) || paramEntry instanceof StaticSymbol) {
                  token = paramEntry;
                } else if (isValidType(paramEntry) && token == null) {
                  token = paramEntry;
                }
              });
            } else {
              token = param;
            }

            if (token == null) {
              hasUnknownDeps = true;
              return {};
            }

            return {
              isAttribute: isAttribute,
              isHost: isHost,
              isSelf: isSelf,
              isSkipSelf: isSkipSelf,
              isOptional: isOptional,
              token: _this218._getTokenMetadata(token)
            };
          });

          if (hasUnknownDeps) {
            var depsTokens = dependenciesMetadata.map(function (dep) {
              return dep.token ? stringifyType(dep.token) : '?';
            }).join(', ');
            var message = "Can't resolve all parameters for ".concat(stringifyType(typeOrFunc), ": (").concat(depsTokens, ").");

            if (throwOnUnknownDeps || this._config.strictInjectionParameters) {
              this._reportError(syntaxError(message), typeOrFunc);
            } else {
              this._console.warn("Warning: ".concat(message, " This will become an error in Angular v6.x"));
            }
          }

          return dependenciesMetadata;
        }
      }, {
        key: "_getTokenMetadata",
        value: function _getTokenMetadata(token) {
          token = resolveForwardRef(token);
          var compileToken;

          if (typeof token === 'string') {
            compileToken = {
              value: token
            };
          } else {
            compileToken = {
              identifier: {
                reference: token
              }
            };
          }

          return compileToken;
        }
      }, {
        key: "_getProvidersMetadata",
        value: function _getProvidersMetadata(providers, targetEntryComponents, debugInfo) {
          var _this219 = this;

          var compileProviders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          var type = arguments.length > 4 ? arguments[4] : undefined;
          providers.forEach(function (provider, providerIdx) {
            if (Array.isArray(provider)) {
              _this219._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);
            } else {
              provider = resolveForwardRef(provider);
              var providerMeta = undefined;

              if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {
                _this219._validateProvider(provider);

                providerMeta = new ProviderMeta(provider.provide, provider);
              } else if (isValidType(provider)) {
                providerMeta = new ProviderMeta(provider, {
                  useClass: provider
                });
              } else if (provider === void 0) {
                _this219._reportError(syntaxError("Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files."));

                return;
              } else {
                var providersInfo = providers.reduce(function (soFar, seenProvider, seenProviderIdx) {
                  if (seenProviderIdx < providerIdx) {
                    soFar.push("".concat(stringifyType(seenProvider)));
                  } else if (seenProviderIdx == providerIdx) {
                    soFar.push("?".concat(stringifyType(seenProvider), "?"));
                  } else if (seenProviderIdx == providerIdx + 1) {
                    soFar.push('...');
                  }

                  return soFar;
                }, []).join(', ');

                _this219._reportError(syntaxError("Invalid ".concat(debugInfo ? debugInfo : 'provider', " - only instances of Provider and Type are allowed, got: [").concat(providersInfo, "]")), type);

                return;
              }

              if (providerMeta.token === _this219._reflector.resolveExternalReference(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {
                targetEntryComponents.push.apply(targetEntryComponents, _toConsumableArray(_this219._getEntryComponentsFromProvider(providerMeta, type)));
              } else {
                compileProviders.push(_this219.getProviderMetadata(providerMeta));
              }
            }
          });
          return compileProviders;
        }
      }, {
        key: "_validateProvider",
        value: function _validateProvider(provider) {
          if (provider.hasOwnProperty('useClass') && provider.useClass == null) {
            this._reportError(syntaxError("Invalid provider for ".concat(stringifyType(provider.provide), ". useClass cannot be ").concat(provider.useClass, ".\n           Usually it happens when:\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\n           2. Class was used before it was declared. Use forwardRef in this case.")));
          }
        }
      }, {
        key: "_getEntryComponentsFromProvider",
        value: function _getEntryComponentsFromProvider(provider, type) {
          var _this220 = this;

          var components = [];
          var collectedIdentifiers = [];

          if (provider.useFactory || provider.useExisting || provider.useClass) {
            this._reportError(syntaxError("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!"), type);

            return [];
          }

          if (!provider.multi) {
            this._reportError(syntaxError("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!"), type);

            return [];
          }

          extractIdentifiers(provider.useValue, collectedIdentifiers);
          collectedIdentifiers.forEach(function (identifier) {
            var entry = _this220._getEntryComponentMetadata(identifier.reference, false);

            if (entry) {
              components.push(entry);
            }
          });
          return components;
        }
      }, {
        key: "_getEntryComponentMetadata",
        value: function _getEntryComponentMetadata(dirType) {
          var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);

          if (dirMeta && dirMeta.metadata.isComponent) {
            return {
              componentType: dirType,
              componentFactory: dirMeta.metadata.componentFactory
            };
          }

          var dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);

          if (dirSummary && dirSummary.isComponent) {
            return {
              componentType: dirType,
              componentFactory: dirSummary.componentFactory
            };
          }

          if (throwIfNotFound) {
            throw syntaxError("".concat(dirType.name, " cannot be used as an entry component."));
          }

          return null;
        }
      }, {
        key: "_getInjectableTypeMetadata",
        value: function _getInjectableTypeMetadata(type) {
          var dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          var typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);

          if (typeSummary) {
            return typeSummary.type;
          }

          return this._getTypeMetadata(type, dependencies);
        }
      }, {
        key: "getProviderMetadata",
        value: function getProviderMetadata(provider) {
          var compileDeps = undefined;
          var compileTypeMetadata = null;
          var compileFactoryMetadata = null;

          var token = this._getTokenMetadata(provider.token);

          if (provider.useClass) {
            compileTypeMetadata = this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);
            compileDeps = compileTypeMetadata.diDeps;

            if (provider.token === provider.useClass) {
              // use the compileTypeMetadata as it contains information about lifecycleHooks...
              token = {
                identifier: compileTypeMetadata
              };
            }
          } else if (provider.useFactory) {
            compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);
            compileDeps = compileFactoryMetadata.diDeps;
          }

          return {
            token: token,
            useClass: compileTypeMetadata,
            useValue: provider.useValue,
            useFactory: compileFactoryMetadata,
            useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,
            deps: compileDeps,
            multi: provider.multi
          };
        }
      }, {
        key: "_getQueriesMetadata",
        value: function _getQueriesMetadata(queries, isViewQuery, directiveType) {
          var _this221 = this;

          var res = [];
          Object.keys(queries).forEach(function (propertyName) {
            var query = queries[propertyName];

            if (query.isViewQuery === isViewQuery) {
              res.push(_this221._getQueryMetadata(query, propertyName, directiveType));
            }
          });
          return res;
        }
      }, {
        key: "_queryVarBindings",
        value: function _queryVarBindings(selector) {
          return selector.split(/\s*,\s*/);
        }
      }, {
        key: "_getQueryMetadata",
        value: function _getQueryMetadata(q, propertyName, typeOrFunc) {
          var _this222 = this;

          var selectors;

          if (typeof q.selector === 'string') {
            selectors = this._queryVarBindings(q.selector).map(function (varName) {
              return _this222._getTokenMetadata(varName);
            });
          } else {
            if (!q.selector) {
              this._reportError(syntaxError("Can't construct a query for the property \"".concat(propertyName, "\" of \"").concat(stringifyType(typeOrFunc), "\" since the query selector wasn't defined.")), typeOrFunc);

              selectors = [];
            } else {
              selectors = [this._getTokenMetadata(q.selector)];
            }
          }

          return {
            selectors: selectors,
            first: q.first,
            descendants: q.descendants,
            propertyName: propertyName,
            read: q.read ? this._getTokenMetadata(q.read) : null,
            static: q.static
          };
        }
      }, {
        key: "_reportError",
        value: function _reportError(error, type, otherType) {
          if (this._errorCollector) {
            this._errorCollector(error, type);

            if (otherType) {
              this._errorCollector(error, otherType);
            }
          } else {
            throw error;
          }
        }
      }]);

      return CompileMetadataResolver;
    }();

    function flattenArray(tree) {
      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (tree) {
        for (var i = 0; i < tree.length; i++) {
          var item = resolveForwardRef(tree[i]);

          if (Array.isArray(item)) {
            flattenArray(item, out);
          } else {
            out.push(item);
          }
        }
      }

      return out;
    }

    function dedupeArray(array) {
      if (array) {
        return Array.from(new Set(array));
      }

      return [];
    }

    function flattenAndDedupeArray(tree) {
      return dedupeArray(flattenArray(tree));
    }

    function isValidType(value) {
      return value instanceof StaticSymbol || value instanceof Type;
    }

    function extractIdentifiers(value, targetIdentifiers) {
      visitValue(value, new _CompileValueConverter(), targetIdentifiers);
    }

    var _CompileValueConverter =
    /*#__PURE__*/
    function (_ValueTransformer) {
      _inherits(_CompileValueConverter, _ValueTransformer);

      function _CompileValueConverter() {
        _classCallCheck(this, _CompileValueConverter);

        return _possibleConstructorReturn(this, _getPrototypeOf(_CompileValueConverter).apply(this, arguments));
      }

      _createClass(_CompileValueConverter, [{
        key: "visitOther",
        value: function visitOther(value, targetIdentifiers) {
          targetIdentifiers.push({
            reference: value
          });
        }
      }]);

      return _CompileValueConverter;
    }(ValueTransformer);

    function stringifyType(type) {
      if (type instanceof StaticSymbol) {
        return "".concat(type.name, " in ").concat(type.filePath);
      } else {
        return stringify(type);
      }
    }
    /**
     * Indicates that a component is still being loaded in a synchronous compile.
     */


    function componentStillLoadingError(compType) {
      var error = Error("Can't compile synchronously as ".concat(stringify(compType), " is still being loaded!"));
      error[ERROR_COMPONENT_TYPE] = compType;
      return error;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function providerDef(ctx, providerAst) {
      var flags = 0
      /* None */
      ;

      if (!providerAst.eager) {
        flags |= 4096
        /* LazyProvider */
        ;
      }

      if (providerAst.providerType === ProviderAstType.PrivateService) {
        flags |= 8192
        /* PrivateProvider */
        ;
      }

      if (providerAst.isModule) {
        flags |= 1073741824
        /* TypeModuleProvider */
        ;
      }

      providerAst.lifecycleHooks.forEach(function (lifecycleHook) {
        // for regular providers, we only support ngOnDestroy
        if (lifecycleHook === LifecycleHooks.OnDestroy || providerAst.providerType === ProviderAstType.Directive || providerAst.providerType === ProviderAstType.Component) {
          flags |= lifecycleHookToNodeFlag(lifecycleHook);
        }
      });

      var _ref34 = providerAst.multiProvider ? multiProviderDef(ctx, flags, providerAst.providers) : singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]),
          providerExpr = _ref34.providerExpr,
          providerFlags = _ref34.flags,
          depsExpr = _ref34.depsExpr;

      return {
        providerExpr: providerExpr,
        flags: providerFlags,
        depsExpr: depsExpr,
        tokenExpr: tokenExpr(ctx, providerAst.token)
      };
    }

    function multiProviderDef(ctx, flags, providers) {
      var allDepDefs = [];
      var allParams = [];
      var exprs = providers.map(function (provider, providerIndex) {
        var expr;

        if (provider.useClass) {
          var depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);
          expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);
        } else if (provider.useFactory) {
          var _depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);

          expr = ctx.importExpr(provider.useFactory.reference).callFn(_depExprs);
        } else if (provider.useExisting) {
          var _depExprs2 = convertDeps(providerIndex, [{
            token: provider.useExisting
          }]);

          expr = _depExprs2[0];
        } else {
          expr = convertValueToOutputAst(ctx, provider.useValue);
        }

        return expr;
      });
      var providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);
      return {
        providerExpr: providerExpr,
        flags: flags | 1024
        /* TypeFactoryProvider */
        ,
        depsExpr: literalArr(allDepDefs)
      };

      function convertDeps(providerIndex, deps) {
        return deps.map(function (dep, depIndex) {
          var paramName = "p".concat(providerIndex, "_").concat(depIndex);
          allParams.push(new FnParam(paramName, DYNAMIC_TYPE));
          allDepDefs.push(depDef(ctx, dep));
          return variable(paramName);
        });
      }
    }

    function singleProviderDef(ctx, flags, providerType, providerMeta) {
      var providerExpr;
      var deps;

      if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {
        providerExpr = ctx.importExpr(providerMeta.useClass.reference);
        flags |= 16384
        /* TypeDirective */
        ;
        deps = providerMeta.deps || providerMeta.useClass.diDeps;
      } else {
        if (providerMeta.useClass) {
          providerExpr = ctx.importExpr(providerMeta.useClass.reference);
          flags |= 512
          /* TypeClassProvider */
          ;
          deps = providerMeta.deps || providerMeta.useClass.diDeps;
        } else if (providerMeta.useFactory) {
          providerExpr = ctx.importExpr(providerMeta.useFactory.reference);
          flags |= 1024
          /* TypeFactoryProvider */
          ;
          deps = providerMeta.deps || providerMeta.useFactory.diDeps;
        } else if (providerMeta.useExisting) {
          providerExpr = NULL_EXPR;
          flags |= 2048
          /* TypeUseExistingProvider */
          ;
          deps = [{
            token: providerMeta.useExisting
          }];
        } else {
          providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);
          flags |= 256
          /* TypeValueProvider */
          ;
          deps = [];
        }
      }

      var depsExpr = literalArr(deps.map(function (dep) {
        return depDef(ctx, dep);
      }));
      return {
        providerExpr: providerExpr,
        flags: flags,
        depsExpr: depsExpr
      };
    }

    function tokenExpr(ctx, tokenMeta) {
      return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) : literal(tokenMeta.value);
    }

    function depDef(ctx, dep) {
      // Note: the following fields have already been normalized out by provider_analyzer:
      // - isAttribute, isHost
      var expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token);
      var flags = 0
      /* None */
      ;

      if (dep.isSkipSelf) {
        flags |= 1
        /* SkipSelf */
        ;
      }

      if (dep.isOptional) {
        flags |= 2
        /* Optional */
        ;
      }

      if (dep.isSelf) {
        flags |= 4
        /* Self */
        ;
      }

      if (dep.isValue) {
        flags |= 8
        /* Value */
        ;
      }

      return flags === 0
      /* None */
      ? expr : literalArr([literal(flags), expr]);
    }

    function lifecycleHookToNodeFlag(lifecycleHook) {
      var nodeFlag = 0
      /* None */
      ;

      switch (lifecycleHook) {
        case LifecycleHooks.AfterContentChecked:
          nodeFlag = 2097152
          /* AfterContentChecked */
          ;
          break;

        case LifecycleHooks.AfterContentInit:
          nodeFlag = 1048576
          /* AfterContentInit */
          ;
          break;

        case LifecycleHooks.AfterViewChecked:
          nodeFlag = 8388608
          /* AfterViewChecked */
          ;
          break;

        case LifecycleHooks.AfterViewInit:
          nodeFlag = 4194304
          /* AfterViewInit */
          ;
          break;

        case LifecycleHooks.DoCheck:
          nodeFlag = 262144
          /* DoCheck */
          ;
          break;

        case LifecycleHooks.OnChanges:
          nodeFlag = 524288
          /* OnChanges */
          ;
          break;

        case LifecycleHooks.OnDestroy:
          nodeFlag = 131072
          /* OnDestroy */
          ;
          break;

        case LifecycleHooks.OnInit:
          nodeFlag = 65536
          /* OnInit */
          ;
          break;
      }

      return nodeFlag;
    }

    function componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {
      var entryComponentFactories = entryComponents.map(function (entryComponent) {
        return ctx.importExpr(entryComponent.componentFactory);
      });
      var token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);
      var classMeta = {
        diDeps: [{
          isValue: true,
          value: literalArr(entryComponentFactories)
        }, {
          token: token,
          isSkipSelf: true,
          isOptional: true
        }, {
          token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef)
        }],
        lifecycleHooks: [],
        reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)
      };

      var _singleProviderDef = singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {
        token: token,
        multi: false,
        useClass: classMeta
      }),
          providerExpr = _singleProviderDef.providerExpr,
          providerFlags = _singleProviderDef.flags,
          depsExpr = _singleProviderDef.depsExpr;

      return {
        providerExpr: providerExpr,
        flags: providerFlags,
        depsExpr: depsExpr,
        tokenExpr: tokenExpr(ctx, token)
      };
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var NgModuleCompileResult = function NgModuleCompileResult(ngModuleFactoryVar) {
      _classCallCheck(this, NgModuleCompileResult);

      this.ngModuleFactoryVar = ngModuleFactoryVar;
    };

    var LOG_VAR = variable('_l');

    var NgModuleCompiler =
    /*#__PURE__*/
    function () {
      function NgModuleCompiler(reflector) {
        _classCallCheck(this, NgModuleCompiler);

        this.reflector = reflector;
      }

      _createClass(NgModuleCompiler, [{
        key: "compile",
        value: function compile(ctx, ngModuleMeta, extraProviders) {
          var sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);
          var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;
          var bootstrapComponents = ngModuleMeta.bootstrapComponents;
          var providerParser = new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);
          var providerDefs = [componentFactoryResolverProviderDef(this.reflector, ctx, 0
          /* None */
          , entryComponentFactories)].concat(providerParser.parse().map(function (provider) {
            return providerDef(ctx, provider);
          })).map(function (_ref35) {
            var providerExpr = _ref35.providerExpr,
                depsExpr = _ref35.depsExpr,
                flags = _ref35.flags,
                tokenExpr = _ref35.tokenExpr;
            return importExpr(Identifiers.moduleProviderDef).callFn([literal(flags), tokenExpr, providerExpr, depsExpr]);
          });
          var ngModuleDef = importExpr(Identifiers.moduleDef).callFn([literalArr(providerDefs)]);
          var ngModuleDefFactory = fn([new FnParam(LOG_VAR.name)], [new ReturnStatement(ngModuleDef)], INFERRED_TYPE);
          var ngModuleFactoryVar = "".concat(identifierName(ngModuleMeta.type), "NgFactory");

          this._createNgModuleFactory(ctx, ngModuleMeta.type.reference, importExpr(Identifiers.createModuleFactory).callFn([ctx.importExpr(ngModuleMeta.type.reference), literalArr(bootstrapComponents.map(function (id) {
            return ctx.importExpr(id.reference);
          })), ngModuleDefFactory]));

          if (ngModuleMeta.id) {
            var id = typeof ngModuleMeta.id === 'string' ? literal(ngModuleMeta.id) : ctx.importExpr(ngModuleMeta.id);
            var registerFactoryStmt = importExpr(Identifiers.RegisterModuleFactoryFn).callFn([id, variable(ngModuleFactoryVar)]).toStmt();
            ctx.statements.push(registerFactoryStmt);
          }

          return new NgModuleCompileResult(ngModuleFactoryVar);
        }
      }, {
        key: "createStub",
        value: function createStub(ctx, ngModuleReference) {
          this._createNgModuleFactory(ctx, ngModuleReference, NULL_EXPR);
        }
      }, {
        key: "_createNgModuleFactory",
        value: function _createNgModuleFactory(ctx, reference, value) {
          var ngModuleFactoryVar = "".concat(identifierName({
            reference: reference
          }), "NgFactory");
          var ngModuleFactoryStmt = variable(ngModuleFactoryVar).set(value).toDeclStmt(importType(Identifiers.NgModuleFactory, [expressionType(ctx.importExpr(reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]);
          ctx.statements.push(ngModuleFactoryStmt);
        }
      }]);

      return NgModuleCompiler;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Resolves types to {@link NgModule}.
     */


    var NgModuleResolver =
    /*#__PURE__*/
    function () {
      function NgModuleResolver(_reflector) {
        _classCallCheck(this, NgModuleResolver);

        this._reflector = _reflector;
      }

      _createClass(NgModuleResolver, [{
        key: "isNgModule",
        value: function isNgModule(type) {
          return this._reflector.annotations(type).some(createNgModule.isTypeOf);
        }
      }, {
        key: "resolve",
        value: function resolve(type) {
          var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var ngModuleMeta = findLast(this._reflector.annotations(type), createNgModule.isTypeOf);

          if (ngModuleMeta) {
            return ngModuleMeta;
          } else {
            if (throwIfNotFound) {
              throw new Error("No NgModule metadata found for '".concat(stringify(type), "'."));
            }

            return null;
          }
        }
      }]);

      return NgModuleResolver;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var _debugFilePath = '/debug/lib';

    function debugOutputAstAsTypeScript(ast) {
      var converter = new _TsEmitterVisitor();
      var ctx = EmitterVisitorContext.createRoot();
      var asts = Array.isArray(ast) ? ast : [ast];
      asts.forEach(function (ast) {
        if (ast instanceof Statement) {
          ast.visitStatement(converter, ctx);
        } else if (ast instanceof Expression) {
          ast.visitExpression(converter, ctx);
        } else if (ast instanceof Type$1) {
          ast.visitType(converter, ctx);
        } else {
          throw new Error("Don't know how to print debug info for ".concat(ast));
        }
      });
      return ctx.toSource();
    }

    var TypeScriptEmitter =
    /*#__PURE__*/
    function () {
      function TypeScriptEmitter() {
        _classCallCheck(this, TypeScriptEmitter);
      }

      _createClass(TypeScriptEmitter, [{
        key: "emitStatementsAndContext",
        value: function emitStatementsAndContext(genFilePath, stmts) {
          var preamble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          var emitSourceMaps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var referenceFilter = arguments.length > 4 ? arguments[4] : undefined;
          var importFilter = arguments.length > 5 ? arguments[5] : undefined;
          var converter = new _TsEmitterVisitor(referenceFilter, importFilter);
          var ctx = EmitterVisitorContext.createRoot();
          converter.visitAllStatements(stmts, ctx);
          var preambleLines = preamble ? preamble.split('\n') : [];
          converter.reexports.forEach(function (reexports, exportedModuleName) {
            var reexportsCode = reexports.map(function (reexport) {
              return "".concat(reexport.name, " as ").concat(reexport.as);
            }).join(',');
            preambleLines.push("export {".concat(reexportsCode, "} from '").concat(exportedModuleName, "';"));
          });
          converter.importsWithPrefixes.forEach(function (prefix, importedModuleName) {
            // Note: can't write the real word for import as it screws up system.js auto detection...
            preambleLines.push("imp" + "ort * as ".concat(prefix, " from '").concat(importedModuleName, "';"));
          });
          var sm = emitSourceMaps ? ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment() : '';
          var lines = [].concat(_toConsumableArray(preambleLines), [ctx.toSource(), sm]);

          if (sm) {
            // always add a newline at the end, as some tools have bugs without it.
            lines.push('');
          }

          ctx.setPreambleLineCount(preambleLines.length);
          return {
            sourceText: lines.join('\n'),
            context: ctx
          };
        }
      }, {
        key: "emitStatements",
        value: function emitStatements(genFilePath, stmts) {
          var preamble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          return this.emitStatementsAndContext(genFilePath, stmts, preamble).sourceText;
        }
      }]);

      return TypeScriptEmitter;
    }();

    var _TsEmitterVisitor =
    /*#__PURE__*/
    function (_AbstractEmitterVisit2) {
      _inherits(_TsEmitterVisitor, _AbstractEmitterVisit2);

      function _TsEmitterVisitor(referenceFilter, importFilter) {
        var _this223;

        _classCallCheck(this, _TsEmitterVisitor);

        _this223 = _possibleConstructorReturn(this, _getPrototypeOf(_TsEmitterVisitor).call(this, false));
        _this223.referenceFilter = referenceFilter;
        _this223.importFilter = importFilter;
        _this223.typeExpression = 0;
        _this223.importsWithPrefixes = new Map();
        _this223.reexports = new Map();
        return _this223;
      }

      _createClass(_TsEmitterVisitor, [{
        key: "visitType",
        value: function visitType(t, ctx) {
          var defaultType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'any';

          if (t) {
            this.typeExpression++;
            t.visitType(this, ctx);
            this.typeExpression--;
          } else {
            ctx.print(null, defaultType);
          }
        }
      }, {
        key: "visitLiteralExpr",
        value: function visitLiteralExpr(ast, ctx) {
          var value = ast.value;

          if (value == null && ast.type != INFERRED_TYPE) {
            ctx.print(ast, "(".concat(value, " as any)"));
            return null;
          }

          return _get(_getPrototypeOf(_TsEmitterVisitor.prototype), "visitLiteralExpr", this).call(this, ast, ctx);
        } // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.
        // In SNC mode, [] have the type never[], so we cast here to any[].
        // TODO: narrow the cast to a more explicit type, or use a pattern that does not
        // start with [].concat. see https://github.com/angular/angular/pull/11846

      }, {
        key: "visitLiteralArrayExpr",
        value: function visitLiteralArrayExpr(ast, ctx) {
          if (ast.entries.length === 0) {
            ctx.print(ast, '(');
          }

          var result = _get(_getPrototypeOf(_TsEmitterVisitor.prototype), "visitLiteralArrayExpr", this).call(this, ast, ctx);

          if (ast.entries.length === 0) {
            ctx.print(ast, ' as any[])');
          }

          return result;
        }
      }, {
        key: "visitExternalExpr",
        value: function visitExternalExpr(ast, ctx) {
          this._visitIdentifier(ast.value, ast.typeParams, ctx);

          return null;
        }
      }, {
        key: "visitAssertNotNullExpr",
        value: function visitAssertNotNullExpr(ast, ctx) {
          var result = _get(_getPrototypeOf(_TsEmitterVisitor.prototype), "visitAssertNotNullExpr", this).call(this, ast, ctx);

          ctx.print(ast, '!');
          return result;
        }
      }, {
        key: "visitDeclareVarStmt",
        value: function visitDeclareVarStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr && !stmt.type) {
            // check for a reexport
            var _stmt$value$value = stmt.value.value,
                name = _stmt$value$value.name,
                moduleName = _stmt$value$value.moduleName;

            if (moduleName) {
              var reexports = this.reexports.get(moduleName);

              if (!reexports) {
                reexports = [];
                this.reexports.set(moduleName, reexports);
              }

              reexports.push({
                name: name,
                as: stmt.name
              });
              return null;
            }
          }

          if (stmt.hasModifier(StmtModifier.Exported)) {
            ctx.print(stmt, "export ");
          }

          if (stmt.hasModifier(StmtModifier.Final)) {
            ctx.print(stmt, "const");
          } else {
            ctx.print(stmt, "var");
          }

          ctx.print(stmt, " ".concat(stmt.name));

          this._printColonType(stmt.type, ctx);

          if (stmt.value) {
            ctx.print(stmt, " = ");
            stmt.value.visitExpression(this, ctx);
          }

          ctx.println(stmt, ";");
          return null;
        }
      }, {
        key: "visitWrappedNodeExpr",
        value: function visitWrappedNodeExpr(ast, ctx) {
          throw new Error('Cannot visit a WrappedNodeExpr when outputting Typescript.');
        }
      }, {
        key: "visitCastExpr",
        value: function visitCastExpr(ast, ctx) {
          ctx.print(ast, "(<");
          ast.type.visitType(this, ctx);
          ctx.print(ast, ">");
          ast.value.visitExpression(this, ctx);
          ctx.print(ast, ")");
          return null;
        }
      }, {
        key: "visitInstantiateExpr",
        value: function visitInstantiateExpr(ast, ctx) {
          ctx.print(ast, "new ");
          this.typeExpression++;
          ast.classExpr.visitExpression(this, ctx);
          this.typeExpression--;
          ctx.print(ast, "(");
          this.visitAllExpressions(ast.args, ctx, ',');
          ctx.print(ast, ")");
          return null;
        }
      }, {
        key: "visitDeclareClassStmt",
        value: function visitDeclareClassStmt(stmt, ctx) {
          var _this224 = this;

          ctx.pushClass(stmt);

          if (stmt.hasModifier(StmtModifier.Exported)) {
            ctx.print(stmt, "export ");
          }

          ctx.print(stmt, "class ".concat(stmt.name));

          if (stmt.parent != null) {
            ctx.print(stmt, " extends ");
            this.typeExpression++;
            stmt.parent.visitExpression(this, ctx);
            this.typeExpression--;
          }

          ctx.println(stmt, " {");
          ctx.incIndent();
          stmt.fields.forEach(function (field) {
            return _this224._visitClassField(field, ctx);
          });

          if (stmt.constructorMethod != null) {
            this._visitClassConstructor(stmt, ctx);
          }

          stmt.getters.forEach(function (getter) {
            return _this224._visitClassGetter(getter, ctx);
          });
          stmt.methods.forEach(function (method) {
            return _this224._visitClassMethod(method, ctx);
          });
          ctx.decIndent();
          ctx.println(stmt, "}");
          ctx.popClass();
          return null;
        }
      }, {
        key: "_visitClassField",
        value: function _visitClassField(field, ctx) {
          if (field.hasModifier(StmtModifier.Private)) {
            // comment out as a workaround for #10967
            ctx.print(null, "/*private*/ ");
          }

          if (field.hasModifier(StmtModifier.Static)) {
            ctx.print(null, 'static ');
          }

          ctx.print(null, field.name);

          this._printColonType(field.type, ctx);

          if (field.initializer) {
            ctx.print(null, ' = ');
            field.initializer.visitExpression(this, ctx);
          }

          ctx.println(null, ";");
        }
      }, {
        key: "_visitClassGetter",
        value: function _visitClassGetter(getter, ctx) {
          if (getter.hasModifier(StmtModifier.Private)) {
            ctx.print(null, "private ");
          }

          ctx.print(null, "get ".concat(getter.name, "()"));

          this._printColonType(getter.type, ctx);

          ctx.println(null, " {");
          ctx.incIndent();
          this.visitAllStatements(getter.body, ctx);
          ctx.decIndent();
          ctx.println(null, "}");
        }
      }, {
        key: "_visitClassConstructor",
        value: function _visitClassConstructor(stmt, ctx) {
          ctx.print(stmt, "constructor(");

          this._visitParams(stmt.constructorMethod.params, ctx);

          ctx.println(stmt, ") {");
          ctx.incIndent();
          this.visitAllStatements(stmt.constructorMethod.body, ctx);
          ctx.decIndent();
          ctx.println(stmt, "}");
        }
      }, {
        key: "_visitClassMethod",
        value: function _visitClassMethod(method, ctx) {
          if (method.hasModifier(StmtModifier.Private)) {
            ctx.print(null, "private ");
          }

          ctx.print(null, "".concat(method.name, "("));

          this._visitParams(method.params, ctx);

          ctx.print(null, ")");

          this._printColonType(method.type, ctx, 'void');

          ctx.println(null, " {");
          ctx.incIndent();
          this.visitAllStatements(method.body, ctx);
          ctx.decIndent();
          ctx.println(null, "}");
        }
      }, {
        key: "visitFunctionExpr",
        value: function visitFunctionExpr(ast, ctx) {
          if (ast.name) {
            ctx.print(ast, 'function ');
            ctx.print(ast, ast.name);
          }

          ctx.print(ast, "(");

          this._visitParams(ast.params, ctx);

          ctx.print(ast, ")");

          this._printColonType(ast.type, ctx, 'void');

          if (!ast.name) {
            ctx.print(ast, " => ");
          }

          ctx.println(ast, '{');
          ctx.incIndent();
          this.visitAllStatements(ast.statements, ctx);
          ctx.decIndent();
          ctx.print(ast, "}");
          return null;
        }
      }, {
        key: "visitDeclareFunctionStmt",
        value: function visitDeclareFunctionStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported)) {
            ctx.print(stmt, "export ");
          }

          ctx.print(stmt, "function ".concat(stmt.name, "("));

          this._visitParams(stmt.params, ctx);

          ctx.print(stmt, ")");

          this._printColonType(stmt.type, ctx, 'void');

          ctx.println(stmt, " {");
          ctx.incIndent();
          this.visitAllStatements(stmt.statements, ctx);
          ctx.decIndent();
          ctx.println(stmt, "}");
          return null;
        }
      }, {
        key: "visitTryCatchStmt",
        value: function visitTryCatchStmt(stmt, ctx) {
          ctx.println(stmt, "try {");
          ctx.incIndent();
          this.visitAllStatements(stmt.bodyStmts, ctx);
          ctx.decIndent();
          ctx.println(stmt, "} catch (".concat(CATCH_ERROR_VAR$1.name, ") {"));
          ctx.incIndent();
          var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack', null)).toDeclStmt(null, [StmtModifier.Final])].concat(stmt.catchStmts);
          this.visitAllStatements(catchStmts, ctx);
          ctx.decIndent();
          ctx.println(stmt, "}");
          return null;
        }
      }, {
        key: "visitBuiltinType",
        value: function visitBuiltinType(type, ctx) {
          var typeStr;

          switch (type.name) {
            case BuiltinTypeName.Bool:
              typeStr = 'boolean';
              break;

            case BuiltinTypeName.Dynamic:
              typeStr = 'any';
              break;

            case BuiltinTypeName.Function:
              typeStr = 'Function';
              break;

            case BuiltinTypeName.Number:
              typeStr = 'number';
              break;

            case BuiltinTypeName.Int:
              typeStr = 'number';
              break;

            case BuiltinTypeName.String:
              typeStr = 'string';
              break;

            case BuiltinTypeName.None:
              typeStr = 'never';
              break;

            default:
              throw new Error("Unsupported builtin type ".concat(type.name));
          }

          ctx.print(null, typeStr);
          return null;
        }
      }, {
        key: "visitExpressionType",
        value: function visitExpressionType(ast, ctx) {
          var _this225 = this;

          ast.value.visitExpression(this, ctx);

          if (ast.typeParams !== null) {
            ctx.print(null, '<');
            this.visitAllObjects(function (type) {
              return _this225.visitType(type, ctx);
            }, ast.typeParams, ctx, ',');
            ctx.print(null, '>');
          }

          return null;
        }
      }, {
        key: "visitArrayType",
        value: function visitArrayType(type, ctx) {
          this.visitType(type.of, ctx);
          ctx.print(null, "[]");
          return null;
        }
      }, {
        key: "visitMapType",
        value: function visitMapType(type, ctx) {
          ctx.print(null, "{[key: string]:");
          this.visitType(type.valueType, ctx);
          ctx.print(null, "}");
          return null;
        }
      }, {
        key: "getBuiltinMethodName",
        value: function getBuiltinMethodName(method) {
          var name;

          switch (method) {
            case BuiltinMethod.ConcatArray:
              name = 'concat';
              break;

            case BuiltinMethod.SubscribeObservable:
              name = 'subscribe';
              break;

            case BuiltinMethod.Bind:
              name = 'bind';
              break;

            default:
              throw new Error("Unknown builtin method: ".concat(method));
          }

          return name;
        }
      }, {
        key: "_visitParams",
        value: function _visitParams(params, ctx) {
          var _this226 = this;

          this.visitAllObjects(function (param) {
            ctx.print(null, param.name);

            _this226._printColonType(param.type, ctx);
          }, params, ctx, ',');
        }
      }, {
        key: "_visitIdentifier",
        value: function _visitIdentifier(value, typeParams, ctx) {
          var _this227 = this;

          var name = value.name,
              moduleName = value.moduleName;

          if (this.referenceFilter && this.referenceFilter(value)) {
            ctx.print(null, '(null as any)');
            return;
          }

          if (moduleName && (!this.importFilter || !this.importFilter(value))) {
            var prefix = this.importsWithPrefixes.get(moduleName);

            if (prefix == null) {
              prefix = "i".concat(this.importsWithPrefixes.size);
              this.importsWithPrefixes.set(moduleName, prefix);
            }

            ctx.print(null, "".concat(prefix, "."));
          }

          ctx.print(null, name);

          if (this.typeExpression > 0) {
            // If we are in a type expression that refers to a generic type then supply
            // the required type parameters. If there were not enough type parameters
            // supplied, supply any as the type. Outside a type expression the reference
            // should not supply type parameters and be treated as a simple value reference
            // to the constructor function itself.
            var suppliedParameters = typeParams || [];

            if (suppliedParameters.length > 0) {
              ctx.print(null, "<");
              this.visitAllObjects(function (type) {
                return type.visitType(_this227, ctx);
              }, typeParams, ctx, ',');
              ctx.print(null, ">");
            }
          }
        }
      }, {
        key: "_printColonType",
        value: function _printColonType(type, ctx, defaultType) {
          if (type !== INFERRED_TYPE) {
            ctx.print(null, ':');
            this.visitType(type, ctx, defaultType);
          }
        }
      }]);

      return _TsEmitterVisitor;
    }(AbstractEmitterVisitor);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Resolve a `Type` for {@link Pipe}.
     *
     * This interface can be overridden by the application developer to create custom behavior.
     *
     * See {@link Compiler}
     */


    var PipeResolver =
    /*#__PURE__*/
    function () {
      function PipeResolver(_reflector) {
        _classCallCheck(this, PipeResolver);

        this._reflector = _reflector;
      }

      _createClass(PipeResolver, [{
        key: "isPipe",
        value: function isPipe(type) {
          var typeMetadata = this._reflector.annotations(resolveForwardRef(type));

          return typeMetadata && typeMetadata.some(createPipe.isTypeOf);
        }
        /**
         * Return {@link Pipe} for a given `Type`.
         */

      }, {
        key: "resolve",
        value: function resolve(type) {
          var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          var metas = this._reflector.annotations(resolveForwardRef(type));

          if (metas) {
            var annotation = findLast(metas, createPipe.isTypeOf);

            if (annotation) {
              return annotation;
            }
          }

          if (throwIfNotFound) {
            throw new Error("No Pipe decorator found on ".concat(stringify(type)));
          }

          return null;
        }
      }]);

      return PipeResolver;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Generates code that is used to type check templates.
     */


    var TypeCheckCompiler =
    /*#__PURE__*/
    function () {
      function TypeCheckCompiler(options, reflector) {
        _classCallCheck(this, TypeCheckCompiler);

        this.options = options;
        this.reflector = reflector;
      }
      /**
       * Important notes:
       * - This must not produce new `import` statements, but only refer to types outside
       *   of the file via the variables provided via externalReferenceVars.
       *   This allows Typescript to reuse the old program's structure as no imports have changed.
       * - This must not produce any exports, as this would pollute the .d.ts file
       *   and also violate the point above.
       */


      _createClass(TypeCheckCompiler, [{
        key: "compileComponent",
        value: function compileComponent(componentId, component, template, usedPipes, externalReferenceVars, ctx) {
          var _this228 = this;

          var pipes = new Map();
          usedPipes.forEach(function (p) {
            return pipes.set(p.name, p.type.reference);
          });
          var embeddedViewCount = 0;

          var viewBuilderFactory = function viewBuilderFactory(parent, guards) {
            var embeddedViewIndex = embeddedViewCount++;
            return new ViewBuilder(_this228.options, _this228.reflector, externalReferenceVars, parent, component.type.reference, component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);
          };

          var visitor = viewBuilderFactory(null, []);
          visitor.visitAll([], template);
          return visitor.build(componentId);
        }
      }]);

      return TypeCheckCompiler;
    }();

    var DYNAMIC_VAR_NAME = '_any';

    var TypeCheckLocalResolver =
    /*#__PURE__*/
    function () {
      function TypeCheckLocalResolver() {
        _classCallCheck(this, TypeCheckLocalResolver);
      }

      _createClass(TypeCheckLocalResolver, [{
        key: "notifyImplicitReceiverUse",
        value: function notifyImplicitReceiverUse() {}
      }, {
        key: "getLocal",
        value: function getLocal(name) {
          if (name === EventHandlerVars.event.name) {
            // References to the event should not be type-checked.
            // TODO(chuckj): determine a better type for the event.
            return variable(DYNAMIC_VAR_NAME);
          }

          return null;
        }
      }]);

      return TypeCheckLocalResolver;
    }();

    var defaultResolver = new TypeCheckLocalResolver();

    var ViewBuilder =
    /*#__PURE__*/
    function () {
      function ViewBuilder(options, reflector, externalReferenceVars, parent, component, isHostComponent, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory) {
        _classCallCheck(this, ViewBuilder);

        this.options = options;
        this.reflector = reflector;
        this.externalReferenceVars = externalReferenceVars;
        this.parent = parent;
        this.component = component;
        this.isHostComponent = isHostComponent;
        this.embeddedViewIndex = embeddedViewIndex;
        this.pipes = pipes;
        this.guards = guards;
        this.ctx = ctx;
        this.viewBuilderFactory = viewBuilderFactory;
        this.refOutputVars = new Map();
        this.variables = [];
        this.children = [];
        this.updates = [];
        this.actions = [];
      }

      _createClass(ViewBuilder, [{
        key: "getOutputVar",
        value: function getOutputVar(type) {
          var varName;

          if (type === this.component && this.isHostComponent) {
            varName = DYNAMIC_VAR_NAME;
          } else if (type instanceof StaticSymbol) {
            varName = this.externalReferenceVars.get(type);
          } else {
            varName = DYNAMIC_VAR_NAME;
          }

          if (!varName) {
            throw new Error("Illegal State: referring to a type without a variable ".concat(JSON.stringify(type)));
          }

          return varName;
        }
      }, {
        key: "getTypeGuardExpressions",
        value: function getTypeGuardExpressions(ast) {
          var result = _toConsumableArray(this.guards);

          var _iteratorNormalCompletion15 = true;
          var _didIteratorError15 = false;
          var _iteratorError15 = undefined;

          try {
            for (var _iterator15 = ast.directives[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
              var directive = _step15.value;
              var _iteratorNormalCompletion16 = true;
              var _didIteratorError16 = false;
              var _iteratorError16 = undefined;

              try {
                for (var _iterator16 = directive.inputs[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                  var input = _step16.value;
                  var guard = directive.directive.guards[input.directiveName];

                  if (guard) {
                    var useIf = guard === 'UseIf';
                    result.push({
                      guard: guard,
                      useIf: useIf,
                      expression: {
                        context: this.component,
                        value: input.value
                      }
                    });
                  }
                }
              } catch (err) {
                _didIteratorError16 = true;
                _iteratorError16 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
                    _iterator16.return();
                  }
                } finally {
                  if (_didIteratorError16) {
                    throw _iteratorError16;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError15 = true;
            _iteratorError15 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
                _iterator15.return();
              }
            } finally {
              if (_didIteratorError15) {
                throw _iteratorError15;
              }
            }
          }

          return result;
        }
      }, {
        key: "visitAll",
        value: function visitAll(variables, astNodes) {
          this.variables = variables;
          templateVisitAll(this, astNodes);
        }
      }, {
        key: "build",
        value: function build(componentId) {
          var _this229 = this;

          var targetStatements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          this.children.forEach(function (child) {
            return child.build(componentId, targetStatements);
          });
          var viewStmts = [variable(DYNAMIC_VAR_NAME).set(NULL_EXPR).toDeclStmt(DYNAMIC_TYPE)];
          var bindingCount = 0;
          this.updates.forEach(function (expression) {
            var _viewStmts;

            var _this229$preprocessUp = _this229.preprocessUpdateExpression(expression),
                sourceSpan = _this229$preprocessUp.sourceSpan,
                context = _this229$preprocessUp.context,
                value = _this229$preprocessUp.value;

            var bindingId = "".concat(bindingCount++);
            var nameResolver = context === _this229.component ? _this229 : defaultResolver;

            var _convertPropertyBindi = _convertPropertyBinding(nameResolver, variable(_this229.getOutputVar(context)), value, bindingId, BindingForm.General),
                stmts = _convertPropertyBindi.stmts,
                currValExpr = _convertPropertyBindi.currValExpr;

            stmts.push(new ExpressionStatement(currValExpr));

            (_viewStmts = viewStmts).push.apply(_viewStmts, _toConsumableArray(stmts.map(function (stmt) {
              return applySourceSpanToStatementIfNeeded(stmt, sourceSpan);
            })));
          });
          this.actions.forEach(function (_ref36) {
            var _viewStmts2;

            var sourceSpan = _ref36.sourceSpan,
                context = _ref36.context,
                value = _ref36.value;
            var bindingId = "".concat(bindingCount++);
            var nameResolver = context === _this229.component ? _this229 : defaultResolver;

            var _convertActionBinding = convertActionBinding(nameResolver, variable(_this229.getOutputVar(context)), value, bindingId),
                stmts = _convertActionBinding.stmts;

            (_viewStmts2 = viewStmts).push.apply(_viewStmts2, _toConsumableArray(stmts.map(function (stmt) {
              return applySourceSpanToStatementIfNeeded(stmt, sourceSpan);
            })));
          });

          if (this.guards.length) {
            var guardExpression = undefined;
            var _iteratorNormalCompletion17 = true;
            var _didIteratorError17 = false;
            var _iteratorError17 = undefined;

            try {
              for (var _iterator17 = this.guards[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                var guard = _step17.value;

                var _this$preprocessUpdat = this.preprocessUpdateExpression(guard.expression),
                    context = _this$preprocessUpdat.context,
                    value = _this$preprocessUpdat.value;

                var bindingId = "".concat(bindingCount++);
                var nameResolver = context === this.component ? this : defaultResolver; // We only support support simple expressions and ignore others as they
                // are unlikely to affect type narrowing.

                var _convertPropertyBindi2 = _convertPropertyBinding(nameResolver, variable(this.getOutputVar(context)), value, bindingId, BindingForm.TrySimple),
                    stmts = _convertPropertyBindi2.stmts,
                    currValExpr = _convertPropertyBindi2.currValExpr;

                if (stmts.length == 0) {
                  var guardClause = guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);
                  guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;
                }
              }
            } catch (err) {
              _didIteratorError17 = true;
              _iteratorError17 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
                  _iterator17.return();
                }
              } finally {
                if (_didIteratorError17) {
                  throw _iteratorError17;
                }
              }
            }

            if (guardExpression) {
              viewStmts = [new IfStmt(guardExpression, viewStmts)];
            }
          }

          var viewName = "_View_".concat(componentId, "_").concat(this.embeddedViewIndex);
          var viewFactory = new DeclareFunctionStmt(viewName, [], viewStmts);
          targetStatements.push(viewFactory);
          return targetStatements;
        }
      }, {
        key: "visitBoundText",
        value: function visitBoundText(ast, context) {
          var _this230 = this;

          var astWithSource = ast.value;
          var inter = astWithSource.ast;
          inter.expressions.forEach(function (expr) {
            return _this230.updates.push({
              context: _this230.component,
              value: expr,
              sourceSpan: ast.sourceSpan
            });
          });
        }
      }, {
        key: "visitEmbeddedTemplate",
        value: function visitEmbeddedTemplate(ast, context) {
          this.visitElementOrTemplate(ast); // Note: The old view compiler used to use an `any` type
          // for the context in any embedded view.
          // We keep this behaivor behind a flag for now.

          if (this.options.fullTemplateTypeCheck) {
            // Find any applicable type guards. For example, NgIf has a type guard on ngIf
            // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only
            // stamped out if ngIf is truthy so any bindings in the template can assume that,
            // if a nullable type is used for ngIf, that expression is not null or undefined.
            var guards = this.getTypeGuardExpressions(ast);
            var childVisitor = this.viewBuilderFactory(this, guards);
            this.children.push(childVisitor);
            childVisitor.visitAll(ast.variables, ast.children);
          }
        }
      }, {
        key: "visitElement",
        value: function visitElement(ast, context) {
          var _this231 = this;

          this.visitElementOrTemplate(ast);
          var inputDefs = [];
          var updateRendererExpressions = [];
          var outputDefs = [];
          ast.inputs.forEach(function (inputAst) {
            _this231.updates.push({
              context: _this231.component,
              value: inputAst.value,
              sourceSpan: inputAst.sourceSpan
            });
          });
          templateVisitAll(this, ast.children);
        }
      }, {
        key: "visitElementOrTemplate",
        value: function visitElementOrTemplate(ast) {
          var _this232 = this;

          ast.directives.forEach(function (dirAst) {
            _this232.visitDirective(dirAst);
          });
          ast.references.forEach(function (ref) {
            var outputVarType = null; // Note: The old view compiler used to use an `any` type
            // for directives exposed via `exportAs`.
            // We keep this behaivor behind a flag for now.

            if (ref.value && ref.value.identifier && _this232.options.fullTemplateTypeCheck) {
              outputVarType = ref.value.identifier.reference;
            } else {
              outputVarType = BuiltinTypeName.Dynamic;
            }

            _this232.refOutputVars.set(ref.name, outputVarType);
          });
          ast.outputs.forEach(function (outputAst) {
            _this232.actions.push({
              context: _this232.component,
              value: outputAst.handler,
              sourceSpan: outputAst.sourceSpan
            });
          });
        }
      }, {
        key: "visitDirective",
        value: function visitDirective(dirAst) {
          var _this233 = this;

          var dirType = dirAst.directive.type.reference;
          dirAst.inputs.forEach(function (input) {
            return _this233.updates.push({
              context: _this233.component,
              value: input.value,
              sourceSpan: input.sourceSpan
            });
          }); // Note: The old view compiler used to use an `any` type
          // for expressions in host properties / events.
          // We keep this behaivor behind a flag for now.

          if (this.options.fullTemplateTypeCheck) {
            dirAst.hostProperties.forEach(function (inputAst) {
              return _this233.updates.push({
                context: dirType,
                value: inputAst.value,
                sourceSpan: inputAst.sourceSpan
              });
            });
            dirAst.hostEvents.forEach(function (hostEventAst) {
              return _this233.actions.push({
                context: dirType,
                value: hostEventAst.handler,
                sourceSpan: hostEventAst.sourceSpan
              });
            });
          }
        }
      }, {
        key: "notifyImplicitReceiverUse",
        value: function notifyImplicitReceiverUse() {}
      }, {
        key: "getLocal",
        value: function getLocal(name) {
          if (name == EventHandlerVars.event.name) {
            return variable(this.getOutputVar(BuiltinTypeName.Dynamic));
          }

          for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent) {
            var outputVarType = void 0; // check references

            outputVarType = currBuilder.refOutputVars.get(name);

            if (outputVarType == null) {
              // check variables
              var varAst = currBuilder.variables.find(function (varAst) {
                return varAst.name === name;
              });

              if (varAst) {
                outputVarType = BuiltinTypeName.Dynamic;
              }
            }

            if (outputVarType != null) {
              return variable(this.getOutputVar(outputVarType));
            }
          }

          return null;
        }
      }, {
        key: "pipeOutputVar",
        value: function pipeOutputVar(name) {
          var pipe = this.pipes.get(name);

          if (!pipe) {
            throw new Error("Illegal State: Could not find pipe ".concat(name, " in template of ").concat(this.component));
          }

          return this.getOutputVar(pipe);
        }
      }, {
        key: "preprocessUpdateExpression",
        value: function preprocessUpdateExpression(expression) {
          var _this234 = this;

          return {
            sourceSpan: expression.sourceSpan,
            context: expression.context,
            value: convertPropertyBindingBuiltins({
              createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {
                return function (args) {
                  var arr = literalArr(args); // Note: The old view compiler used to use an `any` type
                  // for arrays.

                  return _this234.options.fullTemplateTypeCheck ? arr : arr.cast(DYNAMIC_TYPE);
                };
              },
              createLiteralMapConverter: function createLiteralMapConverter(keys) {
                return function (values) {
                  var entries = keys.map(function (k, i) {
                    return {
                      key: k.key,
                      value: values[i],
                      quoted: k.quoted
                    };
                  });
                  var map = literalMap(entries); // Note: The old view compiler used to use an `any` type
                  // for maps.

                  return _this234.options.fullTemplateTypeCheck ? map : map.cast(DYNAMIC_TYPE);
                };
              },
              createPipeConverter: function createPipeConverter(name, argCount) {
                return function (args) {
                  // Note: The old view compiler used to use an `any` type
                  // for pipes.
                  var pipeExpr = _this234.options.fullTemplateTypeCheck ? variable(_this234.pipeOutputVar(name)) : variable(_this234.getOutputVar(BuiltinTypeName.Dynamic));
                  return pipeExpr.callMethod('transform', args);
                };
              }
            }, expression.value)
          };
        }
      }, {
        key: "visitNgContent",
        value: function visitNgContent(ast, context) {}
      }, {
        key: "visitText",
        value: function visitText(ast, context) {}
      }, {
        key: "visitDirectiveProperty",
        value: function visitDirectiveProperty(ast, context) {}
      }, {
        key: "visitReference",
        value: function visitReference(ast, context) {}
      }, {
        key: "visitVariable",
        value: function visitVariable(ast, context) {}
      }, {
        key: "visitEvent",
        value: function visitEvent(ast, context) {}
      }, {
        key: "visitElementProperty",
        value: function visitElementProperty(ast, context) {}
      }, {
        key: "visitAttr",
        value: function visitAttr(ast, context) {}
      }]);

      return ViewBuilder;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var CLASS_ATTR$1 = 'class';
    var STYLE_ATTR = 'style';
    var IMPLICIT_TEMPLATE_VAR = '\$implicit';

    var ViewCompileResult = function ViewCompileResult(viewClassVar, rendererTypeVar) {
      _classCallCheck(this, ViewCompileResult);

      this.viewClassVar = viewClassVar;
      this.rendererTypeVar = rendererTypeVar;
    };

    var ViewCompiler =
    /*#__PURE__*/
    function () {
      function ViewCompiler(_reflector) {
        _classCallCheck(this, ViewCompiler);

        this._reflector = _reflector;
      }

      _createClass(ViewCompiler, [{
        key: "compileComponent",
        value: function compileComponent(outputCtx, component, template, styles, usedPipes) {
          var _this235 = this,
              _outputCtx$statements;

          var embeddedViewCount = 0;
          var renderComponentVarName = undefined;

          if (!component.isHost) {
            var _template = component.template;
            var customRenderData = [];

            if (_template.animations && _template.animations.length) {
              customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(outputCtx, _template.animations), true));
            }

            var renderComponentVar = variable(rendererTypeName(component.type.reference));
            renderComponentVarName = renderComponentVar.name;
            outputCtx.statements.push(renderComponentVar.set(importExpr(Identifiers.createRendererType2).callFn([new LiteralMapExpr([new LiteralMapEntry('encapsulation', literal(_template.encapsulation), false), new LiteralMapEntry('styles', styles, false), new LiteralMapEntry('data', new LiteralMapExpr(customRenderData), false)])])).toDeclStmt(importType(Identifiers.RendererType2), [StmtModifier.Final, StmtModifier.Exported]));
          }

          var viewBuilderFactory = function viewBuilderFactory(parent) {
            var embeddedViewIndex = embeddedViewCount++;
            return new ViewBuilder$1(_this235._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory);
          };

          var visitor = viewBuilderFactory(null);
          visitor.visitAll([], template);

          (_outputCtx$statements = outputCtx.statements).push.apply(_outputCtx$statements, _toConsumableArray(visitor.build()));

          return new ViewCompileResult(visitor.viewName, renderComponentVarName);
        }
      }]);

      return ViewCompiler;
    }();

    var LOG_VAR$1 = variable('_l');
    var VIEW_VAR = variable('_v');
    var CHECK_VAR = variable('_ck');
    var COMP_VAR = variable('_co');
    var EVENT_NAME_VAR = variable('en');
    var ALLOW_DEFAULT_VAR = variable("ad");

    var ViewBuilder$1 =
    /*#__PURE__*/
    function () {
      function ViewBuilder$1(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory) {
        _classCallCheck(this, ViewBuilder$1);

        this.reflector = reflector;
        this.outputCtx = outputCtx;
        this.parent = parent;
        this.component = component;
        this.embeddedViewIndex = embeddedViewIndex;
        this.usedPipes = usedPipes;
        this.viewBuilderFactory = viewBuilderFactory;
        this.nodes = [];
        this.purePipeNodeIndices = Object.create(null); // Need Object.create so that we don't have builtin values...

        this.refNodeIndices = Object.create(null);
        this.variables = [];
        this.children = []; // TODO(tbosch): The old view compiler used to use an `any` type
        // for the context in any embedded view. We keep this behaivor for now
        // to be able to introduce the new view compiler without too many errors.

        this.compType = this.embeddedViewIndex > 0 ? DYNAMIC_TYPE : expressionType(outputCtx.importExpr(this.component.type.reference));
        this.viewName = viewClassName(this.component.type.reference, this.embeddedViewIndex);
      }

      _createClass(ViewBuilder$1, [{
        key: "visitAll",
        value: function visitAll(variables, astNodes) {
          var _this236 = this;

          this.variables = variables; // create the pipes for the pure pipes immediately, so that we know their indices.

          if (!this.parent) {
            this.usedPipes.forEach(function (pipe) {
              if (pipe.pure) {
                _this236.purePipeNodeIndices[pipe.name] = _this236._createPipe(null, pipe);
              }
            });
          }

          if (!this.parent) {
            this.component.viewQueries.forEach(function (query, queryIndex) {
              // Note: queries start with id 1 so we can use the number in a Bloom filter!
              var queryId = queryIndex + 1;
              var bindingType = query.first ? 0
              /* First */
              : 1
              /* All */
              ;
              var flags = 134217728
              /* TypeViewQuery */
              | calcStaticDynamicQueryFlags(query);

              _this236.nodes.push(function () {
                return {
                  sourceSpan: null,
                  nodeFlags: flags,
                  nodeDef: importExpr(Identifiers.queryDef).callFn([literal(flags), literal(queryId), new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])])
                };
              });
            });
          }

          templateVisitAll(this, astNodes);

          if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {
            // if the view is an embedded view, then we need to add an additional root node in some cases
            this.nodes.push(function () {
              return {
                sourceSpan: null,
                nodeFlags: 1
                /* TypeElement */
                ,
                nodeDef: importExpr(Identifiers.anchorDef).callFn([literal(0
                /* None */
                ), NULL_EXPR, NULL_EXPR, literal(0)])
              };
            });
          }
        }
      }, {
        key: "build",
        value: function build() {
          var targetStatements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          this.children.forEach(function (child) {
            return child.build(targetStatements);
          });

          var _this$_createNodeExpr = this._createNodeExpressions(),
              updateRendererStmts = _this$_createNodeExpr.updateRendererStmts,
              updateDirectivesStmts = _this$_createNodeExpr.updateDirectivesStmts,
              nodeDefExprs = _this$_createNodeExpr.nodeDefExprs;

          var updateRendererFn = this._createUpdateFn(updateRendererStmts);

          var updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);

          var viewFlags = 0
          /* None */
          ;

          if (!this.parent && this.component.changeDetection === ChangeDetectionStrategy.OnPush) {
            viewFlags |= 2
            /* OnPush */
            ;
          }

          var viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(LOG_VAR$1.name)], [new ReturnStatement(importExpr(Identifiers.viewDef).callFn([literal(viewFlags), literalArr(nodeDefExprs), updateDirectivesFn, updateRendererFn]))], importType(Identifiers.ViewDefinition), this.embeddedViewIndex === 0 ? [StmtModifier.Exported] : []);
          targetStatements.push(viewFactory);
          return targetStatements;
        }
      }, {
        key: "_createUpdateFn",
        value: function _createUpdateFn(updateStmts) {
          var updateFn;

          if (updateStmts.length > 0) {
            var preStmts = [];

            if (!this.component.isHost && findReadVarNames(updateStmts).has(COMP_VAR.name)) {
              preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));
            }

            updateFn = fn([new FnParam(CHECK_VAR.name, INFERRED_TYPE), new FnParam(VIEW_VAR.name, INFERRED_TYPE)], [].concat(preStmts, _toConsumableArray(updateStmts)), INFERRED_TYPE);
          } else {
            updateFn = NULL_EXPR;
          }

          return updateFn;
        }
      }, {
        key: "visitNgContent",
        value: function visitNgContent(ast, context) {
          // ngContentDef(ngContentIndex: number, index: number): NodeDef;
          this.nodes.push(function () {
            return {
              sourceSpan: ast.sourceSpan,
              nodeFlags: 8
              /* TypeNgContent */
              ,
              nodeDef: importExpr(Identifiers.ngContentDef).callFn([literal(ast.ngContentIndex), literal(ast.index)])
            };
          });
        }
      }, {
        key: "visitText",
        value: function visitText(ast, context) {
          // Static text nodes have no check function
          var checkIndex = -1;
          this.nodes.push(function () {
            return {
              sourceSpan: ast.sourceSpan,
              nodeFlags: 2
              /* TypeText */
              ,
              nodeDef: importExpr(Identifiers.textDef).callFn([literal(checkIndex), literal(ast.ngContentIndex), literalArr([literal(ast.value)])])
            };
          });
        }
      }, {
        key: "visitBoundText",
        value: function visitBoundText(ast, context) {
          var _this237 = this;

          var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array

          this.nodes.push(null);
          var astWithSource = ast.value;
          var inter = astWithSource.ast;
          var updateRendererExpressions = inter.expressions.map(function (expr, bindingIndex) {
            return _this237._preprocessUpdateExpression({
              nodeIndex: nodeIndex,
              bindingIndex: bindingIndex,
              sourceSpan: ast.sourceSpan,
              context: COMP_VAR,
              value: expr
            });
          }); // Check index is the same as the node index during compilation
          // They might only differ at runtime

          var checkIndex = nodeIndex;

          this.nodes[nodeIndex] = function () {
            return {
              sourceSpan: ast.sourceSpan,
              nodeFlags: 2
              /* TypeText */
              ,
              nodeDef: importExpr(Identifiers.textDef).callFn([literal(checkIndex), literal(ast.ngContentIndex), literalArr(inter.strings.map(function (s) {
                return literal(s);
              }))]),
              updateRenderer: updateRendererExpressions
            };
          };
        }
      }, {
        key: "visitEmbeddedTemplate",
        value: function visitEmbeddedTemplate(ast, context) {
          var _this238 = this;

          var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array

          this.nodes.push(null);

          var _this$_visitElementOr = this._visitElementOrTemplate(nodeIndex, ast),
              flags = _this$_visitElementOr.flags,
              queryMatchesExpr = _this$_visitElementOr.queryMatchesExpr,
              hostEvents = _this$_visitElementOr.hostEvents;

          var childVisitor = this.viewBuilderFactory(this);
          this.children.push(childVisitor);
          childVisitor.visitAll(ast.variables, ast.children);
          var childCount = this.nodes.length - nodeIndex - 1; // anchorDef(
          //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,
          //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:
          //   ViewDefinitionFactory): NodeDef;

          this.nodes[nodeIndex] = function () {
            return {
              sourceSpan: ast.sourceSpan,
              nodeFlags: 1
              /* TypeElement */
              | flags,
              nodeDef: importExpr(Identifiers.anchorDef).callFn([literal(flags), queryMatchesExpr, literal(ast.ngContentIndex), literal(childCount), _this238._createElementHandleEventFn(nodeIndex, hostEvents), variable(childVisitor.viewName)])
            };
          };
        }
      }, {
        key: "visitElement",
        value: function visitElement(ast, context) {
          var _this239 = this;

          var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array so we can add children

          this.nodes.push(null); // Using a null element name creates an anchor.

          var elName = isNgContainer(ast.name) ? null : ast.name;

          var _this$_visitElementOr2 = this._visitElementOrTemplate(nodeIndex, ast),
              flags = _this$_visitElementOr2.flags,
              usedEvents = _this$_visitElementOr2.usedEvents,
              queryMatchesExpr = _this$_visitElementOr2.queryMatchesExpr,
              dirHostBindings = _this$_visitElementOr2.hostBindings,
              hostEvents = _this$_visitElementOr2.hostEvents;

          var inputDefs = [];
          var updateRendererExpressions = [];
          var outputDefs = [];

          if (elName) {
            var hostBindings = ast.inputs.map(function (inputAst) {
              return {
                context: COMP_VAR,
                inputAst: inputAst,
                dirAst: null
              };
            }).concat(dirHostBindings);

            if (hostBindings.length) {
              updateRendererExpressions = hostBindings.map(function (hostBinding, bindingIndex) {
                return _this239._preprocessUpdateExpression({
                  context: hostBinding.context,
                  nodeIndex: nodeIndex,
                  bindingIndex: bindingIndex,
                  sourceSpan: hostBinding.inputAst.sourceSpan,
                  value: hostBinding.inputAst.value
                });
              });
              inputDefs = hostBindings.map(function (hostBinding) {
                return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst);
              });
            }

            outputDefs = usedEvents.map(function (_ref37) {
              var _ref38 = _slicedToArray(_ref37, 2),
                  target = _ref38[0],
                  eventName = _ref38[1];

              return literalArr([literal(target), literal(eventName)]);
            });
          }

          templateVisitAll(this, ast.children);
          var childCount = this.nodes.length - nodeIndex - 1;
          var compAst = ast.directives.find(function (dirAst) {
            return dirAst.directive.isComponent;
          });
          var compRendererType = NULL_EXPR;
          var compView = NULL_EXPR;

          if (compAst) {
            compView = this.outputCtx.importExpr(compAst.directive.componentViewType);
            compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);
          } // Check index is the same as the node index during compilation
          // They might only differ at runtime


          var checkIndex = nodeIndex;

          this.nodes[nodeIndex] = function () {
            return {
              sourceSpan: ast.sourceSpan,
              nodeFlags: 1
              /* TypeElement */
              | flags,
              nodeDef: importExpr(Identifiers.elementDef).callFn([literal(checkIndex), literal(flags), queryMatchesExpr, literal(ast.ngContentIndex), literal(childCount), literal(elName), elName ? fixedAttrsDef(ast) : NULL_EXPR, inputDefs.length ? literalArr(inputDefs) : NULL_EXPR, outputDefs.length ? literalArr(outputDefs) : NULL_EXPR, _this239._createElementHandleEventFn(nodeIndex, hostEvents), compView, compRendererType]),
              updateRenderer: updateRendererExpressions
            };
          };
        }
      }, {
        key: "_visitElementOrTemplate",
        value: function _visitElementOrTemplate(nodeIndex, ast) {
          var _this240 = this;

          var flags = 0
          /* None */
          ;

          if (ast.hasViewContainer) {
            flags |= 16777216
            /* EmbeddedViews */
            ;
          }

          var usedEvents = new Map();
          ast.outputs.forEach(function (event) {
            var _elementEventNameAndT = elementEventNameAndTarget(event, null),
                name = _elementEventNameAndT.name,
                target = _elementEventNameAndT.target;

            usedEvents.set(elementEventFullName(target, name), [target, name]);
          });
          ast.directives.forEach(function (dirAst) {
            dirAst.hostEvents.forEach(function (event) {
              var _elementEventNameAndT2 = elementEventNameAndTarget(event, dirAst),
                  name = _elementEventNameAndT2.name,
                  target = _elementEventNameAndT2.target;

              usedEvents.set(elementEventFullName(target, name), [target, name]);
            });
          });
          var hostBindings = [];
          var hostEvents = [];

          this._visitComponentFactoryResolverProvider(ast.directives);

          ast.providers.forEach(function (providerAst) {
            var dirAst = undefined;
            ast.directives.forEach(function (localDirAst) {
              if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {
                dirAst = localDirAst;
              }
            });

            if (dirAst) {
              var _this240$_visitDirect = _this240._visitDirective(providerAst, dirAst, ast.references, ast.queryMatches, usedEvents),
                  dirHostBindings = _this240$_visitDirect.hostBindings,
                  dirHostEvents = _this240$_visitDirect.hostEvents;

              hostBindings.push.apply(hostBindings, _toConsumableArray(dirHostBindings));
              hostEvents.push.apply(hostEvents, _toConsumableArray(dirHostEvents));
            } else {
              _this240._visitProvider(providerAst, ast.queryMatches);
            }
          });
          var queryMatchExprs = [];
          ast.queryMatches.forEach(function (match) {
            var valueType = undefined;

            if (tokenReference(match.value) === _this240.reflector.resolveExternalReference(Identifiers.ElementRef)) {
              valueType = 0
              /* ElementRef */
              ;
            } else if (tokenReference(match.value) === _this240.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {
              valueType = 3
              /* ViewContainerRef */
              ;
            } else if (tokenReference(match.value) === _this240.reflector.resolveExternalReference(Identifiers.TemplateRef)) {
              valueType = 2
              /* TemplateRef */
              ;
            }

            if (valueType != null) {
              queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));
            }
          });
          ast.references.forEach(function (ref) {
            var valueType = undefined;

            if (!ref.value) {
              valueType = 1
              /* RenderElement */
              ;
            } else if (tokenReference(ref.value) === _this240.reflector.resolveExternalReference(Identifiers.TemplateRef)) {
              valueType = 2
              /* TemplateRef */
              ;
            }

            if (valueType != null) {
              _this240.refNodeIndices[ref.name] = nodeIndex;
              queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));
            }
          });
          ast.outputs.forEach(function (outputAst) {
            hostEvents.push({
              context: COMP_VAR,
              eventAst: outputAst,
              dirAst: null
            });
          });
          return {
            flags: flags,
            usedEvents: Array.from(usedEvents.values()),
            queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,
            hostBindings: hostBindings,
            hostEvents: hostEvents
          };
        }
      }, {
        key: "_visitDirective",
        value: function _visitDirective(providerAst, dirAst, refs, queryMatches, usedEvents) {
          var _this241 = this;

          var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array so we can add children

          this.nodes.push(null);
          dirAst.directive.queries.forEach(function (query, queryIndex) {
            var queryId = dirAst.contentQueryStartId + queryIndex;
            var flags = 67108864
            /* TypeContentQuery */
            | calcStaticDynamicQueryFlags(query);
            var bindingType = query.first ? 0
            /* First */
            : 1
            /* All */
            ;

            _this241.nodes.push(function () {
              return {
                sourceSpan: dirAst.sourceSpan,
                nodeFlags: flags,
                nodeDef: importExpr(Identifiers.queryDef).callFn([literal(flags), literal(queryId), new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])])
              };
            });
          }); // Note: the operation below might also create new nodeDefs,
          // but we don't want them to be a child of a directive,
          // as they might be a provider/pipe on their own.
          // I.e. we only allow queries as children of directives nodes.

          var childCount = this.nodes.length - nodeIndex - 1;

          var _this$_visitProviderO = this._visitProviderOrDirective(providerAst, queryMatches),
              flags = _this$_visitProviderO.flags,
              queryMatchExprs = _this$_visitProviderO.queryMatchExprs,
              providerExpr = _this$_visitProviderO.providerExpr,
              depsExpr = _this$_visitProviderO.depsExpr;

          refs.forEach(function (ref) {
            if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {
              _this241.refNodeIndices[ref.name] = nodeIndex;
              queryMatchExprs.push(literalArr([literal(ref.name), literal(4
              /* Provider */
              )]));
            }
          });

          if (dirAst.directive.isComponent) {
            flags |= 32768
            /* Component */
            ;
          }

          var inputDefs = dirAst.inputs.map(function (inputAst, inputIndex) {
            var mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]); // Note: it's important to not quote the key so that we can capture renames by minifiers!

            return new LiteralMapEntry(inputAst.directiveName, mapValue, false);
          });
          var outputDefs = [];
          var dirMeta = dirAst.directive;
          Object.keys(dirMeta.outputs).forEach(function (propName) {
            var eventName = dirMeta.outputs[propName];

            if (usedEvents.has(eventName)) {
              // Note: it's important to not quote the key so that we can capture renames by minifiers!
              outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));
            }
          });
          var updateDirectiveExpressions = [];

          if (dirAst.inputs.length || (flags & (262144
          /* DoCheck */
          | 65536
          /* OnInit */
          )) > 0) {
            updateDirectiveExpressions = dirAst.inputs.map(function (input, bindingIndex) {
              return _this241._preprocessUpdateExpression({
                nodeIndex: nodeIndex,
                bindingIndex: bindingIndex,
                sourceSpan: input.sourceSpan,
                context: COMP_VAR,
                value: input.value
              });
            });
          }

          var dirContextExpr = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);
          var hostBindings = dirAst.hostProperties.map(function (inputAst) {
            return {
              context: dirContextExpr,
              dirAst: dirAst,
              inputAst: inputAst
            };
          });
          var hostEvents = dirAst.hostEvents.map(function (hostEventAst) {
            return {
              context: dirContextExpr,
              eventAst: hostEventAst,
              dirAst: dirAst
            };
          }); // Check index is the same as the node index during compilation
          // They might only differ at runtime

          var checkIndex = nodeIndex;

          this.nodes[nodeIndex] = function () {
            return {
              sourceSpan: dirAst.sourceSpan,
              nodeFlags: 16384
              /* TypeDirective */
              | flags,
              nodeDef: importExpr(Identifiers.directiveDef).callFn([literal(checkIndex), literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR, literal(childCount), providerExpr, depsExpr, inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR, outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR]),
              updateDirectives: updateDirectiveExpressions,
              directive: dirAst.directive.type
            };
          };

          return {
            hostBindings: hostBindings,
            hostEvents: hostEvents
          };
        }
      }, {
        key: "_visitProvider",
        value: function _visitProvider(providerAst, queryMatches) {
          this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));
        }
      }, {
        key: "_visitComponentFactoryResolverProvider",
        value: function _visitComponentFactoryResolverProvider(directives) {
          var componentDirMeta = directives.find(function (dirAst) {
            return dirAst.directive.isComponent;
          });

          if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {
            var _componentFactoryReso = componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192
            /* PrivateProvider */
            , componentDirMeta.directive.entryComponents),
                providerExpr = _componentFactoryReso.providerExpr,
                depsExpr = _componentFactoryReso.depsExpr,
                flags = _componentFactoryReso.flags,
                _tokenExpr = _componentFactoryReso.tokenExpr;

            this._addProviderNode({
              providerExpr: providerExpr,
              depsExpr: depsExpr,
              flags: flags,
              tokenExpr: _tokenExpr,
              queryMatchExprs: [],
              sourceSpan: componentDirMeta.sourceSpan
            });
          }
        }
      }, {
        key: "_addProviderNode",
        value: function _addProviderNode(data) {
          // providerDef(
          //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,
          //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;
          this.nodes.push(function () {
            return {
              sourceSpan: data.sourceSpan,
              nodeFlags: data.flags,
              nodeDef: importExpr(Identifiers.providerDef).callFn([literal(data.flags), data.queryMatchExprs.length ? literalArr(data.queryMatchExprs) : NULL_EXPR, data.tokenExpr, data.providerExpr, data.depsExpr])
            };
          });
        }
      }, {
        key: "_visitProviderOrDirective",
        value: function _visitProviderOrDirective(providerAst, queryMatches) {
          var flags = 0
          /* None */
          ;
          var queryMatchExprs = [];
          queryMatches.forEach(function (match) {
            if (tokenReference(match.value) === tokenReference(providerAst.token)) {
              queryMatchExprs.push(literalArr([literal(match.queryId), literal(4
              /* Provider */
              )]));
            }
          });

          var _providerDef = providerDef(this.outputCtx, providerAst),
              providerExpr = _providerDef.providerExpr,
              depsExpr = _providerDef.depsExpr,
              providerFlags = _providerDef.flags,
              tokenExpr = _providerDef.tokenExpr;

          return {
            flags: flags | providerFlags,
            queryMatchExprs: queryMatchExprs,
            providerExpr: providerExpr,
            depsExpr: depsExpr,
            tokenExpr: tokenExpr,
            sourceSpan: providerAst.sourceSpan
          };
        }
      }, {
        key: "getLocal",
        value: function getLocal(name) {
          if (name == EventHandlerVars.event.name) {
            return EventHandlerVars.event;
          }

          var currViewExpr = VIEW_VAR;

          for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent, currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {
            // check references
            var refNodeIndex = currBuilder.refNodeIndices[name];

            if (refNodeIndex != null) {
              return importExpr(Identifiers.nodeValue).callFn([currViewExpr, literal(refNodeIndex)]);
            } // check variables


            var varAst = currBuilder.variables.find(function (varAst) {
              return varAst.name === name;
            });

            if (varAst) {
              var varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;
              return currViewExpr.prop('context').prop(varValue);
            }
          }

          return null;
        }
      }, {
        key: "notifyImplicitReceiverUse",
        value: function notifyImplicitReceiverUse() {// Not needed in View Engine as View Engine walks through the generated
          // expressions to figure out if the implicit receiver is used and needs
          // to be generated as part of the pre-update statements.
        }
      }, {
        key: "_createLiteralArrayConverter",
        value: function _createLiteralArrayConverter(sourceSpan, argCount) {
          if (argCount === 0) {
            var valueExpr = importExpr(Identifiers.EMPTY_ARRAY);
            return function () {
              return valueExpr;
            };
          }

          var checkIndex = this.nodes.length;
          this.nodes.push(function () {
            return {
              sourceSpan: sourceSpan,
              nodeFlags: 32
              /* TypePureArray */
              ,
              nodeDef: importExpr(Identifiers.pureArrayDef).callFn([literal(checkIndex), literal(argCount)])
            };
          });
          return function (args) {
            return callCheckStmt(checkIndex, args);
          };
        }
      }, {
        key: "_createLiteralMapConverter",
        value: function _createLiteralMapConverter(sourceSpan, keys) {
          if (keys.length === 0) {
            var valueExpr = importExpr(Identifiers.EMPTY_MAP);
            return function () {
              return valueExpr;
            };
          }

          var map = literalMap(keys.map(function (e, i) {
            return Object.assign(Object.assign({}, e), {
              value: literal(i)
            });
          }));
          var checkIndex = this.nodes.length;
          this.nodes.push(function () {
            return {
              sourceSpan: sourceSpan,
              nodeFlags: 64
              /* TypePureObject */
              ,
              nodeDef: importExpr(Identifiers.pureObjectDef).callFn([literal(checkIndex), map])
            };
          });
          return function (args) {
            return callCheckStmt(checkIndex, args);
          };
        }
      }, {
        key: "_createPipeConverter",
        value: function _createPipeConverter(expression, name, argCount) {
          var pipe = this.usedPipes.find(function (pipeSummary) {
            return pipeSummary.name === name;
          });

          if (pipe.pure) {
            var checkIndex = this.nodes.length;
            this.nodes.push(function () {
              return {
                sourceSpan: expression.sourceSpan,
                nodeFlags: 128
                /* TypePurePipe */
                ,
                nodeDef: importExpr(Identifiers.purePipeDef).callFn([literal(checkIndex), literal(argCount)])
              };
            }); // find underlying pipe in the component view

            var compViewExpr = VIEW_VAR;
            var compBuilder = this;

            while (compBuilder.parent) {
              compBuilder = compBuilder.parent;
              compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);
            }

            var pipeNodeIndex = compBuilder.purePipeNodeIndices[name];
            var pipeValueExpr = importExpr(Identifiers.nodeValue).callFn([compViewExpr, literal(pipeNodeIndex)]);
            return function (args) {
              return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(checkIndex, [pipeValueExpr].concat(args)));
            };
          } else {
            var nodeIndex = this._createPipe(expression.sourceSpan, pipe);

            var nodeValueExpr = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);
            return function (args) {
              return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr.callMethod('transform', args));
            };
          }
        }
      }, {
        key: "_createPipe",
        value: function _createPipe(sourceSpan, pipe) {
          var _this242 = this;

          var nodeIndex = this.nodes.length;
          var flags = 0
          /* None */
          ;
          pipe.type.lifecycleHooks.forEach(function (lifecycleHook) {
            // for pipes, we only support ngOnDestroy
            if (lifecycleHook === LifecycleHooks.OnDestroy) {
              flags |= lifecycleHookToNodeFlag(lifecycleHook);
            }
          });
          var depExprs = pipe.type.diDeps.map(function (diDep) {
            return depDef(_this242.outputCtx, diDep);
          }); // function pipeDef(
          //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef

          this.nodes.push(function () {
            return {
              sourceSpan: sourceSpan,
              nodeFlags: 16
              /* TypePipe */
              ,
              nodeDef: importExpr(Identifiers.pipeDef).callFn([literal(flags), _this242.outputCtx.importExpr(pipe.type.reference), literalArr(depExprs)])
            };
          });
          return nodeIndex;
        }
        /**
         * For the AST in `UpdateExpression.value`:
         * - create nodes for pipes, literal arrays and, literal maps,
         * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.
         *
         * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!
         */

      }, {
        key: "_preprocessUpdateExpression",
        value: function _preprocessUpdateExpression(expression) {
          var _this243 = this;

          return {
            nodeIndex: expression.nodeIndex,
            bindingIndex: expression.bindingIndex,
            sourceSpan: expression.sourceSpan,
            context: expression.context,
            value: convertPropertyBindingBuiltins({
              createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {
                return _this243._createLiteralArrayConverter(expression.sourceSpan, argCount);
              },
              createLiteralMapConverter: function createLiteralMapConverter(keys) {
                return _this243._createLiteralMapConverter(expression.sourceSpan, keys);
              },
              createPipeConverter: function createPipeConverter(name, argCount) {
                return _this243._createPipeConverter(expression, name, argCount);
              }
            }, expression.value)
          };
        }
      }, {
        key: "_createNodeExpressions",
        value: function _createNodeExpressions() {
          var self = this;
          var updateBindingCount = 0;
          var updateRendererStmts = [];
          var updateDirectivesStmts = [];
          var nodeDefExprs = this.nodes.map(function (factory, nodeIndex) {
            var _factory = factory(),
                nodeDef = _factory.nodeDef,
                nodeFlags = _factory.nodeFlags,
                updateDirectives = _factory.updateDirectives,
                updateRenderer = _factory.updateRenderer,
                sourceSpan = _factory.sourceSpan;

            if (updateRenderer) {
              updateRendererStmts.push.apply(updateRendererStmts, _toConsumableArray(createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false)));
            }

            if (updateDirectives) {
              updateDirectivesStmts.push.apply(updateDirectivesStmts, _toConsumableArray(createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144
              /* DoCheck */
              | 65536
              /* OnInit */
              )) > 0)));
            } // We use a comma expression to call the log function before
            // the nodeDef function, but still use the result of the nodeDef function
            // as the value.
            // Note: We only add the logger to elements / text nodes,
            // so we don't generate too much code.


            var logWithNodeDef = nodeFlags & 3
            /* CatRenderNode */
            ? new CommaExpr([LOG_VAR$1.callFn([]).callFn([]), nodeDef]) : nodeDef;
            return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);
          });
          return {
            updateRendererStmts: updateRendererStmts,
            updateDirectivesStmts: updateDirectivesStmts,
            nodeDefExprs: nodeDefExprs
          };

          function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {
            var updateStmts = [];
            var exprs = expressions.map(function (_ref39) {
              var sourceSpan = _ref39.sourceSpan,
                  context = _ref39.context,
                  value = _ref39.value;
              var bindingId = "".concat(updateBindingCount++);
              var nameResolver = context === COMP_VAR ? self : null;

              var _convertPropertyBindi3 = _convertPropertyBinding(nameResolver, context, value, bindingId, BindingForm.General),
                  stmts = _convertPropertyBindi3.stmts,
                  currValExpr = _convertPropertyBindi3.currValExpr;

              updateStmts.push.apply(updateStmts, _toConsumableArray(stmts.map(function (stmt) {
                return applySourceSpanToStatementIfNeeded(stmt, sourceSpan);
              })));
              return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);
            });

            if (expressions.length || allowEmptyExprs) {
              updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));
            }

            return updateStmts;
          }
        }
      }, {
        key: "_createElementHandleEventFn",
        value: function _createElementHandleEventFn(nodeIndex, handlers) {
          var _this244 = this;

          var handleEventStmts = [];
          var handleEventBindingCount = 0;
          handlers.forEach(function (_ref40) {
            var context = _ref40.context,
                eventAst = _ref40.eventAst,
                dirAst = _ref40.dirAst;
            var bindingId = "".concat(handleEventBindingCount++);
            var nameResolver = context === COMP_VAR ? _this244 : null;

            var _convertActionBinding2 = convertActionBinding(nameResolver, context, eventAst.handler, bindingId),
                stmts = _convertActionBinding2.stmts,
                allowDefault = _convertActionBinding2.allowDefault;

            var trueStmts = stmts;

            if (allowDefault) {
              trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());
            }

            var _elementEventNameAndT3 = elementEventNameAndTarget(eventAst, dirAst),
                eventTarget = _elementEventNameAndT3.target,
                eventName = _elementEventNameAndT3.name;

            var fullEventName = elementEventFullName(eventTarget, eventName);
            handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));
          });
          var handleEventFn;

          if (handleEventStmts.length > 0) {
            var preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];

            if (!this.component.isHost && findReadVarNames(handleEventStmts).has(COMP_VAR.name)) {
              preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));
            }

            handleEventFn = fn([new FnParam(VIEW_VAR.name, INFERRED_TYPE), new FnParam(EVENT_NAME_VAR.name, INFERRED_TYPE), new FnParam(EventHandlerVars.event.name, INFERRED_TYPE)], [].concat(preStmts, handleEventStmts, [new ReturnStatement(ALLOW_DEFAULT_VAR)]), INFERRED_TYPE);
          } else {
            handleEventFn = NULL_EXPR;
          }

          return handleEventFn;
        }
      }, {
        key: "visitDirective",
        value: function visitDirective(ast, context) {}
      }, {
        key: "visitDirectiveProperty",
        value: function visitDirectiveProperty(ast, context) {}
      }, {
        key: "visitReference",
        value: function visitReference(ast, context) {}
      }, {
        key: "visitVariable",
        value: function visitVariable(ast, context) {}
      }, {
        key: "visitEvent",
        value: function visitEvent(ast, context) {}
      }, {
        key: "visitElementProperty",
        value: function visitElementProperty(ast, context) {}
      }, {
        key: "visitAttr",
        value: function visitAttr(ast, context) {}
      }]);

      return ViewBuilder$1;
    }();

    function needsAdditionalRootNode(astNodes) {
      var lastAstNode = astNodes[astNodes.length - 1];

      if (lastAstNode instanceof EmbeddedTemplateAst) {
        return lastAstNode.hasViewContainer;
      }

      if (lastAstNode instanceof ElementAst) {
        if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {
          return needsAdditionalRootNode(lastAstNode.children);
        }

        return lastAstNode.hasViewContainer;
      }

      return lastAstNode instanceof NgContentAst;
    }

    function elementBindingDef(inputAst, dirAst) {
      var inputType = inputAst.type;

      switch (inputType) {
        case 1
        /* Attribute */
        :
          return literalArr([literal(1
          /* TypeElementAttribute */
          ), literal(inputAst.name), literal(inputAst.securityContext)]);

        case 0
        /* Property */
        :
          return literalArr([literal(8
          /* TypeProperty */
          ), literal(inputAst.name), literal(inputAst.securityContext)]);

        case 4
        /* Animation */
        :
          var bindingType = 8
          /* TypeProperty */
          | (dirAst && dirAst.directive.isComponent ? 32
          /* SyntheticHostProperty */
          : 16
          /* SyntheticProperty */
          );
          return literalArr([literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)]);

        case 2
        /* Class */
        :
          return literalArr([literal(2
          /* TypeElementClass */
          ), literal(inputAst.name), NULL_EXPR]);

        case 3
        /* Style */
        :
          return literalArr([literal(4
          /* TypeElementStyle */
          ), literal(inputAst.name), literal(inputAst.unit)]);

        default:
          // This default case is not needed by TypeScript compiler, as the switch is exhaustive.
          // However Closure Compiler does not understand that and reports an error in typed mode.
          // The `throw new Error` below works around the problem, and the unexpected: never variable
          // makes sure tsc still checks this code is unreachable.
          var unexpected = inputType;
          throw new Error("unexpected ".concat(unexpected));
      }
    }

    function fixedAttrsDef(elementAst) {
      var mapResult = Object.create(null);
      elementAst.attrs.forEach(function (attrAst) {
        mapResult[attrAst.name] = attrAst.value;
      });
      elementAst.directives.forEach(function (dirAst) {
        Object.keys(dirAst.directive.hostAttributes).forEach(function (name) {
          var value = dirAst.directive.hostAttributes[name];
          var prevValue = mapResult[name];
          mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;
        });
      }); // Note: We need to sort to get a defined output order
      // for tests and for caching generated artifacts...

      return literalArr(Object.keys(mapResult).sort().map(function (attrName) {
        return literalArr([literal(attrName), literal(mapResult[attrName])]);
      }));
    }

    function mergeAttributeValue(attrName, attrValue1, attrValue2) {
      if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {
        return "".concat(attrValue1, " ").concat(attrValue2);
      } else {
        return attrValue2;
      }
    }

    function callCheckStmt(nodeIndex, exprs) {
      if (exprs.length > 10) {
        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1
        /* Dynamic */
        ), literalArr(exprs)]);
      } else {
        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(0
        /* Inline */
        )].concat(_toConsumableArray(exprs)));
      }
    }

    function callUnwrapValue(nodeIndex, bindingIdx, expr) {
      return importExpr(Identifiers.unwrapValue).callFn([VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr]);
    }

    function elementEventNameAndTarget(eventAst, dirAst) {
      if (eventAst.isAnimation) {
        return {
          name: "@".concat(eventAst.name, ".").concat(eventAst.phase),
          target: dirAst && dirAst.directive.isComponent ? 'component' : null
        };
      } else {
        return eventAst;
      }
    }

    function calcStaticDynamicQueryFlags(query) {
      var flags = 0
      /* None */
      ; // Note: We only make queries static that query for a single item and the user specifically
      // set the to be static. This is because of backwards compatibility with the old view compiler...

      if (query.first && query.static) {
        flags |= 268435456
        /* StaticQuery */
        ;
      } else {
        flags |= 536870912
        /* DynamicQuery */
        ;
      }

      return flags;
    }

    function elementEventFullName(target, name) {
      return target ? "".concat(target, ":").concat(name) : name;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * A container for message extracted from the templates.
     */


    var MessageBundle =
    /*#__PURE__*/
    function () {
      function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs) {
        var _locale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        _classCallCheck(this, MessageBundle);

        this._htmlParser = _htmlParser;
        this._implicitTags = _implicitTags;
        this._implicitAttrs = _implicitAttrs;
        this._locale = _locale;
        this._messages = [];
      }

      _createClass(MessageBundle, [{
        key: "updateFromTemplate",
        value: function updateFromTemplate(html, url, interpolationConfig) {
          var _this$_messages;

          var htmlParserResult = this._htmlParser.parse(html, url, {
            tokenizeExpansionForms: true,
            interpolationConfig: interpolationConfig
          });

          if (htmlParserResult.errors.length) {
            return htmlParserResult.errors;
          }

          var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);

          if (i18nParserResult.errors.length) {
            return i18nParserResult.errors;
          }

          (_this$_messages = this._messages).push.apply(_this$_messages, _toConsumableArray(i18nParserResult.messages));

          return [];
        } // Return the message in the internal format
        // The public (serialized) format might be different, see the `write` method.

      }, {
        key: "getMessages",
        value: function getMessages() {
          return this._messages;
        }
      }, {
        key: "write",
        value: function write(serializer, filterSources) {
          var messages = {};
          var mapperVisitor = new MapPlaceholderNames(); // Deduplicate messages based on their ID

          this._messages.forEach(function (message) {
            var id = serializer.digest(message);

            if (!messages.hasOwnProperty(id)) {
              messages[id] = message;
            } else {
              var _messages$id$sources;

              (_messages$id$sources = messages[id].sources).push.apply(_messages$id$sources, _toConsumableArray(message.sources));
            }
          }); // Transform placeholder names using the serializer mapping


          var msgList = Object.keys(messages).map(function (id) {
            var mapper = serializer.createNameMapper(messages[id]);
            var src = messages[id];
            var nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;
            var transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);
            transformedMessage.sources = src.sources;

            if (filterSources) {
              transformedMessage.sources.forEach(function (source) {
                return source.filePath = filterSources(source.filePath);
              });
            }

            return transformedMessage;
          });
          return serializer.write(msgList, this._locale);
        }
      }]);

      return MessageBundle;
    }(); // Transform an i18n AST by renaming the placeholder nodes with the given mapper


    var MapPlaceholderNames =
    /*#__PURE__*/
    function (_CloneVisitor) {
      _inherits(MapPlaceholderNames, _CloneVisitor);

      function MapPlaceholderNames() {
        _classCallCheck(this, MapPlaceholderNames);

        return _possibleConstructorReturn(this, _getPrototypeOf(MapPlaceholderNames).apply(this, arguments));
      }

      _createClass(MapPlaceholderNames, [{
        key: "convert",
        value: function convert(nodes, mapper) {
          var _this245 = this;

          return mapper ? nodes.map(function (n) {
            return n.visit(_this245, mapper);
          }) : nodes;
        }
      }, {
        key: "visitTagPlaceholder",
        value: function visitTagPlaceholder(ph, mapper) {
          var _this246 = this;

          var startName = mapper.toPublicName(ph.startName);
          var closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;
          var children = ph.children.map(function (n) {
            return n.visit(_this246, mapper);
          });
          return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan);
        }
      }, {
        key: "visitPlaceholder",
        value: function visitPlaceholder(ph, mapper) {
          return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);
        }
      }, {
        key: "visitIcuPlaceholder",
        value: function visitIcuPlaceholder(ph, mapper) {
          return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);
        }
      }]);

      return MapPlaceholderNames;
    }(CloneVisitor);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var GeneratedFile =
    /*#__PURE__*/
    function () {
      function GeneratedFile(srcFileUrl, genFileUrl, sourceOrStmts) {
        _classCallCheck(this, GeneratedFile);

        this.srcFileUrl = srcFileUrl;
        this.genFileUrl = genFileUrl;

        if (typeof sourceOrStmts === 'string') {
          this.source = sourceOrStmts;
          this.stmts = null;
        } else {
          this.source = null;
          this.stmts = sourceOrStmts;
        }
      }

      _createClass(GeneratedFile, [{
        key: "isEquivalent",
        value: function isEquivalent(other) {
          if (this.genFileUrl !== other.genFileUrl) {
            return false;
          }

          if (this.source) {
            return this.source === other.source;
          }

          if (other.stmts == null) {
            return false;
          } // Note: the constructor guarantees that if this.source is not filled,
          // then this.stmts is.


          return areAllEquivalent(this.stmts, other.stmts);
        }
      }]);

      return GeneratedFile;
    }();

    function toTypeScript(file) {
      var preamble = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      if (!file.stmts) {
        throw new Error("Illegal state: No stmts present on GeneratedFile ".concat(file.genFileUrl));
      }

      return new TypeScriptEmitter().emitStatements(file.genFileUrl, file.stmts, preamble);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function _listLazyRoutes(moduleMeta, reflector) {
      var allLazyRoutes = [];
      var _iteratorNormalCompletion18 = true;
      var _didIteratorError18 = false;
      var _iteratorError18 = undefined;

      try {
        for (var _iterator18 = moduleMeta.transitiveModule.providers[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
          var _step18$value = _step18.value,
              provider = _step18$value.provider,
              _module = _step18$value.module;

          if (tokenReference(provider.token) === reflector.ROUTES) {
            var loadChildren = _collectLoadChildren(provider.useValue);

            var _iteratorNormalCompletion19 = true;
            var _didIteratorError19 = false;
            var _iteratorError19 = undefined;

            try {
              for (var _iterator19 = loadChildren[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                var route = _step19.value;
                allLazyRoutes.push(parseLazyRoute(route, reflector, _module.reference));
              }
            } catch (err) {
              _didIteratorError19 = true;
              _iteratorError19 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
                  _iterator19.return();
                }
              } finally {
                if (_didIteratorError19) {
                  throw _iteratorError19;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
            _iterator18.return();
          }
        } finally {
          if (_didIteratorError18) {
            throw _iteratorError18;
          }
        }
      }

      return allLazyRoutes;
    }

    function _collectLoadChildren(routes) {
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (typeof routes === 'string') {
        target.push(routes);
      } else if (Array.isArray(routes)) {
        var _iteratorNormalCompletion20 = true;
        var _didIteratorError20 = false;
        var _iteratorError20 = undefined;

        try {
          for (var _iterator20 = routes[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
            var route = _step20.value;

            _collectLoadChildren(route, target);
          }
        } catch (err) {
          _didIteratorError20 = true;
          _iteratorError20 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion20 && _iterator20.return != null) {
              _iterator20.return();
            }
          } finally {
            if (_didIteratorError20) {
              throw _iteratorError20;
            }
          }
        }
      } else if (routes.loadChildren) {
        _collectLoadChildren(routes.loadChildren, target);
      } else if (routes.children) {
        _collectLoadChildren(routes.children, target);
      }

      return target;
    }

    function parseLazyRoute(route, reflector, module) {
      var _route$split = route.split('#'),
          _route$split2 = _slicedToArray(_route$split, 2),
          routePath = _route$split2[0],
          routeName = _route$split2[1];

      var referencedModule = reflector.resolveExternalReference({
        moduleName: routePath,
        name: routeName
      }, module ? module.filePath : undefined);
      return {
        route: route,
        module: module || referencedModule,
        referencedModule: referencedModule
      };
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var TS = /^(?!.*\.d\.ts$).*\.ts$/;

    var ResolvedStaticSymbol = function ResolvedStaticSymbol(symbol, metadata) {
      _classCallCheck(this, ResolvedStaticSymbol);

      this.symbol = symbol;
      this.metadata = metadata;
    };

    var SUPPORTED_SCHEMA_VERSION = 4;
    /**
     * This class is responsible for loading metadata per symbol,
     * and normalizing references between symbols.
     *
     * Internally, it only uses symbols without members,
     * and deduces the values for symbols with members based
     * on these symbols.
     */

    var StaticSymbolResolver =
    /*#__PURE__*/
    function () {
      function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {
        _classCallCheck(this, StaticSymbolResolver);

        this.host = host;
        this.staticSymbolCache = staticSymbolCache;
        this.summaryResolver = summaryResolver;
        this.errorRecorder = errorRecorder;
        this.metadataCache = new Map(); // Note: this will only contain StaticSymbols without members!

        this.resolvedSymbols = new Map(); // Note: this will only contain StaticSymbols without members!

        this.importAs = new Map();
        this.symbolResourcePaths = new Map();
        this.symbolFromFile = new Map();
        this.knownFileNameToModuleNames = new Map();
      }

      _createClass(StaticSymbolResolver, [{
        key: "resolveSymbol",
        value: function resolveSymbol(staticSymbol) {
          if (staticSymbol.members.length > 0) {
            return this._resolveSymbolMembers(staticSymbol);
          } // Note: always ask for a summary first,
          // as we might have read shallow metadata via a .d.ts file
          // for the symbol.


          var resultFromSummary = this._resolveSymbolFromSummary(staticSymbol);

          if (resultFromSummary) {
            return resultFromSummary;
          }

          var resultFromCache = this.resolvedSymbols.get(staticSymbol);

          if (resultFromCache) {
            return resultFromCache;
          } // Note: Some users use libraries that were not compiled with ngc, i.e. they don't
          // have summaries, only .d.ts files. So we always need to check both, the summary
          // and metadata.


          this._createSymbolsOf(staticSymbol.filePath);

          return this.resolvedSymbols.get(staticSymbol);
        }
        /**
         * getImportAs produces a symbol that can be used to import the given symbol.
         * The import might be different than the symbol if the symbol is exported from
         * a library with a summary; in which case we want to import the symbol from the
         * ngfactory re-export instead of directly to avoid introducing a direct dependency
         * on an otherwise indirect dependency.
         *
         * @param staticSymbol the symbol for which to generate a import symbol
         */

      }, {
        key: "getImportAs",
        value: function getImportAs(staticSymbol) {
          var useSummaries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          if (staticSymbol.members.length) {
            var baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);
            var baseImportAs = this.getImportAs(baseSymbol, useSummaries);
            return baseImportAs ? this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) : null;
          }

          var summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);

          if (summarizedFileName !== staticSymbol.filePath) {
            var summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);

            var _baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);

            var _baseImportAs = this.getImportAs(_baseSymbol, useSummaries);

            return _baseImportAs ? this.getStaticSymbol(summaryForJitFileName(_baseImportAs.filePath), summaryForJitName(_baseImportAs.name), _baseSymbol.members) : null;
          }

          var result = useSummaries && this.summaryResolver.getImportAs(staticSymbol) || null;

          if (!result) {
            result = this.importAs.get(staticSymbol);
          }

          return result;
        }
        /**
         * getResourcePath produces the path to the original location of the symbol and should
         * be used to determine the relative location of resource references recorded in
         * symbol metadata.
         */

      }, {
        key: "getResourcePath",
        value: function getResourcePath(staticSymbol) {
          return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;
        }
        /**
         * getTypeArity returns the number of generic type parameters the given symbol
         * has. If the symbol is not a type the result is null.
         */

      }, {
        key: "getTypeArity",
        value: function getTypeArity(staticSymbol) {
          // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would
          // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.
          // All references to generated classes must include the correct arity whenever
          // generating code.
          if (isGeneratedFile(staticSymbol.filePath)) {
            return null;
          }

          var resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));

          while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {
            resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));
          }

          return resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity || null;
        }
      }, {
        key: "getKnownModuleName",
        value: function getKnownModuleName(filePath) {
          return this.knownFileNameToModuleNames.get(filePath) || null;
        }
      }, {
        key: "recordImportAs",
        value: function recordImportAs(sourceSymbol, targetSymbol) {
          sourceSymbol.assertNoMembers();
          targetSymbol.assertNoMembers();
          this.importAs.set(sourceSymbol, targetSymbol);
        }
      }, {
        key: "recordModuleNameForFileName",
        value: function recordModuleNameForFileName(fileName, moduleName) {
          this.knownFileNameToModuleNames.set(fileName, moduleName);
        }
        /**
         * Invalidate all information derived from the given file and return the
         * static symbols contained in the file.
         *
         * @param fileName the file to invalidate
         */

      }, {
        key: "invalidateFile",
        value: function invalidateFile(fileName) {
          this.metadataCache.delete(fileName);
          var symbols = this.symbolFromFile.get(fileName);

          if (!symbols) {
            return [];
          }

          this.symbolFromFile.delete(fileName);
          var _iteratorNormalCompletion21 = true;
          var _didIteratorError21 = false;
          var _iteratorError21 = undefined;

          try {
            for (var _iterator21 = symbols[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
              var symbol = _step21.value;
              this.resolvedSymbols.delete(symbol);
              this.importAs.delete(symbol);
              this.symbolResourcePaths.delete(symbol);
            }
          } catch (err) {
            _didIteratorError21 = true;
            _iteratorError21 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion21 && _iterator21.return != null) {
                _iterator21.return();
              }
            } finally {
              if (_didIteratorError21) {
                throw _iteratorError21;
              }
            }
          }

          return symbols;
        }
        /** @internal */

      }, {
        key: "ignoreErrorsFor",
        value: function ignoreErrorsFor(cb) {
          var recorder = this.errorRecorder;

          this.errorRecorder = function () {};

          try {
            return cb();
          } finally {
            this.errorRecorder = recorder;
          }
        }
      }, {
        key: "_resolveSymbolMembers",
        value: function _resolveSymbolMembers(staticSymbol) {
          var members = staticSymbol.members;
          var baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));

          if (!baseResolvedSymbol) {
            return null;
          }

          var baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);

          if (baseMetadata instanceof StaticSymbol) {
            return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));
          } else if (baseMetadata && baseMetadata.__symbolic === 'class') {
            if (baseMetadata.statics && members.length === 1) {
              return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);
            }
          } else {
            var value = baseMetadata;

            for (var i = 0; i < members.length && value; i++) {
              value = value[members[i]];
            }

            return new ResolvedStaticSymbol(staticSymbol, value);
          }

          return null;
        }
      }, {
        key: "_resolveSymbolFromSummary",
        value: function _resolveSymbolFromSummary(staticSymbol) {
          var summary = this.summaryResolver.resolveSummary(staticSymbol);
          return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;
        }
        /**
         * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
         * All types passed to the StaticResolver should be pseudo-types returned by this method.
         *
         * @param declarationFile the absolute path of the file where the symbol is declared
         * @param name the name of the type.
         * @param members a symbol for a static member of the named type
         */

      }, {
        key: "getStaticSymbol",
        value: function getStaticSymbol(declarationFile, name, members) {
          return this.staticSymbolCache.get(declarationFile, name, members);
        }
        /**
         * hasDecorators checks a file's metadata for the presence of decorators without evaluating the
         * metadata.
         *
         * @param filePath the absolute path to examine for decorators.
         * @returns true if any class in the file has a decorator.
         */

      }, {
        key: "hasDecorators",
        value: function hasDecorators(filePath) {
          var metadata = this.getModuleMetadata(filePath);

          if (metadata['metadata']) {
            return Object.keys(metadata['metadata']).some(function (metadataKey) {
              var entry = metadata['metadata'][metadataKey];
              return entry && entry.__symbolic === 'class' && entry.decorators;
            });
          }

          return false;
        }
      }, {
        key: "getSymbolsOf",
        value: function getSymbolsOf(filePath) {
          var summarySymbols = this.summaryResolver.getSymbolsOf(filePath);

          if (summarySymbols) {
            return summarySymbols;
          } // Note: Some users use libraries that were not compiled with ngc, i.e. they don't
          // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.


          this._createSymbolsOf(filePath);

          return this.symbolFromFile.get(filePath) || [];
        }
      }, {
        key: "_createSymbolsOf",
        value: function _createSymbolsOf(filePath) {
          var _this247 = this;

          if (this.symbolFromFile.has(filePath)) {
            return;
          }

          var resolvedSymbols = [];
          var metadata = this.getModuleMetadata(filePath);

          if (metadata['importAs']) {
            // Index bundle indices should use the importAs module name defined
            // in the bundle.
            this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);
          } // handle the symbols in one of the re-export location


          if (metadata['exports']) {
            var _iteratorNormalCompletion22 = true;
            var _didIteratorError22 = false;
            var _iteratorError22 = undefined;

            try {
              var _loop3 = function _loop3() {
                var moduleExport = _step22.value;

                // handle the symbols in the list of explicitly re-exported symbols.
                if (moduleExport.export) {
                  moduleExport.export.forEach(function (exportSymbol) {
                    var symbolName;

                    if (typeof exportSymbol === 'string') {
                      symbolName = exportSymbol;
                    } else {
                      symbolName = exportSymbol.as;
                    }

                    symbolName = unescapeIdentifier(symbolName);
                    var symName = symbolName;

                    if (typeof exportSymbol !== 'string') {
                      symName = unescapeIdentifier(exportSymbol.name);
                    }

                    var resolvedModule = _this247.resolveModule(moduleExport.from, filePath);

                    if (resolvedModule) {
                      var targetSymbol = _this247.getStaticSymbol(resolvedModule, symName);

                      var sourceSymbol = _this247.getStaticSymbol(filePath, symbolName);

                      resolvedSymbols.push(_this247.createExport(sourceSymbol, targetSymbol));
                    }
                  });
                } else {
                  // handle the symbols via export * directives.
                  var resolvedModule = _this247.resolveModule(moduleExport.from, filePath);

                  if (resolvedModule) {
                    var nestedExports = _this247.getSymbolsOf(resolvedModule);

                    nestedExports.forEach(function (targetSymbol) {
                      var sourceSymbol = _this247.getStaticSymbol(filePath, targetSymbol.name);

                      resolvedSymbols.push(_this247.createExport(sourceSymbol, targetSymbol));
                    });
                  }
                }
              };

              for (var _iterator22 = metadata['exports'][Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                _loop3();
              }
            } catch (err) {
              _didIteratorError22 = true;
              _iteratorError22 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
                  _iterator22.return();
                }
              } finally {
                if (_didIteratorError22) {
                  throw _iteratorError22;
                }
              }
            }
          } // handle the actual metadata. Has to be after the exports
          // as there might be collisions in the names, and we want the symbols
          // of the current module to win ofter reexports.


          if (metadata['metadata']) {
            // handle direct declarations of the symbol
            var topLevelSymbolNames = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));
            var origins = metadata['origins'] || {};
            Object.keys(metadata['metadata']).forEach(function (metadataKey) {
              var symbolMeta = metadata['metadata'][metadataKey];
              var name = unescapeIdentifier(metadataKey);

              var symbol = _this247.getStaticSymbol(filePath, name);

              var origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];

              if (origin) {
                // If the symbol is from a bundled index, use the declaration location of the
                // symbol so relative references (such as './my.html') will be calculated
                // correctly.
                var originFilePath = _this247.resolveModule(origin, filePath);

                if (!originFilePath) {
                  _this247.reportError(new Error("Couldn't resolve original symbol for ".concat(origin, " from ").concat(_this247.host.getOutputName(filePath))));
                } else {
                  _this247.symbolResourcePaths.set(symbol, originFilePath);
                }
              }

              resolvedSymbols.push(_this247.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));
            });
          }

          var uniqueSymbols = new Set();

          for (var _i9 = 0, _resolvedSymbols = resolvedSymbols; _i9 < _resolvedSymbols.length; _i9++) {
            var resolvedSymbol = _resolvedSymbols[_i9];
            this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol);
            uniqueSymbols.add(resolvedSymbol.symbol);
          }

          this.symbolFromFile.set(filePath, Array.from(uniqueSymbols));
        }
      }, {
        key: "createResolvedSymbol",
        value: function createResolvedSymbol(sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {
          var _this248 = this;

          // For classes that don't have Angular summaries / metadata,
          // we only keep their arity, but nothing else
          // (e.g. their constructor parameters).
          // We do this to prevent introducing deep imports
          // as we didn't generate .ngfactory.ts files with proper reexports.
          var isTsFile = TS.test(sourceSymbol.filePath);

          if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata && metadata['__symbolic'] === 'class') {
            var _transformedMeta = {
              __symbolic: 'class',
              arity: metadata.arity
            };
            return new ResolvedStaticSymbol(sourceSymbol, _transformedMeta);
          }

          var _originalFileMemo;

          var getOriginalName = function getOriginalName() {
            if (!_originalFileMemo) {
              // Guess what the original file name is from the reference. If it has a `.d.ts` extension
              // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have
              // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`
              // location as it is not important to finding the file.
              _originalFileMemo = _this248.host.getOutputName(topLevelPath.replace(/((\.ts)|(\.d\.ts)|)$/, '.ts').replace(/^.*node_modules[/\\]/, ''));
            }

            return _originalFileMemo;
          };

          var self = this;

          var ReferenceTransformer =
          /*#__PURE__*/
          function (_ValueTransformer2) {
            _inherits(ReferenceTransformer, _ValueTransformer2);

            function ReferenceTransformer() {
              _classCallCheck(this, ReferenceTransformer);

              return _possibleConstructorReturn(this, _getPrototypeOf(ReferenceTransformer).apply(this, arguments));
            }

            _createClass(ReferenceTransformer, [{
              key: "visitStringMap",
              value: function visitStringMap(map, functionParams) {
                var symbolic = map['__symbolic'];

                if (symbolic === 'function') {
                  var oldLen = functionParams.length;
                  functionParams.push.apply(functionParams, _toConsumableArray(map['parameters'] || []));

                  var result = _get(_getPrototypeOf(ReferenceTransformer.prototype), "visitStringMap", this).call(this, map, functionParams);

                  functionParams.length = oldLen;
                  return result;
                } else if (symbolic === 'reference') {
                  var _module2 = map['module'];
                  var name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];

                  if (!name) {
                    return null;
                  }

                  var filePath;

                  if (_module2) {
                    filePath = self.resolveModule(_module2, sourceSymbol.filePath);

                    if (!filePath) {
                      return {
                        __symbolic: 'error',
                        message: "Could not resolve ".concat(_module2, " relative to ").concat(self.host.getMetadataFor(sourceSymbol.filePath), "."),
                        line: map['line'],
                        character: map['character'],
                        fileName: getOriginalName()
                      };
                    }

                    return {
                      __symbolic: 'resolved',
                      symbol: self.getStaticSymbol(filePath, name),
                      line: map['line'],
                      character: map['character'],
                      fileName: getOriginalName()
                    };
                  } else if (functionParams.indexOf(name) >= 0) {
                    // reference to a function parameter
                    return {
                      __symbolic: 'reference',
                      name: name
                    };
                  } else {
                    if (topLevelSymbolNames.has(name)) {
                      return self.getStaticSymbol(topLevelPath, name);
                    } // ambient value


                    null;
                  }
                } else if (symbolic === 'error') {
                  return Object.assign(Object.assign({}, map), {
                    fileName: getOriginalName()
                  });
                } else {
                  return _get(_getPrototypeOf(ReferenceTransformer.prototype), "visitStringMap", this).call(this, map, functionParams);
                }
              }
            }]);

            return ReferenceTransformer;
          }(ValueTransformer);

          var transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);
          var unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);

          if (unwrappedTransformedMeta instanceof StaticSymbol) {
            return this.createExport(sourceSymbol, unwrappedTransformedMeta);
          }

          return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);
        }
      }, {
        key: "createExport",
        value: function createExport(sourceSymbol, targetSymbol) {
          sourceSymbol.assertNoMembers();
          targetSymbol.assertNoMembers();

          if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {
            // This case is for an ng library importing symbols from a plain ts library
            // transitively.
            // Note: We rely on the fact that we discover symbols in the direction
            // from source files to library files
            this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);
          }

          return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);
        }
      }, {
        key: "reportError",
        value: function reportError(error, context, path) {
          if (this.errorRecorder) {
            this.errorRecorder(error, context && context.filePath || path);
          } else {
            throw error;
          }
        }
        /**
         * @param module an absolute path to a module file.
         */

      }, {
        key: "getModuleMetadata",
        value: function getModuleMetadata(module) {
          var moduleMetadata = this.metadataCache.get(module);

          if (!moduleMetadata) {
            var moduleMetadatas = this.host.getMetadataFor(module);

            if (moduleMetadatas) {
              var maxVersion = -1;
              moduleMetadatas.forEach(function (md) {
                if (md && md['version'] > maxVersion) {
                  maxVersion = md['version'];
                  moduleMetadata = md;
                }
              });
            }

            if (!moduleMetadata) {
              moduleMetadata = {
                __symbolic: 'module',
                version: SUPPORTED_SCHEMA_VERSION,
                module: module,
                metadata: {}
              };
            }

            if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {
              var errorMessage = moduleMetadata['version'] == 2 ? "Unsupported metadata version ".concat(moduleMetadata['version'], " for module ").concat(module, ". This module should be compiled with a newer version of ngc") : "Metadata version mismatch for module ".concat(this.host.getOutputName(module), ", found version ").concat(moduleMetadata['version'], ", expected ").concat(SUPPORTED_SCHEMA_VERSION);
              this.reportError(new Error(errorMessage));
            }

            this.metadataCache.set(module, moduleMetadata);
          }

          return moduleMetadata;
        }
      }, {
        key: "getSymbolByModule",
        value: function getSymbolByModule(module, symbolName, containingFile) {
          var filePath = this.resolveModule(module, containingFile);

          if (!filePath) {
            this.reportError(new Error("Could not resolve module ".concat(module).concat(containingFile ? ' relative to ' + this.host.getOutputName(containingFile) : '')));
            return this.getStaticSymbol("ERROR:".concat(module), symbolName);
          }

          return this.getStaticSymbol(filePath, symbolName);
        }
      }, {
        key: "resolveModule",
        value: function resolveModule(module, containingFile) {
          try {
            return this.host.moduleNameToFileName(module, containingFile);
          } catch (e) {
            console.error("Could not resolve module '".concat(module, "' relative to file ").concat(containingFile));
            this.reportError(e, undefined, containingFile);
          }

          return null;
        }
      }]);

      return StaticSymbolResolver;
    }(); // Remove extra underscore from escaped identifier.
    // See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts


    function unescapeIdentifier(identifier) {
      return identifier.startsWith('___') ? identifier.substr(1) : identifier;
    }

    function unwrapResolvedMetadata(metadata) {
      if (metadata && metadata.__symbolic === 'resolved') {
        return metadata.symbol;
      }

      return metadata;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function serializeSummaries(srcFileName, forJitCtx, summaryResolver, symbolResolver, symbols, types) {
      var createExternalSymbolReexports = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      var toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver, srcFileName); // for symbols, we use everything except for the class metadata itself
      // (we keep the statics though), as the class metadata is contained in the
      // CompileTypeSummary.

      symbols.forEach(function (resolvedSymbol) {
        return toJsonSerializer.addSummary({
          symbol: resolvedSymbol.symbol,
          metadata: resolvedSymbol.metadata
        });
      }); // Add type summaries.

      types.forEach(function (_ref41) {
        var summary = _ref41.summary,
            metadata = _ref41.metadata;
        toJsonSerializer.addSummary({
          symbol: summary.type.reference,
          metadata: undefined,
          type: summary
        });
      });

      var _toJsonSerializer$ser = toJsonSerializer.serialize(createExternalSymbolReexports),
          json = _toJsonSerializer$ser.json,
          exportAs = _toJsonSerializer$ser.exportAs;

      if (forJitCtx) {
        var forJitSerializer = new ForJitSerializer(forJitCtx, symbolResolver, summaryResolver);
        types.forEach(function (_ref42) {
          var summary = _ref42.summary,
              metadata = _ref42.metadata;
          forJitSerializer.addSourceType(summary, metadata);
        });
        toJsonSerializer.unprocessedSymbolSummariesBySymbol.forEach(function (summary) {
          if (summaryResolver.isLibraryFile(summary.symbol.filePath) && summary.type) {
            forJitSerializer.addLibType(summary.type);
          }
        });
        forJitSerializer.serialize(exportAs);
      }

      return {
        json: json,
        exportAs: exportAs
      };
    }

    function deserializeSummaries(symbolCache, summaryResolver, libraryFileName, json) {
      var deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);
      return deserializer.deserialize(libraryFileName, json);
    }

    function createForJitStub(outputCtx, reference) {
      return createSummaryForJitFunction(outputCtx, reference, NULL_EXPR);
    }

    function createSummaryForJitFunction(outputCtx, reference, value) {
      var fnName = summaryForJitName(reference.name);
      outputCtx.statements.push(fn([], [new ReturnStatement(value)], new ArrayType(DYNAMIC_TYPE)).toDeclStmt(fnName, [StmtModifier.Final, StmtModifier.Exported]));
    }

    var ToJsonSerializer =
    /*#__PURE__*/
    function (_ValueTransformer3) {
      _inherits(ToJsonSerializer, _ValueTransformer3);

      function ToJsonSerializer(symbolResolver, summaryResolver, srcFileName) {
        var _this249;

        _classCallCheck(this, ToJsonSerializer);

        _this249 = _possibleConstructorReturn(this, _getPrototypeOf(ToJsonSerializer).call(this));
        _this249.symbolResolver = symbolResolver;
        _this249.summaryResolver = summaryResolver;
        _this249.srcFileName = srcFileName; // Note: This only contains symbols without members.

        _this249.symbols = [];
        _this249.indexBySymbol = new Map();
        _this249.reexportedBy = new Map(); // This now contains a `__symbol: number` in the place of
        // StaticSymbols, but otherwise has the same shape as the original objects.

        _this249.processedSummaryBySymbol = new Map();
        _this249.processedSummaries = [];
        _this249.unprocessedSymbolSummariesBySymbol = new Map();
        _this249.moduleName = symbolResolver.getKnownModuleName(srcFileName);
        return _this249;
      }

      _createClass(ToJsonSerializer, [{
        key: "addSummary",
        value: function addSummary(summary) {
          var _this250 = this;

          var unprocessedSummary = this.unprocessedSymbolSummariesBySymbol.get(summary.symbol);
          var processedSummary = this.processedSummaryBySymbol.get(summary.symbol);

          if (!unprocessedSummary) {
            unprocessedSummary = {
              symbol: summary.symbol,
              metadata: undefined
            };
            this.unprocessedSymbolSummariesBySymbol.set(summary.symbol, unprocessedSummary);
            processedSummary = {
              symbol: this.processValue(summary.symbol, 0
              /* None */
              )
            };
            this.processedSummaries.push(processedSummary);
            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);
          }

          if (!unprocessedSummary.metadata && summary.metadata) {
            var metadata = summary.metadata || {};

            if (metadata.__symbolic === 'class') {
              // For classes, we keep everything except their class decorators.
              // We need to keep e.g. the ctor args, method names, method decorators
              // so that the class can be extended in another compilation unit.
              // We don't keep the class decorators as
              // 1) they refer to data
              //   that should not cause a rebuild of downstream compilation units
              //   (e.g. inline templates of @Component, or @NgModule.declarations)
              // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.
              var clone = {};
              Object.keys(metadata).forEach(function (propName) {
                if (propName !== 'decorators') {
                  clone[propName] = metadata[propName];
                }
              });
              metadata = clone;
            } else if (isCall(metadata)) {
              if (!isFunctionCall(metadata) && !isMethodCallOnVariable(metadata)) {
                // Don't store complex calls as we won't be able to simplify them anyways later on.
                metadata = {
                  __symbolic: 'error',
                  message: 'Complex function calls are not supported.'
                };
              }
            } // Note: We need to keep storing ctor calls for e.g.
            // `export const x = new InjectionToken(...)`


            unprocessedSummary.metadata = metadata;
            processedSummary.metadata = this.processValue(metadata, 1
            /* ResolveValue */
            );

            if (metadata instanceof StaticSymbol && this.summaryResolver.isLibraryFile(metadata.filePath)) {
              var declarationSymbol = this.symbols[this.indexBySymbol.get(metadata)];

              if (!isLoweredSymbol(declarationSymbol.name)) {
                // Note: symbols that were introduced during codegen in the user file can have a reexport
                // if a user used `export *`. However, we can't rely on this as tsickle will change
                // `export *` into named exports, using only the information from the typechecker.
                // As we introduce the new symbols after typecheck, Tsickle does not know about them,
                // and omits them when expanding `export *`.
                // So we have to keep reexporting these symbols manually via .ngfactory files.
                this.reexportedBy.set(declarationSymbol, summary.symbol);
              }
            }
          }

          if (!unprocessedSummary.type && summary.type) {
            unprocessedSummary.type = summary.type; // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,
            // as the type summaries already contain the transitive data that they require
            // (in a minimal way).

            processedSummary.type = this.processValue(summary.type, 0
            /* None */
            ); // except for reexported directives / pipes, so we need to store
            // their summaries explicitly.

            if (summary.type.summaryKind === CompileSummaryKind.NgModule) {
              var ngModuleSummary = summary.type;
              ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {
                var symbol = id.reference;

                if (_this250.summaryResolver.isLibraryFile(symbol.filePath) && !_this250.unprocessedSymbolSummariesBySymbol.has(symbol)) {
                  var _summary = _this250.summaryResolver.resolveSummary(symbol);

                  if (_summary) {
                    _this250.addSummary(_summary);
                  }
                }
              });
            }
          }
        }
        /**
         * @param createExternalSymbolReexports Whether external static symbols should be re-exported.
         * This can be enabled if external symbols should be re-exported by the current module in
         * order to avoid dynamically generated module dependencies which can break strict dependency
         * enforcements (as in Google3). Read more here: https://github.com/angular/angular/issues/25644
         */

      }, {
        key: "serialize",
        value: function serialize(createExternalSymbolReexports) {
          var _this251 = this;

          var exportAs = [];
          var json = JSON.stringify({
            moduleName: this.moduleName,
            summaries: this.processedSummaries,
            symbols: this.symbols.map(function (symbol, index) {
              symbol.assertNoMembers();
              var importAs = undefined;

              if (_this251.summaryResolver.isLibraryFile(symbol.filePath)) {
                var reexportSymbol = _this251.reexportedBy.get(symbol);

                if (reexportSymbol) {
                  // In case the given external static symbol is already manually exported by the
                  // user, we just proxy the external static symbol reference to the manual export.
                  // This ensures that the AOT compiler imports the external symbol through the
                  // user export and does not introduce another dependency which is not needed.
                  importAs = _this251.indexBySymbol.get(reexportSymbol);
                } else if (createExternalSymbolReexports) {
                  // In this case, the given external static symbol is *not* manually exported by
                  // the user, and we manually create a re-export in the factory file so that we
                  // don't introduce another module dependency. This is useful when running within
                  // Bazel so that the AOT compiler does not introduce any module dependencies
                  // which can break the strict dependency enforcement. (e.g. as in Google3)
                  // Read more about this here: https://github.com/angular/angular/issues/25644
                  var summary = _this251.unprocessedSymbolSummariesBySymbol.get(symbol);

                  if (!summary || !summary.metadata || summary.metadata.__symbolic !== 'interface') {
                    importAs = "".concat(symbol.name, "_").concat(index);
                    exportAs.push({
                      symbol: symbol,
                      exportAs: importAs
                    });
                  }
                }
              }

              return {
                __symbol: index,
                name: symbol.name,
                filePath: _this251.summaryResolver.toSummaryFileName(symbol.filePath, _this251.srcFileName),
                importAs: importAs
              };
            })
          });
          return {
            json: json,
            exportAs: exportAs
          };
        }
      }, {
        key: "processValue",
        value: function processValue(value, flags) {
          return visitValue(value, this, flags);
        }
      }, {
        key: "visitOther",
        value: function visitOther(value, context) {
          if (value instanceof StaticSymbol) {
            var baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);
            var index = this.visitStaticSymbol(baseSymbol, context);
            return {
              __symbol: index,
              members: value.members
            };
          }
        }
        /**
         * Strip line and character numbers from ngsummaries.
         * Emitting them causes white spaces changes to retrigger upstream
         * recompilations in bazel.
         * TODO: find out a way to have line and character numbers in errors without
         * excessive recompilation in bazel.
         */

      }, {
        key: "visitStringMap",
        value: function visitStringMap(map, context) {
          if (map['__symbolic'] === 'resolved') {
            return visitValue(map['symbol'], this, context);
          }

          if (map['__symbolic'] === 'error') {
            delete map['line'];
            delete map['character'];
          }

          return _get(_getPrototypeOf(ToJsonSerializer.prototype), "visitStringMap", this).call(this, map, context);
        }
        /**
         * Returns null if the options.resolveValue is true, and the summary for the symbol
         * resolved to a type or could not be resolved.
         */

      }, {
        key: "visitStaticSymbol",
        value: function visitStaticSymbol(baseSymbol, flags) {
          var index = this.indexBySymbol.get(baseSymbol);
          var summary = null;

          if (flags & 1
          /* ResolveValue */
          && this.summaryResolver.isLibraryFile(baseSymbol.filePath)) {
            if (this.unprocessedSymbolSummariesBySymbol.has(baseSymbol)) {
              // the summary for this symbol was already added
              // -> nothing to do.
              return index;
            }

            summary = this.loadSummary(baseSymbol);

            if (summary && summary.metadata instanceof StaticSymbol) {
              // The summary is a reexport
              index = this.visitStaticSymbol(summary.metadata, flags); // reset the summary as it is just a reexport, so we don't want to store it.

              summary = null;
            }
          } else if (index != null) {
            // Note: == on purpose to compare with undefined!
            // No summary and the symbol is already added -> nothing to do.
            return index;
          } // Note: == on purpose to compare with undefined!


          if (index == null) {
            index = this.symbols.length;
            this.symbols.push(baseSymbol);
          }

          this.indexBySymbol.set(baseSymbol, index);

          if (summary) {
            this.addSummary(summary);
          }

          return index;
        }
      }, {
        key: "loadSummary",
        value: function loadSummary(symbol) {
          var summary = this.summaryResolver.resolveSummary(symbol);

          if (!summary) {
            // some symbols might originate from a plain typescript library
            // that just exported .d.ts and .metadata.json files, i.e. where no summary
            // files were created.
            var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);

            if (resolvedSymbol) {
              summary = {
                symbol: resolvedSymbol.symbol,
                metadata: resolvedSymbol.metadata
              };
            }
          }

          return summary;
        }
      }]);

      return ToJsonSerializer;
    }(ValueTransformer);

    var ForJitSerializer =
    /*#__PURE__*/
    function () {
      function ForJitSerializer(outputCtx, symbolResolver, summaryResolver) {
        _classCallCheck(this, ForJitSerializer);

        this.outputCtx = outputCtx;
        this.symbolResolver = symbolResolver;
        this.summaryResolver = summaryResolver;
        this.data = [];
      }

      _createClass(ForJitSerializer, [{
        key: "addSourceType",
        value: function addSourceType(summary, metadata) {
          this.data.push({
            summary: summary,
            metadata: metadata,
            isLibrary: false
          });
        }
      }, {
        key: "addLibType",
        value: function addLibType(summary) {
          this.data.push({
            summary: summary,
            metadata: null,
            isLibrary: true
          });
        }
      }, {
        key: "serialize",
        value: function serialize(exportAsArr) {
          var _this252 = this;

          var exportAsBySymbol = new Map();
          var _iteratorNormalCompletion23 = true;
          var _didIteratorError23 = false;
          var _iteratorError23 = undefined;

          try {
            for (var _iterator23 = exportAsArr[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
              var _step23$value = _step23.value,
                  symbol = _step23$value.symbol,
                  exportAs = _step23$value.exportAs;
              exportAsBySymbol.set(symbol, exportAs);
            }
          } catch (err) {
            _didIteratorError23 = true;
            _iteratorError23 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion23 && _iterator23.return != null) {
                _iterator23.return();
              }
            } finally {
              if (_didIteratorError23) {
                throw _iteratorError23;
              }
            }
          }

          var ngModuleSymbols = new Set();
          var _iteratorNormalCompletion24 = true;
          var _didIteratorError24 = false;
          var _iteratorError24 = undefined;

          try {
            for (var _iterator24 = this.data[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
              var _step24$value = _step24.value,
                  summary = _step24$value.summary,
                  metadata = _step24$value.metadata,
                  isLibrary = _step24$value.isLibrary;

              if (summary.summaryKind === CompileSummaryKind.NgModule) {
                // collect the symbols that refer to NgModule classes.
                // Note: we can't just rely on `summary.type.summaryKind` to determine this as
                // we don't add the summaries of all referenced symbols when we serialize type summaries.
                // See serializeSummaries for details.
                ngModuleSymbols.add(summary.type.reference);
                var modSummary = summary;
                var _iteratorNormalCompletion25 = true;
                var _didIteratorError25 = false;
                var _iteratorError25 = undefined;

                try {
                  for (var _iterator25 = modSummary.modules[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                    var mod = _step25.value;
                    ngModuleSymbols.add(mod.reference);
                  }
                } catch (err) {
                  _didIteratorError25 = true;
                  _iteratorError25 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion25 && _iterator25.return != null) {
                      _iterator25.return();
                    }
                  } finally {
                    if (_didIteratorError25) {
                      throw _iteratorError25;
                    }
                  }
                }
              }

              if (!isLibrary) {
                var fnName = summaryForJitName(summary.type.reference.name);
                createSummaryForJitFunction(this.outputCtx, summary.type.reference, this.serializeSummaryWithDeps(summary, metadata));
              }
            }
          } catch (err) {
            _didIteratorError24 = true;
            _iteratorError24 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion24 && _iterator24.return != null) {
                _iterator24.return();
              }
            } finally {
              if (_didIteratorError24) {
                throw _iteratorError24;
              }
            }
          }

          ngModuleSymbols.forEach(function (ngModuleSymbol) {
            if (_this252.summaryResolver.isLibraryFile(ngModuleSymbol.filePath)) {
              var exportAs = exportAsBySymbol.get(ngModuleSymbol) || ngModuleSymbol.name;
              var jitExportAsName = summaryForJitName(exportAs);

              _this252.outputCtx.statements.push(variable(jitExportAsName).set(_this252.serializeSummaryRef(ngModuleSymbol)).toDeclStmt(null, [StmtModifier.Exported]));
            }
          });
        }
      }, {
        key: "serializeSummaryWithDeps",
        value: function serializeSummaryWithDeps(summary, metadata) {
          var _this253 = this;

          var expressions = [this.serializeSummary(summary)];
          var providers = [];

          if (metadata instanceof CompileNgModuleMetadata) {
            expressions.push.apply(expressions, _toConsumableArray( // For directives / pipes, we only add the declared ones,
            // and rely on transitively importing NgModules to get the transitive
            // summaries.
            metadata.declaredDirectives.concat(metadata.declaredPipes).map(function (type) {
              return type.reference;
            }) // For modules,
            // we also add the summaries for modules
            // from libraries.
            // This is ok as we produce reexports for all transitive modules.
            .concat(metadata.transitiveModule.modules.map(function (type) {
              return type.reference;
            }).filter(function (ref) {
              return ref !== metadata.type.reference;
            })).map(function (ref) {
              return _this253.serializeSummaryRef(ref);
            }))); // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,
            // and we already have transitive modules.

            providers = metadata.providers;
          } else if (summary.summaryKind === CompileSummaryKind.Directive) {
            var dirSummary = summary;
            providers = dirSummary.providers.concat(dirSummary.viewProviders);
          } // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for
          // declaredDirectives / declaredPipes), as we allow
          // providers without ctor arguments to skip the `@Injectable` decorator,
          // i.e. we didn't generate .ngsummary.ts files for these.


          expressions.push.apply(expressions, _toConsumableArray(providers.filter(function (provider) {
            return !!provider.useClass;
          }).map(function (provider) {
            return _this253.serializeSummary({
              summaryKind: CompileSummaryKind.Injectable,
              type: provider.useClass
            });
          })));
          return literalArr(expressions);
        }
      }, {
        key: "serializeSummaryRef",
        value: function serializeSummaryRef(typeSymbol) {
          var jitImportedSymbol = this.symbolResolver.getStaticSymbol(summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));
          return this.outputCtx.importExpr(jitImportedSymbol);
        }
      }, {
        key: "serializeSummary",
        value: function serializeSummary(data) {
          var outputCtx = this.outputCtx;

          var Transformer =
          /*#__PURE__*/
          function () {
            function Transformer() {
              _classCallCheck(this, Transformer);
            }

            _createClass(Transformer, [{
              key: "visitArray",
              value: function visitArray(arr, context) {
                var _this254 = this;

                return literalArr(arr.map(function (entry) {
                  return visitValue(entry, _this254, context);
                }));
              }
            }, {
              key: "visitStringMap",
              value: function visitStringMap(map, context) {
                var _this255 = this;

                return new LiteralMapExpr(Object.keys(map).map(function (key) {
                  return new LiteralMapEntry(key, visitValue(map[key], _this255, context), false);
                }));
              }
            }, {
              key: "visitPrimitive",
              value: function visitPrimitive(value, context) {
                return literal(value);
              }
            }, {
              key: "visitOther",
              value: function visitOther(value, context) {
                if (value instanceof StaticSymbol) {
                  return outputCtx.importExpr(value);
                } else {
                  throw new Error("Illegal State: Encountered value ".concat(value));
                }
              }
            }]);

            return Transformer;
          }();

          return visitValue(data, new Transformer(), null);
        }
      }]);

      return ForJitSerializer;
    }();

    var FromJsonDeserializer =
    /*#__PURE__*/
    function (_ValueTransformer4) {
      _inherits(FromJsonDeserializer, _ValueTransformer4);

      function FromJsonDeserializer(symbolCache, summaryResolver) {
        var _this256;

        _classCallCheck(this, FromJsonDeserializer);

        _this256 = _possibleConstructorReturn(this, _getPrototypeOf(FromJsonDeserializer).call(this));
        _this256.symbolCache = symbolCache;
        _this256.summaryResolver = summaryResolver;
        return _this256;
      }

      _createClass(FromJsonDeserializer, [{
        key: "deserialize",
        value: function deserialize(libraryFileName, json) {
          var _this257 = this;

          var data = JSON.parse(json);
          var allImportAs = [];
          this.symbols = data.symbols.map(function (serializedSymbol) {
            return _this257.symbolCache.get(_this257.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName), serializedSymbol.name);
          });
          data.symbols.forEach(function (serializedSymbol, index) {
            var symbol = _this257.symbols[index];
            var importAs = serializedSymbol.importAs;

            if (typeof importAs === 'number') {
              allImportAs.push({
                symbol: symbol,
                importAs: _this257.symbols[importAs]
              });
            } else if (typeof importAs === 'string') {
              allImportAs.push({
                symbol: symbol,
                importAs: _this257.symbolCache.get(ngfactoryFilePath(libraryFileName), importAs)
              });
            }
          });
          var summaries = visitValue(data.summaries, this, null);
          return {
            moduleName: data.moduleName,
            summaries: summaries,
            importAs: allImportAs
          };
        }
      }, {
        key: "visitStringMap",
        value: function visitStringMap(map, context) {
          if ('__symbol' in map) {
            var baseSymbol = this.symbols[map['__symbol']];
            var members = map['members'];
            return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) : baseSymbol;
          } else {
            return _get(_getPrototypeOf(FromJsonDeserializer.prototype), "visitStringMap", this).call(this, map, context);
          }
        }
      }]);

      return FromJsonDeserializer;
    }(ValueTransformer);

    function isCall(metadata) {
      return metadata && metadata.__symbolic === 'call';
    }

    function isFunctionCall(metadata) {
      return isCall(metadata) && unwrapResolvedMetadata(metadata.expression) instanceof StaticSymbol;
    }

    function isMethodCallOnVariable(metadata) {
      return isCall(metadata) && metadata.expression && metadata.expression.__symbolic === 'select' && unwrapResolvedMetadata(metadata.expression.expression) instanceof StaticSymbol;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var AotCompiler =
    /*#__PURE__*/
    function () {
      function AotCompiler(_config, _options, _host, reflector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _typeCheckCompiler, _ngModuleCompiler, _injectableCompiler, _outputEmitter, _summaryResolver, _symbolResolver) {
        _classCallCheck(this, AotCompiler);

        this._config = _config;
        this._options = _options;
        this._host = _host;
        this.reflector = reflector;
        this._metadataResolver = _metadataResolver;
        this._templateParser = _templateParser;
        this._styleCompiler = _styleCompiler;
        this._viewCompiler = _viewCompiler;
        this._typeCheckCompiler = _typeCheckCompiler;
        this._ngModuleCompiler = _ngModuleCompiler;
        this._injectableCompiler = _injectableCompiler;
        this._outputEmitter = _outputEmitter;
        this._summaryResolver = _summaryResolver;
        this._symbolResolver = _symbolResolver;
        this._templateAstCache = new Map();
        this._analyzedFiles = new Map();
        this._analyzedFilesForInjectables = new Map();
      }

      _createClass(AotCompiler, [{
        key: "clearCache",
        value: function clearCache() {
          this._metadataResolver.clearCache();
        }
      }, {
        key: "analyzeModulesSync",
        value: function analyzeModulesSync(rootFiles) {
          var _this258 = this;

          var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);
          analyzeResult.ngModules.forEach(function (ngModule) {
            return _this258._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true);
          });
          return analyzeResult;
        }
      }, {
        key: "analyzeModulesAsync",
        value: function analyzeModulesAsync(rootFiles) {
          var _this259 = this;

          var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);
          return Promise.all(analyzeResult.ngModules.map(function (ngModule) {
            return _this259._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false);
          })).then(function () {
            return analyzeResult;
          });
        }
      }, {
        key: "_analyzeFile",
        value: function _analyzeFile(fileName) {
          var analyzedFile = this._analyzedFiles.get(fileName);

          if (!analyzedFile) {
            analyzedFile = analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);

            this._analyzedFiles.set(fileName, analyzedFile);
          }

          return analyzedFile;
        }
      }, {
        key: "_analyzeFileForInjectables",
        value: function _analyzeFileForInjectables(fileName) {
          var analyzedFile = this._analyzedFilesForInjectables.get(fileName);

          if (!analyzedFile) {
            analyzedFile = analyzeFileForInjectables(this._host, this._symbolResolver, this._metadataResolver, fileName);

            this._analyzedFilesForInjectables.set(fileName, analyzedFile);
          }

          return analyzedFile;
        }
      }, {
        key: "findGeneratedFileNames",
        value: function findGeneratedFileNames(fileName) {
          var _this260 = this;

          var genFileNames = [];

          var file = this._analyzeFile(fileName); // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule
          // or a reference to a non source file.
          // Note: This is overestimating the required .ngfactory files as the real calculation is harder.
          // Only do this for StubEmitFlags.Basic, as adding a type check block
          // does not change this file (as we generate type check blocks based on NgModules).


          if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length || file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {
            genFileNames.push(ngfactoryFilePath(file.fileName, true));

            if (this._options.enableSummariesForJit) {
              genFileNames.push(summaryForJitFileName(file.fileName, true));
            }
          }

          var fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(file.fileName, true)[1]);
          file.directives.forEach(function (dirSymbol) {
            var compMeta = _this260._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol).metadata;

            if (!compMeta.isComponent) {
              return;
            } // Note: compMeta is a component and therefore template is non null.


            compMeta.template.styleUrls.forEach(function (styleUrl) {
              var normalizedUrl = _this260._host.resourceNameToFileName(styleUrl, file.fileName);

              if (!normalizedUrl) {
                throw syntaxError("Couldn't resolve resource ".concat(styleUrl, " relative to ").concat(file.fileName));
              }

              var needsShim = (compMeta.template.encapsulation || _this260._config.defaultEncapsulation) === ViewEncapsulation.Emulated;
              genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));

              if (_this260._options.allowEmptyCodegenFiles) {
                genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));
              }
            });
          });
          return genFileNames;
        }
      }, {
        key: "emitBasicStub",
        value: function emitBasicStub(genFileName, originalFileName) {
          var outputCtx = this._createOutputContext(genFileName);

          if (genFileName.endsWith('.ngfactory.ts')) {
            if (!originalFileName) {
              throw new Error("Assertion error: require the original file for .ngfactory.ts stubs. File: ".concat(genFileName));
            }

            var originalFile = this._analyzeFile(originalFileName);

            this._createNgFactoryStub(outputCtx, originalFile, 1
            /* Basic */
            );
          } else if (genFileName.endsWith('.ngsummary.ts')) {
            if (this._options.enableSummariesForJit) {
              if (!originalFileName) {
                throw new Error("Assertion error: require the original file for .ngsummary.ts stubs. File: ".concat(genFileName));
              }

              var _originalFile = this._analyzeFile(originalFileName);

              _createEmptyStub(outputCtx);

              _originalFile.ngModules.forEach(function (ngModule) {
                // create exports that user code can reference
                createForJitStub(outputCtx, ngModule.type.reference);
              });
            }
          } else if (genFileName.endsWith('.ngstyle.ts')) {
            _createEmptyStub(outputCtx);
          } // Note: for the stubs, we don't need a property srcFileUrl,
          // as later on in emitAllImpls we will create the proper GeneratedFiles with the
          // correct srcFileUrl.
          // This is good as e.g. for .ngstyle.ts files we can't derive
          // the url of components based on the genFileUrl.


          return this._codegenSourceModule('unknown', outputCtx);
        }
      }, {
        key: "emitTypeCheckStub",
        value: function emitTypeCheckStub(genFileName, originalFileName) {
          var originalFile = this._analyzeFile(originalFileName);

          var outputCtx = this._createOutputContext(genFileName);

          if (genFileName.endsWith('.ngfactory.ts')) {
            this._createNgFactoryStub(outputCtx, originalFile, 2
            /* TypeCheck */
            );
          }

          return outputCtx.statements.length > 0 ? this._codegenSourceModule(originalFile.fileName, outputCtx) : null;
        }
      }, {
        key: "loadFilesAsync",
        value: function loadFilesAsync(fileNames, tsFiles) {
          var _this261 = this;

          var files = fileNames.map(function (fileName) {
            return _this261._analyzeFile(fileName);
          });
          var loadingPromises = [];
          files.forEach(function (file) {
            return file.ngModules.forEach(function (ngModule) {
              return loadingPromises.push(_this261._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false));
            });
          });
          var analyzedInjectables = tsFiles.map(function (tsFile) {
            return _this261._analyzeFileForInjectables(tsFile);
          });
          return Promise.all(loadingPromises).then(function (_) {
            return {
              analyzedModules: mergeAndValidateNgFiles(files),
              analyzedInjectables: analyzedInjectables
            };
          });
        }
      }, {
        key: "loadFilesSync",
        value: function loadFilesSync(fileNames, tsFiles) {
          var _this262 = this;

          var files = fileNames.map(function (fileName) {
            return _this262._analyzeFile(fileName);
          });
          files.forEach(function (file) {
            return file.ngModules.forEach(function (ngModule) {
              return _this262._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true);
            });
          });
          var analyzedInjectables = tsFiles.map(function (tsFile) {
            return _this262._analyzeFileForInjectables(tsFile);
          });
          return {
            analyzedModules: mergeAndValidateNgFiles(files),
            analyzedInjectables: analyzedInjectables
          };
        }
      }, {
        key: "_createNgFactoryStub",
        value: function _createNgFactoryStub(outputCtx, file, emitFlags) {
          var _this263 = this;

          var componentId = 0;
          file.ngModules.forEach(function (ngModuleMeta, ngModuleIndex) {
            // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,
            // so we don't change the .ngfactory file too much when adding the type-check block.
            // create exports that user code can reference
            _this263._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference); // add references to the symbols from the metadata.
            // These can be used by the type check block for components,
            // and they also cause TypeScript to include these files into the program too,
            // which will make them part of the analyzedFiles.


            var externalReferences = [].concat(_toConsumableArray(ngModuleMeta.transitiveModule.directives.map(function (d) {
              return d.reference;
            })), _toConsumableArray(ngModuleMeta.transitiveModule.pipes.map(function (d) {
              return d.reference;
            })), _toConsumableArray(ngModuleMeta.importedModules.map(function (m) {
              return m.type.reference;
            })), _toConsumableArray(ngModuleMeta.exportedModules.map(function (m) {
              return m.type.reference;
            })), _toConsumableArray(_this263._externalIdentifierReferences([Identifiers.TemplateRef, Identifiers.ElementRef])));
            var externalReferenceVars = new Map();
            externalReferences.forEach(function (ref, typeIndex) {
              externalReferenceVars.set(ref, "_decl".concat(ngModuleIndex, "_").concat(typeIndex));
            });
            externalReferenceVars.forEach(function (varName, reference) {
              outputCtx.statements.push(variable(varName).set(NULL_EXPR.cast(DYNAMIC_TYPE)).toDeclStmt(expressionType(outputCtx.importExpr(reference,
              /* typeParams */
              null,
              /* useSummaries */
              false))));
            });

            if (emitFlags & 2
            /* TypeCheck */
            ) {
                // add the type-check block for all components of the NgModule
                ngModuleMeta.declaredDirectives.forEach(function (dirId) {
                  var compMeta = _this263._metadataResolver.getDirectiveMetadata(dirId.reference);

                  if (!compMeta.isComponent) {
                    return;
                  }

                  componentId++;

                  _this263._createTypeCheckBlock(outputCtx, "".concat(compMeta.type.reference.name, "_Host_").concat(componentId), ngModuleMeta, _this263._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type], externalReferenceVars);

                  _this263._createTypeCheckBlock(outputCtx, "".concat(compMeta.type.reference.name, "_").concat(componentId), ngModuleMeta, compMeta, ngModuleMeta.transitiveModule.directives, externalReferenceVars);
                });
              }
          });

          if (outputCtx.statements.length === 0) {
            _createEmptyStub(outputCtx);
          }
        }
      }, {
        key: "_externalIdentifierReferences",
        value: function _externalIdentifierReferences(references) {
          var result = [];
          var _iteratorNormalCompletion26 = true;
          var _didIteratorError26 = false;
          var _iteratorError26 = undefined;

          try {
            for (var _iterator26 = references[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
              var reference = _step26.value;
              var token = createTokenForExternalReference(this.reflector, reference);

              if (token.identifier) {
                result.push(token.identifier.reference);
              }
            }
          } catch (err) {
            _didIteratorError26 = true;
            _iteratorError26 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion26 && _iterator26.return != null) {
                _iterator26.return();
              }
            } finally {
              if (_didIteratorError26) {
                throw _iteratorError26;
              }
            }
          }

          return result;
        }
      }, {
        key: "_createTypeCheckBlock",
        value: function _createTypeCheckBlock(ctx, componentId, moduleMeta, compMeta, directives, externalReferenceVars) {
          var _ctx$statements;

          var _this$_parseTemplate = this._parseTemplate(compMeta, moduleMeta, directives),
              parsedTemplate = _this$_parseTemplate.template,
              usedPipes = _this$_parseTemplate.pipes;

          (_ctx$statements = ctx.statements).push.apply(_ctx$statements, _toConsumableArray(this._typeCheckCompiler.compileComponent(componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars, ctx)));
        }
      }, {
        key: "emitMessageBundle",
        value: function emitMessageBundle(analyzeResult, locale) {
          var _this264 = this;

          var errors = [];
          var htmlParser = new HtmlParser(); // TODO(vicb): implicit tags & attributes

          var messageBundle = new MessageBundle(htmlParser, [], {}, locale);
          analyzeResult.files.forEach(function (file) {
            var compMetas = [];
            file.directives.forEach(function (directiveType) {
              var dirMeta = _this264._metadataResolver.getDirectiveMetadata(directiveType);

              if (dirMeta && dirMeta.isComponent) {
                compMetas.push(dirMeta);
              }
            });
            compMetas.forEach(function (compMeta) {
              var html = compMeta.template.template; // Template URL points to either an HTML or TS file depending on whether
              // the file is used with `templateUrl:` or `template:`, respectively.

              var templateUrl = compMeta.template.templateUrl;
              var interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);
              errors.push.apply(errors, _toConsumableArray(messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)));
            });
          });

          if (errors.length) {
            throw new Error(errors.map(function (e) {
              return e.toString();
            }).join('\n'));
          }

          return messageBundle;
        }
      }, {
        key: "emitAllPartialModules",
        value: function emitAllPartialModules(_ref43, r3Files) {
          var _this265 = this;

          var ngModuleByPipeOrDirective = _ref43.ngModuleByPipeOrDirective,
              files = _ref43.files;
          var contextMap = new Map();

          var getContext = function getContext(fileName) {
            if (!contextMap.has(fileName)) {
              contextMap.set(fileName, _this265._createOutputContext(fileName));
            }

            return contextMap.get(fileName);
          };

          files.forEach(function (file) {
            return _this265._compilePartialModule(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables, getContext(file.fileName));
          });
          r3Files.forEach(function (file) {
            return _this265._compileShallowModules(file.fileName, file.shallowModules, getContext(file.fileName));
          });
          return Array.from(contextMap.values()).map(function (context) {
            return {
              fileName: context.genFilePath,
              statements: [].concat(_toConsumableArray(context.constantPool.statements), _toConsumableArray(context.statements))
            };
          });
        }
      }, {
        key: "_compileShallowModules",
        value: function _compileShallowModules(fileName, shallowModules, context) {
          var _this266 = this;

          shallowModules.forEach(function (module) {
            return compileNgModuleFromRender2(context, module, _this266._injectableCompiler);
          });
        }
      }, {
        key: "_compilePartialModule",
        value: function _compilePartialModule(fileName, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables, context) {
          var _this267 = this;

          var errors = [];
          var schemaRegistry = new DomElementSchemaRegistry();
          var hostBindingParser = new BindingParser(this._templateParser.expressionParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, [], errors); // Process all components and directives

          directives.forEach(function (directiveType) {
            var directiveMetadata = _this267._metadataResolver.getDirectiveMetadata(directiveType);

            if (directiveMetadata.isComponent) {
              var _module3 = ngModuleByPipeOrDirective.get(directiveType);

              _module3 || error("Cannot determine the module for component '".concat(identifierName(directiveMetadata.type), "'"));
              var htmlAst = directiveMetadata.template.htmlAst;
              var preserveWhitespaces = directiveMetadata.template.preserveWhitespaces;

              if (!preserveWhitespaces) {
                htmlAst = removeWhitespaces(htmlAst);
              }

              var render3Ast = htmlAstToRender3Ast(htmlAst.rootNodes, hostBindingParser); // Map of StaticType by directive selectors

              var directiveTypeBySel = new Map();

              var _directives = _module3.transitiveModule.directives.map(function (dir) {
                return _this267._metadataResolver.getDirectiveSummary(dir.reference);
              });

              _directives.forEach(function (directive) {
                if (directive.selector) {
                  directiveTypeBySel.set(directive.selector, directive.type.reference);
                }
              }); // Map of StaticType by pipe names


              var pipeTypeByName = new Map();

              var _pipes = _module3.transitiveModule.pipes.map(function (pipe) {
                return _this267._metadataResolver.getPipeSummary(pipe.reference);
              });

              _pipes.forEach(function (pipe) {
                pipeTypeByName.set(pipe.name, pipe.type.reference);
              });

              compileComponentFromRender2(context, directiveMetadata, render3Ast, _this267.reflector, hostBindingParser, directiveTypeBySel, pipeTypeByName);
            } else {
              compileDirectiveFromRender2(context, directiveMetadata, _this267.reflector, hostBindingParser);
            }
          });
          pipes.forEach(function (pipeType) {
            var pipeMetadata = _this267._metadataResolver.getPipeMetadata(pipeType);

            if (pipeMetadata) {
              compilePipeFromRender2(context, pipeMetadata, _this267.reflector);
            }
          });
          injectables.forEach(function (injectable) {
            return _this267._injectableCompiler.compile(injectable, context);
          });
        }
      }, {
        key: "emitAllPartialModules2",
        value: function emitAllPartialModules2(files) {
          var _this268 = this;

          // Using reduce like this is a select many pattern (where map is a select pattern)
          return files.reduce(function (r, file) {
            r.push.apply(r, _toConsumableArray(_this268._emitPartialModule2(file.fileName, file.injectables)));
            return r;
          }, []);
        }
      }, {
        key: "_emitPartialModule2",
        value: function _emitPartialModule2(fileName, injectables) {
          var _this269 = this;

          var context = this._createOutputContext(fileName);

          injectables.forEach(function (injectable) {
            return _this269._injectableCompiler.compile(injectable, context);
          });

          if (context.statements && context.statements.length > 0) {
            return [{
              fileName: fileName,
              statements: [].concat(_toConsumableArray(context.constantPool.statements), _toConsumableArray(context.statements))
            }];
          }

          return [];
        }
      }, {
        key: "emitAllImpls",
        value: function emitAllImpls(analyzeResult) {
          var _this270 = this;

          var ngModuleByPipeOrDirective = analyzeResult.ngModuleByPipeOrDirective,
              files = analyzeResult.files;
          var sourceModules = files.map(function (file) {
            return _this270._compileImplFile(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables);
          });
          return flatten(sourceModules);
        }
      }, {
        key: "_compileImplFile",
        value: function _compileImplFile(srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {
          var _this271 = this;

          var fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(srcFileUrl, true)[1]);
          var generatedFiles = [];

          var outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));

          generatedFiles.push.apply(generatedFiles, _toConsumableArray(this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx))); // compile all ng modules

          ngModules.forEach(function (ngModuleMeta) {
            return _this271._compileModule(outputCtx, ngModuleMeta);
          }); // compile components

          directives.forEach(function (dirType) {
            var compMeta = _this271._metadataResolver.getDirectiveMetadata(dirType);

            if (!compMeta.isComponent) {
              return;
            }

            var ngModule = ngModuleByPipeOrDirective.get(dirType);

            if (!ngModule) {
              throw new Error("Internal Error: cannot determine the module for component ".concat(identifierName(compMeta.type), "!"));
            } // compile styles


            var componentStylesheet = _this271._styleCompiler.compileComponent(outputCtx, compMeta); // Note: compMeta is a component and therefore template is non null.


            compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {
              // Note: fill non shim and shim style files as they might
              // be shared by component with and without ViewEncapsulation.
              var shim = _this271._styleCompiler.needsStyleShim(compMeta);

              generatedFiles.push(_this271._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));

              if (_this271._options.allowEmptyCodegenFiles) {
                generatedFiles.push(_this271._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));
              }
            }); // compile components

            var compViewVars = _this271._compileComponent(outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet, fileSuffix);

            _this271._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);
          });

          if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {
            var srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);

            generatedFiles.unshift(srcModule);
          }

          return generatedFiles;
        }
      }, {
        key: "_createSummary",
        value: function _createSummary(srcFileName, directives, pipes, ngModules, injectables, ngFactoryCtx) {
          var _this272 = this;

          var symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName).map(function (symbol) {
            return _this272._symbolResolver.resolveSymbol(symbol);
          });

          var typeData = [].concat(_toConsumableArray(ngModules.map(function (meta) {
            return {
              summary: _this272._metadataResolver.getNgModuleSummary(meta.type.reference),
              metadata: _this272._metadataResolver.getNgModuleMetadata(meta.type.reference)
            };
          })), _toConsumableArray(directives.map(function (ref) {
            return {
              summary: _this272._metadataResolver.getDirectiveSummary(ref),
              metadata: _this272._metadataResolver.getDirectiveMetadata(ref)
            };
          })), _toConsumableArray(pipes.map(function (ref) {
            return {
              summary: _this272._metadataResolver.getPipeSummary(ref),
              metadata: _this272._metadataResolver.getPipeMetadata(ref)
            };
          })), _toConsumableArray(injectables.map(function (ref) {
            return {
              summary: _this272._metadataResolver.getInjectableSummary(ref.symbol),
              metadata: _this272._metadataResolver.getInjectableSummary(ref.symbol).type
            };
          })));
          var forJitOutputCtx = this._options.enableSummariesForJit ? this._createOutputContext(summaryForJitFileName(srcFileName, true)) : null;

          var _serializeSummaries = serializeSummaries(srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries, typeData, this._options.createExternalSymbolFactoryReexports),
              json = _serializeSummaries.json,
              exportAs = _serializeSummaries.exportAs;

          exportAs.forEach(function (entry) {
            ngFactoryCtx.statements.push(variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [StmtModifier.Exported]));
          });
          var summaryJson = new GeneratedFile(srcFileName, summaryFileName(srcFileName), json);
          var result = [summaryJson];

          if (forJitOutputCtx) {
            result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));
          }

          return result;
        }
      }, {
        key: "_compileModule",
        value: function _compileModule(outputCtx, ngModule) {
          var providers = [];

          if (this._options.locale) {
            var normalizedLocale = this._options.locale.replace(/_/g, '-');

            providers.push({
              token: createTokenForExternalReference(this.reflector, Identifiers.LOCALE_ID),
              useValue: normalizedLocale
            });
          }

          if (this._options.i18nFormat) {
            providers.push({
              token: createTokenForExternalReference(this.reflector, Identifiers.TRANSLATIONS_FORMAT),
              useValue: this._options.i18nFormat
            });
          }

          this._ngModuleCompiler.compile(outputCtx, ngModule, providers);
        }
      }, {
        key: "_compileComponentFactory",
        value: function _compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix) {
          var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);

          var hostViewFactoryVar = this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix).viewClassVar;

          var compFactoryVar = componentFactoryName(compMeta.type.reference);
          var inputsExprs = [];

          for (var propName in compMeta.inputs) {
            var templateName = compMeta.inputs[propName]; // Don't quote so that the key gets minified...

            inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));
          }

          var outputsExprs = [];

          for (var _propName in compMeta.outputs) {
            var _templateName = compMeta.outputs[_propName]; // Don't quote so that the key gets minified...

            outputsExprs.push(new LiteralMapEntry(_propName, literal(_templateName), false));
          }

          outputCtx.statements.push(variable(compFactoryVar).set(importExpr(Identifiers.createComponentFactory).callFn([literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference), variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs), new LiteralMapExpr(outputsExprs), literalArr(compMeta.template.ngContentSelectors.map(function (selector) {
            return literal(selector);
          }))])).toDeclStmt(importType(Identifiers.ComponentFactory, [expressionType(outputCtx.importExpr(compMeta.type.reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]));
        }
      }, {
        key: "_compileComponent",
        value: function _compileComponent(outputCtx, compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix) {
          var _this$_parseTemplate2 = this._parseTemplate(compMeta, ngModule, directiveIdentifiers),
              parsedTemplate = _this$_parseTemplate2.template,
              usedPipes = _this$_parseTemplate2.pipes;

          var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);

          var viewResult = this._viewCompiler.compileComponent(outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);

          if (componentStyles) {
            _resolveStyleStatements(this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);
          }

          return viewResult;
        }
      }, {
        key: "_parseTemplate",
        value: function _parseTemplate(compMeta, ngModule, directiveIdentifiers) {
          var _this273 = this;

          if (this._templateAstCache.has(compMeta.type.reference)) {
            return this._templateAstCache.get(compMeta.type.reference);
          }

          var preserveWhitespaces = compMeta.template.preserveWhitespaces;
          var directives = directiveIdentifiers.map(function (dir) {
            return _this273._metadataResolver.getDirectiveSummary(dir.reference);
          });
          var pipes = ngModule.transitiveModule.pipes.map(function (pipe) {
            return _this273._metadataResolver.getPipeSummary(pipe.reference);
          });

          var result = this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);

          this._templateAstCache.set(compMeta.type.reference, result);

          return result;
        }
      }, {
        key: "_createOutputContext",
        value: function _createOutputContext(genFilePath) {
          var _this274 = this;

          var importExpr$1 = function importExpr$1(symbol) {
            var typeParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var useSummaries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

            if (!(symbol instanceof StaticSymbol)) {
              throw new Error("Internal error: unknown identifier ".concat(JSON.stringify(symbol)));
            }

            var arity = _this274._symbolResolver.getTypeArity(symbol) || 0;

            var _ref44 = _this274._symbolResolver.getImportAs(symbol, useSummaries) || symbol,
                filePath = _ref44.filePath,
                name = _ref44.name,
                members = _ref44.members;

            var importModule = _this274._fileNameToModuleName(filePath, genFilePath); // It should be good enough to compare filePath to genFilePath and if they are equal
            // there is a self reference. However, ngfactory files generate to .ts but their
            // symbols have .d.ts so a simple compare is insufficient. They should be canonical
            // and is tracked by #17705.


            var selfReference = _this274._fileNameToModuleName(genFilePath, genFilePath);

            var moduleName = importModule === selfReference ? null : importModule; // If we are in a type expression that refers to a generic type then supply
            // the required type parameters. If there were not enough type parameters
            // supplied, supply any as the type. Outside a type expression the reference
            // should not supply type parameters and be treated as a simple value reference
            // to the constructor function itself.

            var suppliedTypeParams = typeParams || [];
            var missingTypeParamsCount = arity - suppliedTypeParams.length;
            var allTypeParams = suppliedTypeParams.concat(newArray(missingTypeParamsCount, DYNAMIC_TYPE));
            return members.reduce(function (expr, memberName) {
              return expr.prop(memberName);
            }, importExpr(new ExternalReference(moduleName, name, null), allTypeParams));
          };

          return {
            statements: [],
            genFilePath: genFilePath,
            importExpr: importExpr$1,
            constantPool: new ConstantPool()
          };
        }
      }, {
        key: "_fileNameToModuleName",
        value: function _fileNameToModuleName(importedFilePath, containingFilePath) {
          return this._summaryResolver.getKnownModuleName(importedFilePath) || this._symbolResolver.getKnownModuleName(importedFilePath) || this._host.fileNameToModuleName(importedFilePath, containingFilePath);
        }
      }, {
        key: "_codegenStyles",
        value: function _codegenStyles(srcFileUrl, compMeta, stylesheetMetadata, isShimmed, fileSuffix) {
          var outputCtx = this._createOutputContext(_stylesModuleUrl(stylesheetMetadata.moduleUrl, isShimmed, fileSuffix));

          var compiledStylesheet = this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);

          _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);

          return this._codegenSourceModule(srcFileUrl, outputCtx);
        }
      }, {
        key: "_codegenSourceModule",
        value: function _codegenSourceModule(srcFileUrl, ctx) {
          return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);
        }
      }, {
        key: "listLazyRoutes",
        value: function listLazyRoutes(entryRoute, analyzedModules) {
          var self = this;

          if (entryRoute) {
            var symbol = parseLazyRoute(entryRoute, this.reflector).referencedModule;
            return visitLazyRoute(symbol);
          } else if (analyzedModules) {
            var allLazyRoutes = [];
            var _iteratorNormalCompletion27 = true;
            var _didIteratorError27 = false;
            var _iteratorError27 = undefined;

            try {
              for (var _iterator27 = analyzedModules.ngModules[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                var ngModule = _step27.value;

                var lazyRoutes = _listLazyRoutes(ngModule, this.reflector);

                var _iteratorNormalCompletion28 = true;
                var _didIteratorError28 = false;
                var _iteratorError28 = undefined;

                try {
                  for (var _iterator28 = lazyRoutes[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
                    var lazyRoute = _step28.value;
                    allLazyRoutes.push(lazyRoute);
                  }
                } catch (err) {
                  _didIteratorError28 = true;
                  _iteratorError28 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion28 && _iterator28.return != null) {
                      _iterator28.return();
                    }
                  } finally {
                    if (_didIteratorError28) {
                      throw _iteratorError28;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError27 = true;
              _iteratorError27 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion27 && _iterator27.return != null) {
                  _iterator27.return();
                }
              } finally {
                if (_didIteratorError27) {
                  throw _iteratorError27;
                }
              }
            }

            return allLazyRoutes;
          } else {
            throw new Error("Either route or analyzedModules has to be specified!");
          }

          function visitLazyRoute(symbol) {
            var seenRoutes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
            var allLazyRoutes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

            // Support pointing to default exports, but stop recursing there,
            // as the StaticReflector does not yet support default exports.
            if (seenRoutes.has(symbol) || !symbol.name) {
              return allLazyRoutes;
            }

            seenRoutes.add(symbol);

            var lazyRoutes = _listLazyRoutes(self._metadataResolver.getNgModuleMetadata(symbol, true), self.reflector);

            var _iteratorNormalCompletion29 = true;
            var _didIteratorError29 = false;
            var _iteratorError29 = undefined;

            try {
              for (var _iterator29 = lazyRoutes[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
                var _lazyRoute = _step29.value;
                allLazyRoutes.push(_lazyRoute);
                visitLazyRoute(_lazyRoute.referencedModule, seenRoutes, allLazyRoutes);
              }
            } catch (err) {
              _didIteratorError29 = true;
              _iteratorError29 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion29 && _iterator29.return != null) {
                  _iterator29.return();
                }
              } finally {
                if (_didIteratorError29) {
                  throw _iteratorError29;
                }
              }
            }

            return allLazyRoutes;
          }
        }
      }]);

      return AotCompiler;
    }();

    function _createEmptyStub(outputCtx) {
      // Note: We need to produce at least one import statement so that
      // TypeScript knows that the file is an es6 module. Otherwise our generated
      // exports / imports won't be emitted properly by TypeScript.
      outputCtx.statements.push(importExpr(Identifiers.ComponentFactory).toStmt());
    }

    function _resolveStyleStatements(symbolResolver, compileResult, needsShim, fileSuffix) {
      compileResult.dependencies.forEach(function (dep) {
        dep.setValue(symbolResolver.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));
      });
    }

    function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
      return "".concat(stylesheetUrl).concat(shim ? '.shim' : '', ".ngstyle").concat(suffix);
    }

    function analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {
      var files = _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver);

      return mergeAnalyzedFiles(files);
    }

    function analyzeAndValidateNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {
      return validateAnalyzedModules(analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));
    }

    function validateAnalyzedModules(analyzedModules) {
      if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {
        var messages = analyzedModules.symbolsMissingModule.map(function (s) {
          return "Cannot determine the module for class ".concat(s.name, " in ").concat(s.filePath, "! Add ").concat(s.name, " to the NgModule to fix it.");
        });
        throw syntaxError(messages.join('\n'));
      }

      return analyzedModules;
    } // Analyzes all of the program files,
    // including files that are not part of the program
    // but are referenced by an NgModule.


    function _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver) {
      var seenFiles = new Set();
      var files = [];

      var visitFile = function visitFile(fileName) {
        if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {
          return false;
        }

        seenFiles.add(fileName);
        var analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);
        files.push(analyzedFile);
        analyzedFile.ngModules.forEach(function (ngModule) {
          ngModule.transitiveModule.modules.forEach(function (modMeta) {
            return visitFile(modMeta.reference.filePath);
          });
        });
      };

      fileNames.forEach(function (fileName) {
        return visitFile(fileName);
      });
      return files;
    }

    function analyzeFile(host, staticSymbolResolver, metadataResolver, fileName) {
      var abstractDirectives = [];
      var directives = [];
      var pipes = [];
      var injectables = [];
      var ngModules = [];
      var hasDecorators = staticSymbolResolver.hasDecorators(fileName);
      var exportsNonSourceFiles = false;
      var isDeclarationFile = fileName.endsWith('.d.ts'); // Don't analyze .d.ts files that have no decorators as a shortcut
      // to speed up the analysis. This prevents us from
      // resolving the references in these files.
      // Note: exportsNonSourceFiles is only needed when compiling with summaries,
      // which is not the case when .d.ts files are treated as input files.

      if (!isDeclarationFile || hasDecorators) {
        staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {
          var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);
          var symbolMeta = resolvedSymbol.metadata;

          if (!symbolMeta || symbolMeta.__symbolic === 'error') {
            return;
          }

          var isNgSymbol = false;

          if (symbolMeta.__symbolic === 'class') {
            if (metadataResolver.isDirective(symbol)) {
              isNgSymbol = true; // This directive either has a selector or doesn't. Selector-less directives get tracked
              // in abstractDirectives, not directives. The compiler doesn't deal with selector-less
              // directives at all, really, other than to persist their metadata. This is done so that
              // apps will have an easier time migrating to Ivy, which requires the selector-less
              // annotations to be applied.

              if (!metadataResolver.isAbstractDirective(symbol)) {
                // The directive is an ordinary directive.
                directives.push(symbol);
              } else {
                // The directive has no selector and is an "abstract" directive, so track it
                // accordingly.
                abstractDirectives.push(symbol);
              }
            } else if (metadataResolver.isPipe(symbol)) {
              isNgSymbol = true;
              pipes.push(symbol);
            } else if (metadataResolver.isNgModule(symbol)) {
              var ngModule = metadataResolver.getNgModuleMetadata(symbol, false);

              if (ngModule) {
                isNgSymbol = true;
                ngModules.push(ngModule);
              }
            } else if (metadataResolver.isInjectable(symbol)) {
              isNgSymbol = true;
              var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);

              if (injectable) {
                injectables.push(injectable);
              }
            }
          }

          if (!isNgSymbol) {
            exportsNonSourceFiles = exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);
          }
        });
      }

      return {
        fileName: fileName,
        directives: directives,
        abstractDirectives: abstractDirectives,
        pipes: pipes,
        ngModules: ngModules,
        injectables: injectables,
        exportsNonSourceFiles: exportsNonSourceFiles
      };
    }

    function analyzeFileForInjectables(host, staticSymbolResolver, metadataResolver, fileName) {
      var injectables = [];
      var shallowModules = [];

      if (staticSymbolResolver.hasDecorators(fileName)) {
        staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {
          var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);
          var symbolMeta = resolvedSymbol.metadata;

          if (!symbolMeta || symbolMeta.__symbolic === 'error') {
            return;
          }

          if (symbolMeta.__symbolic === 'class') {
            if (metadataResolver.isInjectable(symbol)) {
              var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);

              if (injectable) {
                injectables.push(injectable);
              }
            } else if (metadataResolver.isNgModule(symbol)) {
              var _module4 = metadataResolver.getShallowModuleMetadata(symbol);

              if (_module4) {
                shallowModules.push(_module4);
              }
            }
          }
        });
      }

      return {
        fileName: fileName,
        injectables: injectables,
        shallowModules: shallowModules
      };
    }

    function isValueExportingNonSourceFile(host, metadata) {
      var exportsNonSourceFiles = false;

      var Visitor =
      /*#__PURE__*/
      function () {
        function Visitor() {
          _classCallCheck(this, Visitor);
        }

        _createClass(Visitor, [{
          key: "visitArray",
          value: function visitArray(arr, context) {
            var _this275 = this;

            arr.forEach(function (v) {
              return visitValue(v, _this275, context);
            });
          }
        }, {
          key: "visitStringMap",
          value: function visitStringMap(map, context) {
            var _this276 = this;

            Object.keys(map).forEach(function (key) {
              return visitValue(map[key], _this276, context);
            });
          }
        }, {
          key: "visitPrimitive",
          value: function visitPrimitive(value, context) {}
        }, {
          key: "visitOther",
          value: function visitOther(value, context) {
            if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {
              exportsNonSourceFiles = true;
            }
          }
        }]);

        return Visitor;
      }();

      visitValue(metadata, new Visitor(), null);
      return exportsNonSourceFiles;
    }

    function mergeAnalyzedFiles(analyzedFiles) {
      var allNgModules = [];
      var ngModuleByPipeOrDirective = new Map();
      var allPipesAndDirectives = new Set();
      analyzedFiles.forEach(function (af) {
        af.ngModules.forEach(function (ngModule) {
          allNgModules.push(ngModule);
          ngModule.declaredDirectives.forEach(function (d) {
            return ngModuleByPipeOrDirective.set(d.reference, ngModule);
          });
          ngModule.declaredPipes.forEach(function (p) {
            return ngModuleByPipeOrDirective.set(p.reference, ngModule);
          });
        });
        af.directives.forEach(function (d) {
          return allPipesAndDirectives.add(d);
        });
        af.pipes.forEach(function (p) {
          return allPipesAndDirectives.add(p);
        });
      });
      var symbolsMissingModule = [];
      allPipesAndDirectives.forEach(function (ref) {
        if (!ngModuleByPipeOrDirective.has(ref)) {
          symbolsMissingModule.push(ref);
        }
      });
      return {
        ngModules: allNgModules,
        ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,
        symbolsMissingModule: symbolsMissingModule,
        files: analyzedFiles
      };
    }

    function mergeAndValidateNgFiles(files) {
      return validateAnalyzedModules(mergeAnalyzedFiles(files));
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var FORMATTED_MESSAGE = 'ngFormattedMessage';

    function indentStr(level) {
      if (level <= 0) return '';
      if (level < 6) return ['', ' ', '  ', '   ', '    ', '     '][level];
      var half = indentStr(Math.floor(level / 2));
      return half + half + (level % 2 === 1 ? ' ' : '');
    }

    function formatChain(chain) {
      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (!chain) return '';
      var position = chain.position ? "".concat(chain.position.fileName, "(").concat(chain.position.line + 1, ",").concat(chain.position.column + 1, ")") : '';
      var prefix = position && indent === 0 ? "".concat(position, ": ") : '';
      var postfix = position && indent !== 0 ? " at ".concat(position) : '';
      var message = "".concat(prefix).concat(chain.message).concat(postfix);

      if (chain.next) {
        var _iteratorNormalCompletion30 = true;
        var _didIteratorError30 = false;
        var _iteratorError30 = undefined;

        try {
          for (var _iterator30 = chain.next[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
            var kid = _step30.value;
            message += '\n' + formatChain(kid, indent + 2);
          }
        } catch (err) {
          _didIteratorError30 = true;
          _iteratorError30 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion30 && _iterator30.return != null) {
              _iterator30.return();
            }
          } finally {
            if (_didIteratorError30) {
              throw _iteratorError30;
            }
          }
        }
      }

      return "".concat(indentStr(indent)).concat(message);
    }

    function formattedError(chain) {
      var message = formatChain(chain) + '.';
      var error = syntaxError(message);
      error[FORMATTED_MESSAGE] = true;
      error.chain = chain;
      error.position = chain.position;
      return error;
    }

    function isFormattedError(error) {
      return !!error[FORMATTED_MESSAGE];
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var ANGULAR_CORE = '@angular/core';
    var ANGULAR_ROUTER = '@angular/router';
    var HIDDEN_KEY = /^\$.*\$$/;
    var IGNORE = {
      __symbolic: 'ignore'
    };
    var USE_VALUE$1 = 'useValue';
    var PROVIDE = 'provide';
    var REFERENCE_SET = new Set([USE_VALUE$1, 'useFactory', 'data', 'id', 'loadChildren']);
    var TYPEGUARD_POSTFIX = 'TypeGuard';
    var USE_IF = 'UseIf';

    function shouldIgnore(value) {
      return value && value.__symbolic == 'ignore';
    }
    /**
     * A static reflector implements enough of the Reflector API that is necessary to compile
     * templates statically.
     */


    var StaticReflector =
    /*#__PURE__*/
    function () {
      function StaticReflector(summaryResolver, symbolResolver) {
        var _this277 = this;

        var knownMetadataClasses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var knownMetadataFunctions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        var errorRecorder = arguments.length > 4 ? arguments[4] : undefined;

        _classCallCheck(this, StaticReflector);

        this.summaryResolver = summaryResolver;
        this.symbolResolver = symbolResolver;
        this.errorRecorder = errorRecorder;
        this.annotationCache = new Map();
        this.shallowAnnotationCache = new Map();
        this.propertyCache = new Map();
        this.parameterCache = new Map();
        this.methodCache = new Map();
        this.staticCache = new Map();
        this.conversionMap = new Map();
        this.resolvedExternalReferences = new Map();
        this.annotationForParentClassWithSummaryKind = new Map();
        this.initializeConversionMap();
        knownMetadataClasses.forEach(function (kc) {
          return _this277._registerDecoratorOrConstructor(_this277.getStaticSymbol(kc.filePath, kc.name), kc.ctor);
        });
        knownMetadataFunctions.forEach(function (kf) {
          return _this277._registerFunction(_this277.getStaticSymbol(kf.filePath, kf.name), kf.fn);
        });
        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [createDirective, createComponent]);
        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [createPipe]);
        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [createNgModule]);
        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [createInjectable, createPipe, createDirective, createComponent, createNgModule]);
      }

      _createClass(StaticReflector, [{
        key: "componentModuleUrl",
        value: function componentModuleUrl(typeOrFunc) {
          var staticSymbol = this.findSymbolDeclaration(typeOrFunc);
          return this.symbolResolver.getResourcePath(staticSymbol);
        }
        /**
         * Invalidate the specified `symbols` on program change.
         * @param symbols
         */

      }, {
        key: "invalidateSymbols",
        value: function invalidateSymbols(symbols) {
          var _iteratorNormalCompletion31 = true;
          var _didIteratorError31 = false;
          var _iteratorError31 = undefined;

          try {
            for (var _iterator31 = symbols[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
              var symbol = _step31.value;
              this.annotationCache.delete(symbol);
              this.shallowAnnotationCache.delete(symbol);
              this.propertyCache.delete(symbol);
              this.parameterCache.delete(symbol);
              this.methodCache.delete(symbol);
              this.staticCache.delete(symbol);
              this.conversionMap.delete(symbol);
            }
          } catch (err) {
            _didIteratorError31 = true;
            _iteratorError31 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion31 && _iterator31.return != null) {
                _iterator31.return();
              }
            } finally {
              if (_didIteratorError31) {
                throw _iteratorError31;
              }
            }
          }
        }
      }, {
        key: "resolveExternalReference",
        value: function resolveExternalReference(ref, containingFile) {
          var key = undefined;

          if (!containingFile) {
            key = "".concat(ref.moduleName, ":").concat(ref.name);

            var _declarationSymbol = this.resolvedExternalReferences.get(key);

            if (_declarationSymbol) return _declarationSymbol;
          }

          var refSymbol = this.symbolResolver.getSymbolByModule(ref.moduleName, ref.name, containingFile);
          var declarationSymbol = this.findSymbolDeclaration(refSymbol);

          if (!containingFile) {
            this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, ref.moduleName);
            this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);
          }

          if (key) {
            this.resolvedExternalReferences.set(key, declarationSymbol);
          }

          return declarationSymbol;
        }
      }, {
        key: "findDeclaration",
        value: function findDeclaration(moduleUrl, name, containingFile) {
          return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));
        }
      }, {
        key: "tryFindDeclaration",
        value: function tryFindDeclaration(moduleUrl, name, containingFile) {
          var _this278 = this;

          return this.symbolResolver.ignoreErrorsFor(function () {
            return _this278.findDeclaration(moduleUrl, name, containingFile);
          });
        }
      }, {
        key: "findSymbolDeclaration",
        value: function findSymbolDeclaration(symbol) {
          var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);

          if (resolvedSymbol) {
            var resolvedMetadata = resolvedSymbol.metadata;

            if (resolvedMetadata && resolvedMetadata.__symbolic === 'resolved') {
              resolvedMetadata = resolvedMetadata.symbol;
            }

            if (resolvedMetadata instanceof StaticSymbol) {
              return this.findSymbolDeclaration(resolvedSymbol.metadata);
            }
          }

          return symbol;
        }
      }, {
        key: "tryAnnotations",
        value: function tryAnnotations(type) {
          var originalRecorder = this.errorRecorder;

          this.errorRecorder = function (error, fileName) {};

          try {
            return this.annotations(type);
          } finally {
            this.errorRecorder = originalRecorder;
          }
        }
      }, {
        key: "annotations",
        value: function annotations(type) {
          var _this279 = this;

          return this._annotations(type, function (type, decorators) {
            return _this279.simplify(type, decorators);
          }, this.annotationCache);
        }
      }, {
        key: "shallowAnnotations",
        value: function shallowAnnotations(type) {
          var _this280 = this;

          return this._annotations(type, function (type, decorators) {
            return _this280.simplify(type, decorators, true);
          }, this.shallowAnnotationCache);
        }
      }, {
        key: "_annotations",
        value: function _annotations(type, simplify, annotationCache) {
          var annotations = annotationCache.get(type);

          if (!annotations) {
            annotations = [];
            var classMetadata = this.getTypeMetadata(type);
            var parentType = this.findParentType(type, classMetadata);

            if (parentType) {
              var _annotations2;

              var parentAnnotations = this.annotations(parentType);

              (_annotations2 = annotations).push.apply(_annotations2, _toConsumableArray(parentAnnotations));
            }

            var ownAnnotations = [];

            if (classMetadata['decorators']) {
              ownAnnotations = simplify(type, classMetadata['decorators']);

              if (ownAnnotations) {
                var _annotations3;

                (_annotations3 = annotations).push.apply(_annotations3, _toConsumableArray(ownAnnotations));
              }
            }

            if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) && this.summaryResolver.isLibraryFile(parentType.filePath)) {
              var summary = this.summaryResolver.resolveSummary(parentType);

              if (summary && summary.type) {
                var requiredAnnotationTypes = this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind);
                var typeHasRequiredAnnotation = requiredAnnotationTypes.some(function (requiredType) {
                  return ownAnnotations.some(function (ann) {
                    return requiredType.isTypeOf(ann);
                  });
                });

                if (!typeHasRequiredAnnotation) {
                  this.reportError(formatMetadataError(metadataError("Class ".concat(type.name, " in ").concat(type.filePath, " extends from a ").concat(CompileSummaryKind[summary.type.summaryKind], " in another compilation unit without duplicating the decorator"),
                  /* summary */
                  undefined, "Please add a ".concat(requiredAnnotationTypes.map(function (type) {
                    return type.ngMetadataName;
                  }).join(' or '), " decorator to the class")), type), type);
                }
              }
            }

            annotationCache.set(type, annotations.filter(function (ann) {
              return !!ann;
            }));
          }

          return annotations;
        }
      }, {
        key: "propMetadata",
        value: function propMetadata(type) {
          var _this281 = this;

          var propMetadata = this.propertyCache.get(type);

          if (!propMetadata) {
            var classMetadata = this.getTypeMetadata(type);
            propMetadata = {};
            var parentType = this.findParentType(type, classMetadata);

            if (parentType) {
              var parentPropMetadata = this.propMetadata(parentType);
              Object.keys(parentPropMetadata).forEach(function (parentProp) {
                propMetadata[parentProp] = parentPropMetadata[parentProp];
              });
            }

            var members = classMetadata['members'] || {};
            Object.keys(members).forEach(function (propName) {
              var propData = members[propName];
              var prop = propData.find(function (a) {
                return a['__symbolic'] == 'property' || a['__symbolic'] == 'method';
              });
              var decorators = [];

              if (propMetadata[propName]) {
                decorators.push.apply(decorators, _toConsumableArray(propMetadata[propName]));
              }

              propMetadata[propName] = decorators;

              if (prop && prop['decorators']) {
                decorators.push.apply(decorators, _toConsumableArray(_this281.simplify(type, prop['decorators'])));
              }
            });
            this.propertyCache.set(type, propMetadata);
          }

          return propMetadata;
        }
      }, {
        key: "parameters",
        value: function parameters(type) {
          var _this282 = this;

          if (!(type instanceof StaticSymbol)) {
            this.reportError(new Error("parameters received ".concat(JSON.stringify(type), " which is not a StaticSymbol")), type);
            return [];
          }

          try {
            var parameters = this.parameterCache.get(type);

            if (!parameters) {
              var classMetadata = this.getTypeMetadata(type);
              var parentType = this.findParentType(type, classMetadata);
              var members = classMetadata ? classMetadata['members'] : null;
              var ctorData = members ? members['__ctor__'] : null;

              if (ctorData) {
                var ctor = ctorData.find(function (a) {
                  return a['__symbolic'] == 'constructor';
                });
                var rawParameterTypes = ctor['parameters'] || [];
                var parameterDecorators = this.simplify(type, ctor['parameterDecorators'] || []);
                parameters = [];
                rawParameterTypes.forEach(function (rawParamType, index) {
                  var nestedResult = [];

                  var paramType = _this282.trySimplify(type, rawParamType);

                  if (paramType) nestedResult.push(paramType);
                  var decorators = parameterDecorators ? parameterDecorators[index] : null;

                  if (decorators) {
                    nestedResult.push.apply(nestedResult, _toConsumableArray(decorators));
                  }

                  parameters.push(nestedResult);
                });
              } else if (parentType) {
                parameters = this.parameters(parentType);
              }

              if (!parameters) {
                parameters = [];
              }

              this.parameterCache.set(type, parameters);
            }

            return parameters;
          } catch (e) {
            console.error("Failed on type ".concat(JSON.stringify(type), " with error ").concat(e));
            throw e;
          }
        }
      }, {
        key: "_methodNames",
        value: function _methodNames(type) {
          var methodNames = this.methodCache.get(type);

          if (!methodNames) {
            var classMetadata = this.getTypeMetadata(type);
            methodNames = {};
            var parentType = this.findParentType(type, classMetadata);

            if (parentType) {
              var parentMethodNames = this._methodNames(parentType);

              Object.keys(parentMethodNames).forEach(function (parentProp) {
                methodNames[parentProp] = parentMethodNames[parentProp];
              });
            }

            var members = classMetadata['members'] || {};
            Object.keys(members).forEach(function (propName) {
              var propData = members[propName];
              var isMethod = propData.some(function (a) {
                return a['__symbolic'] == 'method';
              });
              methodNames[propName] = methodNames[propName] || isMethod;
            });
            this.methodCache.set(type, methodNames);
          }

          return methodNames;
        }
      }, {
        key: "_staticMembers",
        value: function _staticMembers(type) {
          var staticMembers = this.staticCache.get(type);

          if (!staticMembers) {
            var classMetadata = this.getTypeMetadata(type);
            var staticMemberData = classMetadata['statics'] || {};
            staticMembers = Object.keys(staticMemberData);
            this.staticCache.set(type, staticMembers);
          }

          return staticMembers;
        }
      }, {
        key: "findParentType",
        value: function findParentType(type, classMetadata) {
          var parentType = this.trySimplify(type, classMetadata['extends']);

          if (parentType instanceof StaticSymbol) {
            return parentType;
          }
        }
      }, {
        key: "hasLifecycleHook",
        value: function hasLifecycleHook(type, lcProperty) {
          if (!(type instanceof StaticSymbol)) {
            this.reportError(new Error("hasLifecycleHook received ".concat(JSON.stringify(type), " which is not a StaticSymbol")), type);
          }

          try {
            return !!this._methodNames(type)[lcProperty];
          } catch (e) {
            console.error("Failed on type ".concat(JSON.stringify(type), " with error ").concat(e));
            throw e;
          }
        }
      }, {
        key: "guards",
        value: function guards(type) {
          if (!(type instanceof StaticSymbol)) {
            this.reportError(new Error("guards received ".concat(JSON.stringify(type), " which is not a StaticSymbol")), type);
            return {};
          }

          var staticMembers = this._staticMembers(type);

          var result = {};
          var _iteratorNormalCompletion32 = true;
          var _didIteratorError32 = false;
          var _iteratorError32 = undefined;

          try {
            for (var _iterator32 = staticMembers[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
              var name = _step32.value;

              if (name.endsWith(TYPEGUARD_POSTFIX)) {
                var property = name.substr(0, name.length - TYPEGUARD_POSTFIX.length);
                var value = void 0;

                if (property.endsWith(USE_IF)) {
                  property = name.substr(0, property.length - USE_IF.length);
                  value = USE_IF;
                } else {
                  value = this.getStaticSymbol(type.filePath, type.name, [name]);
                }

                result[property] = value;
              }
            }
          } catch (err) {
            _didIteratorError32 = true;
            _iteratorError32 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion32 && _iterator32.return != null) {
                _iterator32.return();
              }
            } finally {
              if (_didIteratorError32) {
                throw _iteratorError32;
              }
            }
          }

          return result;
        }
      }, {
        key: "_registerDecoratorOrConstructor",
        value: function _registerDecoratorOrConstructor(type, ctor) {
          this.conversionMap.set(type, function (context, args) {
            return _construct(ctor, _toConsumableArray(args));
          });
        }
      }, {
        key: "_registerFunction",
        value: function _registerFunction(type, fn) {
          this.conversionMap.set(type, function (context, args) {
            return fn.apply(undefined, args);
          });
        }
      }, {
        key: "initializeConversionMap",
        value: function initializeConversionMap() {
          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), createInjectable);

          this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');
          this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');
          this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');
          this.ANALYZE_FOR_ENTRY_COMPONENTS = this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), createInject);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), createAttribute);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), createContentChild);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), createContentChildren);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), createViewChild);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), createViewChildren);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), createInput);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), createOutput);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), createPipe);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), createHostBinding);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), createHostListener);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), createDirective);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), createComponent);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), createNgModule); // Note: Some metadata classes can be used directly with Provider.deps.


          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);

          this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);
        }
        /**
         * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
         * All types passed to the StaticResolver should be pseudo-types returned by this method.
         *
         * @param declarationFile the absolute path of the file where the symbol is declared
         * @param name the name of the type.
         */

      }, {
        key: "getStaticSymbol",
        value: function getStaticSymbol(declarationFile, name, members) {
          return this.symbolResolver.getStaticSymbol(declarationFile, name, members);
        }
        /**
         * Simplify but discard any errors
         */

      }, {
        key: "trySimplify",
        value: function trySimplify(context, value) {
          var originalRecorder = this.errorRecorder;

          this.errorRecorder = function (error, fileName) {};

          var result = this.simplify(context, value);
          this.errorRecorder = originalRecorder;
          return result;
        }
        /** @internal */

      }, {
        key: "simplify",
        value: function simplify(context, value) {
          var lazy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var self = this;
          var scope = BindingScope$1.empty;
          var calling = new Map();
          var rootContext = context;

          function simplifyInContext(context, value, depth, references) {
            function resolveReferenceValue(staticSymbol) {
              var resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);
              return resolvedSymbol ? resolvedSymbol.metadata : null;
            }

            function simplifyEagerly(value) {
              return simplifyInContext(context, value, depth, 0);
            }

            function simplifyLazily(value) {
              return simplifyInContext(context, value, depth, references + 1);
            }

            function simplifyNested(nestedContext, value) {
              if (nestedContext === context) {
                // If the context hasn't changed let the exception propagate unmodified.
                return simplifyInContext(nestedContext, value, depth + 1, references);
              }

              try {
                return simplifyInContext(nestedContext, value, depth + 1, references);
              } catch (e) {
                if (isMetadataError(e)) {
                  // Propagate the message text up but add a message to the chain that explains how we got
                  // here.
                  // e.chain implies e.symbol
                  var summaryMsg = e.chain ? 'references \'' + e.symbol.name + '\'' : errorSummary(e);
                  var summary = "'".concat(nestedContext.name, "' ").concat(summaryMsg);
                  var chain = {
                    message: summary,
                    position: e.position,
                    next: e.chain
                  }; // TODO(chuckj): retrieve the position information indirectly from the collectors node
                  // map if the metadata is from a .ts file.

                  self.error({
                    message: e.message,
                    advise: e.advise,
                    context: e.context,
                    chain: chain,
                    symbol: nestedContext
                  }, context);
                } else {
                  // It is probably an internal error.
                  throw e;
                }
              }
            }

            function simplifyCall(functionSymbol, targetFunction, args, targetExpression) {
              if (targetFunction && targetFunction['__symbolic'] == 'function') {
                if (calling.get(functionSymbol)) {
                  self.error({
                    message: 'Recursion is not supported',
                    summary: "called '".concat(functionSymbol.name, "' recursively"),
                    value: targetFunction
                  }, functionSymbol);
                }

                try {
                  var _value6 = targetFunction['value'];

                  if (_value6 && (depth != 0 || _value6.__symbolic != 'error')) {
                    var parameters = targetFunction['parameters'];
                    var defaults = targetFunction.defaults;
                    args = args.map(function (arg) {
                      return simplifyNested(context, arg);
                    }).map(function (arg) {
                      return shouldIgnore(arg) ? undefined : arg;
                    });

                    if (defaults && defaults.length > args.length) {
                      var _args2;

                      (_args2 = args).push.apply(_args2, _toConsumableArray(defaults.slice(args.length).map(function (value) {
                        return simplify(value);
                      })));
                    }

                    calling.set(functionSymbol, true);
                    var functionScope = BindingScope$1.build();

                    for (var i = 0; i < parameters.length; i++) {
                      functionScope.define(parameters[i], args[i]);
                    }

                    var oldScope = scope;

                    var _result;

                    try {
                      scope = functionScope.done();
                      _result = simplifyNested(functionSymbol, _value6);
                    } finally {
                      scope = oldScope;
                    }

                    return _result;
                  }
                } finally {
                  calling.delete(functionSymbol);
                }
              }

              if (depth === 0) {
                // If depth is 0 we are evaluating the top level expression that is describing element
                // decorator. In this case, it is a decorator we don't understand, such as a custom
                // non-angular decorator, and we should just ignore it.
                return IGNORE;
              }

              var position = undefined;

              if (targetExpression && targetExpression.__symbolic == 'resolved') {
                var line = targetExpression.line;
                var character = targetExpression.character;
                var fileName = targetExpression.fileName;

                if (fileName != null && line != null && character != null) {
                  position = {
                    fileName: fileName,
                    line: line,
                    column: character
                  };
                }
              }

              self.error({
                message: FUNCTION_CALL_NOT_SUPPORTED,
                context: functionSymbol,
                value: targetFunction,
                position: position
              }, context);
            }

            function simplify(expression) {
              if (isPrimitive(expression)) {
                return expression;
              }

              if (Array.isArray(expression)) {
                var _result2 = [];
                var _iteratorNormalCompletion33 = true;
                var _didIteratorError33 = false;
                var _iteratorError33 = undefined;

                try {
                  for (var _iterator33 = expression[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
                    var item = _step33.value;

                    // Check for a spread expression
                    if (item && item.__symbolic === 'spread') {
                      // We call with references as 0 because we require the actual value and cannot
                      // tolerate a reference here.
                      var spreadArray = simplifyEagerly(item.expression);

                      if (Array.isArray(spreadArray)) {
                        var _iteratorNormalCompletion34 = true;
                        var _didIteratorError34 = false;
                        var _iteratorError34 = undefined;

                        try {
                          for (var _iterator34 = spreadArray[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
                            var spreadItem = _step34.value;

                            _result2.push(spreadItem);
                          }
                        } catch (err) {
                          _didIteratorError34 = true;
                          _iteratorError34 = err;
                        } finally {
                          try {
                            if (!_iteratorNormalCompletion34 && _iterator34.return != null) {
                              _iterator34.return();
                            }
                          } finally {
                            if (_didIteratorError34) {
                              throw _iteratorError34;
                            }
                          }
                        }

                        continue;
                      }
                    }

                    var _value7 = simplify(item);

                    if (shouldIgnore(_value7)) {
                      continue;
                    }

                    _result2.push(_value7);
                  }
                } catch (err) {
                  _didIteratorError33 = true;
                  _iteratorError33 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion33 && _iterator33.return != null) {
                      _iterator33.return();
                    }
                  } finally {
                    if (_didIteratorError33) {
                      throw _iteratorError33;
                    }
                  }
                }

                return _result2;
              }

              if (expression instanceof StaticSymbol) {
                // Stop simplification at builtin symbols or if we are in a reference context and
                // the symbol doesn't have members.
                if (expression === self.injectionToken || self.conversionMap.has(expression) || references > 0 && !expression.members.length) {
                  return expression;
                } else {
                  var staticSymbol = expression;
                  var declarationValue = resolveReferenceValue(staticSymbol);

                  if (declarationValue != null) {
                    return simplifyNested(staticSymbol, declarationValue);
                  } else {
                    return staticSymbol;
                  }
                }
              }

              if (expression) {
                if (expression['__symbolic']) {
                  var _staticSymbol;

                  switch (expression['__symbolic']) {
                    case 'binop':
                      var left = simplify(expression['left']);
                      if (shouldIgnore(left)) return left;
                      var right = simplify(expression['right']);
                      if (shouldIgnore(right)) return right;

                      switch (expression['operator']) {
                        case '&&':
                          return left && right;

                        case '||':
                          return left || right;

                        case '|':
                          return left | right;

                        case '^':
                          return left ^ right;

                        case '&':
                          return left & right;

                        case '==':
                          return left == right;

                        case '!=':
                          return left != right;

                        case '===':
                          return left === right;

                        case '!==':
                          return left !== right;

                        case '<':
                          return left < right;

                        case '>':
                          return left > right;

                        case '<=':
                          return left <= right;

                        case '>=':
                          return left >= right;

                        case '<<':
                          return left << right;

                        case '>>':
                          return left >> right;

                        case '+':
                          return left + right;

                        case '-':
                          return left - right;

                        case '*':
                          return left * right;

                        case '/':
                          return left / right;

                        case '%':
                          return left % right;
                      }

                      return null;

                    case 'if':
                      var condition = simplify(expression['condition']);
                      return condition ? simplify(expression['thenExpression']) : simplify(expression['elseExpression']);

                    case 'pre':
                      var operand = simplify(expression['operand']);
                      if (shouldIgnore(operand)) return operand;

                      switch (expression['operator']) {
                        case '+':
                          return operand;

                        case '-':
                          return -operand;

                        case '!':
                          return !operand;

                        case '~':
                          return ~operand;
                      }

                      return null;

                    case 'index':
                      var indexTarget = simplifyEagerly(expression['expression']);
                      var index = simplifyEagerly(expression['index']);
                      if (indexTarget && isPrimitive(index)) return indexTarget[index];
                      return null;

                    case 'select':
                      var member = expression['member'];
                      var selectContext = context;
                      var selectTarget = simplify(expression['expression']);

                      if (selectTarget instanceof StaticSymbol) {
                        var members = selectTarget.members.concat(member);
                        selectContext = self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);

                        var _declarationValue = resolveReferenceValue(selectContext);

                        if (_declarationValue != null) {
                          return simplifyNested(selectContext, _declarationValue);
                        } else {
                          return selectContext;
                        }
                      }

                      if (selectTarget && isPrimitive(member)) return simplifyNested(selectContext, selectTarget[member]);
                      return null;

                    case 'reference':
                      // Note: This only has to deal with variable references, as symbol references have
                      // been converted into 'resolved'
                      // in the StaticSymbolResolver.
                      var name = expression['name'];
                      var localValue = scope.resolve(name);

                      if (localValue != BindingScope$1.missing) {
                        return localValue;
                      }

                      break;

                    case 'resolved':
                      try {
                        return simplify(expression.symbol);
                      } catch (e) {
                        // If an error is reported evaluating the symbol record the position of the
                        // reference in the error so it can
                        // be reported in the error message generated from the exception.
                        if (isMetadataError(e) && expression.fileName != null && expression.line != null && expression.character != null) {
                          e.position = {
                            fileName: expression.fileName,
                            line: expression.line,
                            column: expression.character
                          };
                        }

                        throw e;
                      }

                    case 'class':
                      return context;

                    case 'function':
                      return context;

                    case 'new':
                    case 'call':
                      // Determine if the function is a built-in conversion
                      _staticSymbol = simplifyInContext(context, expression['expression'], depth + 1,
                      /* references */
                      0);

                      if (_staticSymbol instanceof StaticSymbol) {
                        if (_staticSymbol === self.injectionToken || _staticSymbol === self.opaqueToken) {
                          // if somebody calls new InjectionToken, don't create an InjectionToken,
                          // but rather return the symbol to which the InjectionToken is assigned to.
                          // OpaqueToken is supported too as it is required by the language service to
                          // support v4 and prior versions of Angular.
                          return context;
                        }

                        var argExpressions = expression['arguments'] || [];
                        var converter = self.conversionMap.get(_staticSymbol);

                        if (converter) {
                          var args = argExpressions.map(function (arg) {
                            return simplifyNested(context, arg);
                          }).map(function (arg) {
                            return shouldIgnore(arg) ? undefined : arg;
                          });
                          return converter(context, args);
                        } else {
                          // Determine if the function is one we can simplify.
                          var targetFunction = resolveReferenceValue(_staticSymbol);
                          return simplifyCall(_staticSymbol, targetFunction, argExpressions, expression['expression']);
                        }
                      }

                      return IGNORE;

                    case 'error':
                      var message = expression.message;

                      if (expression['line'] != null) {
                        self.error({
                          message: message,
                          context: expression.context,
                          value: expression,
                          position: {
                            fileName: expression['fileName'],
                            line: expression['line'],
                            column: expression['character']
                          }
                        }, context);
                      } else {
                        self.error({
                          message: message,
                          context: expression.context
                        }, context);
                      }

                      return IGNORE;

                    case 'ignore':
                      return expression;
                  }

                  return null;
                }

                return mapStringMap(expression, function (value, name) {
                  if (REFERENCE_SET.has(name)) {
                    if (name === USE_VALUE$1 && PROVIDE in expression) {
                      // If this is a provider expression, check for special tokens that need the value
                      // during analysis.
                      var provide = simplify(expression.provide);

                      if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {
                        return simplify(value);
                      }
                    }

                    return simplifyLazily(value);
                  }

                  return simplify(value);
                });
              }

              return IGNORE;
            }

            return simplify(value);
          }

          var result;

          try {
            result = simplifyInContext(context, value, 0, lazy ? 1 : 0);
          } catch (e) {
            if (this.errorRecorder) {
              this.reportError(e, context);
            } else {
              throw formatMetadataError(e, context);
            }
          }

          if (shouldIgnore(result)) {
            return undefined;
          }

          return result;
        }
      }, {
        key: "getTypeMetadata",
        value: function getTypeMetadata(type) {
          var resolvedSymbol = this.symbolResolver.resolveSymbol(type);
          return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata : {
            __symbolic: 'class'
          };
        }
      }, {
        key: "reportError",
        value: function reportError(error, context, path) {
          if (this.errorRecorder) {
            this.errorRecorder(formatMetadataError(error, context), context && context.filePath || path);
          } else {
            throw error;
          }
        }
      }, {
        key: "error",
        value: function error(_ref45, reportingContext) {
          var message = _ref45.message,
              summary = _ref45.summary,
              advise = _ref45.advise,
              position = _ref45.position,
              context = _ref45.context,
              value = _ref45.value,
              symbol = _ref45.symbol,
              chain = _ref45.chain;
          this.reportError(metadataError(message, summary, advise, position, symbol, context, chain), reportingContext);
        }
      }]);

      return StaticReflector;
    }();

    var METADATA_ERROR = 'ngMetadataError';

    function metadataError(message, summary, advise, position, symbol, context, chain) {
      var error = syntaxError(message);
      error[METADATA_ERROR] = true;
      if (advise) error.advise = advise;
      if (position) error.position = position;
      if (summary) error.summary = summary;
      if (context) error.context = context;
      if (chain) error.chain = chain;
      if (symbol) error.symbol = symbol;
      return error;
    }

    function isMetadataError(error) {
      return !!error[METADATA_ERROR];
    }

    var REFERENCE_TO_NONEXPORTED_CLASS = 'Reference to non-exported class';
    var VARIABLE_NOT_INITIALIZED = 'Variable not initialized';
    var DESTRUCTURE_NOT_SUPPORTED = 'Destructuring not supported';
    var COULD_NOT_RESOLVE_TYPE = 'Could not resolve type';
    var FUNCTION_CALL_NOT_SUPPORTED = 'Function call not supported';
    var REFERENCE_TO_LOCAL_SYMBOL = 'Reference to a local symbol';
    var LAMBDA_NOT_SUPPORTED = 'Lambda not supported';

    function expandedMessage(message, context) {
      switch (message) {
        case REFERENCE_TO_NONEXPORTED_CLASS:
          if (context && context.className) {
            return "References to a non-exported class are not supported in decorators but ".concat(context.className, " was referenced.");
          }

          break;

        case VARIABLE_NOT_INITIALIZED:
          return 'Only initialized variables and constants can be referenced in decorators because the value of this variable is needed by the template compiler';

        case DESTRUCTURE_NOT_SUPPORTED:
          return 'Referencing an exported destructured variable or constant is not supported in decorators and this value is needed by the template compiler';

        case COULD_NOT_RESOLVE_TYPE:
          if (context && context.typeName) {
            return "Could not resolve type ".concat(context.typeName);
          }

          break;

        case FUNCTION_CALL_NOT_SUPPORTED:
          if (context && context.name) {
            return "Function calls are not supported in decorators but '".concat(context.name, "' was called");
          }

          return 'Function calls are not supported in decorators';

        case REFERENCE_TO_LOCAL_SYMBOL:
          if (context && context.name) {
            return "Reference to a local (non-exported) symbols are not supported in decorators but '".concat(context.name, "' was referenced");
          }

          break;

        case LAMBDA_NOT_SUPPORTED:
          return "Function expressions are not supported in decorators";
      }

      return message;
    }

    function messageAdvise(message, context) {
      switch (message) {
        case REFERENCE_TO_NONEXPORTED_CLASS:
          if (context && context.className) {
            return "Consider exporting '".concat(context.className, "'");
          }

          break;

        case DESTRUCTURE_NOT_SUPPORTED:
          return 'Consider simplifying to avoid destructuring';

        case REFERENCE_TO_LOCAL_SYMBOL:
          if (context && context.name) {
            return "Consider exporting '".concat(context.name, "'");
          }

          break;

        case LAMBDA_NOT_SUPPORTED:
          return "Consider changing the function expression into an exported function";
      }

      return undefined;
    }

    function errorSummary(error) {
      if (error.summary) {
        return error.summary;
      }

      switch (error.message) {
        case REFERENCE_TO_NONEXPORTED_CLASS:
          if (error.context && error.context.className) {
            return "references non-exported class ".concat(error.context.className);
          }

          break;

        case VARIABLE_NOT_INITIALIZED:
          return 'is not initialized';

        case DESTRUCTURE_NOT_SUPPORTED:
          return 'is a destructured variable';

        case COULD_NOT_RESOLVE_TYPE:
          return 'could not be resolved';

        case FUNCTION_CALL_NOT_SUPPORTED:
          if (error.context && error.context.name) {
            return "calls '".concat(error.context.name, "'");
          }

          return "calls a function";

        case REFERENCE_TO_LOCAL_SYMBOL:
          if (error.context && error.context.name) {
            return "references local variable ".concat(error.context.name);
          }

          return "references a local variable";
      }

      return 'contains the error';
    }

    function mapStringMap(input, transform) {
      if (!input) return {};
      var result = {};
      Object.keys(input).forEach(function (key) {
        var value = transform(input[key], key);

        if (!shouldIgnore(value)) {
          if (HIDDEN_KEY.test(key)) {
            Object.defineProperty(result, key, {
              enumerable: false,
              configurable: true,
              value: value
            });
          } else {
            result[key] = value;
          }
        }
      });
      return result;
    }

    function isPrimitive(o) {
      return o === null || typeof o !== 'function' && typeof o !== 'object';
    }

    var BindingScope$1 =
    /*#__PURE__*/
    function () {
      function BindingScope$1() {
        _classCallCheck(this, BindingScope$1);
      }

      _createClass(BindingScope$1, null, [{
        key: "build",
        value: function build() {
          var current = new Map();
          return {
            define: function define(name, value) {
              current.set(name, value);
              return this;
            },
            done: function done() {
              return current.size > 0 ? new PopulatedScope(current) : BindingScope$1.empty;
            }
          };
        }
      }]);

      return BindingScope$1;
    }();

    BindingScope$1.missing = {};
    BindingScope$1.empty = {
      resolve: function resolve(name) {
        return BindingScope$1.missing;
      }
    };

    var PopulatedScope =
    /*#__PURE__*/
    function (_BindingScope$) {
      _inherits(PopulatedScope, _BindingScope$);

      function PopulatedScope(bindings) {
        var _this283;

        _classCallCheck(this, PopulatedScope);

        _this283 = _possibleConstructorReturn(this, _getPrototypeOf(PopulatedScope).call(this));
        _this283.bindings = bindings;
        return _this283;
      }

      _createClass(PopulatedScope, [{
        key: "resolve",
        value: function resolve(name) {
          return this.bindings.has(name) ? this.bindings.get(name) : BindingScope$1.missing;
        }
      }]);

      return PopulatedScope;
    }(BindingScope$1);

    function formatMetadataMessageChain(chain, advise) {
      var expanded = expandedMessage(chain.message, chain.context);
      var nesting = chain.symbol ? " in '".concat(chain.symbol.name, "'") : '';
      var message = "".concat(expanded).concat(nesting);
      var position = chain.position;
      var next = chain.next ? formatMetadataMessageChain(chain.next, advise) : advise ? {
        message: advise
      } : undefined;
      return {
        message: message,
        position: position,
        next: next ? [next] : undefined
      };
    }

    function formatMetadataError(e, context) {
      if (isMetadataError(e)) {
        // Produce a formatted version of the and leaving enough information in the original error
        // to recover the formatting information to eventually produce a diagnostic error message.
        var position = e.position;
        var chain = {
          message: "Error during template compile of '".concat(context.name, "'"),
          position: position,
          next: {
            message: e.message,
            next: e.chain,
            context: e.context,
            symbol: e.symbol
          }
        };
        var advise = e.advise || messageAdvise(e.message, e.context);
        return formattedError(formatMetadataMessageChain(chain, advise));
      }

      return e;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var AotSummaryResolver =
    /*#__PURE__*/
    function () {
      function AotSummaryResolver(host, staticSymbolCache) {
        _classCallCheck(this, AotSummaryResolver);

        this.host = host;
        this.staticSymbolCache = staticSymbolCache; // Note: this will only contain StaticSymbols without members!

        this.summaryCache = new Map();
        this.loadedFilePaths = new Map(); // Note: this will only contain StaticSymbols without members!

        this.importAs = new Map();
        this.knownFileNameToModuleNames = new Map();
      }

      _createClass(AotSummaryResolver, [{
        key: "isLibraryFile",
        value: function isLibraryFile(filePath) {
          // Note: We need to strip the .ngfactory. file path,
          // so this method also works for generated files
          // (for which host.isSourceFile will always return false).
          return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));
        }
      }, {
        key: "toSummaryFileName",
        value: function toSummaryFileName(filePath, referringSrcFileName) {
          return this.host.toSummaryFileName(filePath, referringSrcFileName);
        }
      }, {
        key: "fromSummaryFileName",
        value: function fromSummaryFileName(fileName, referringLibFileName) {
          return this.host.fromSummaryFileName(fileName, referringLibFileName);
        }
      }, {
        key: "resolveSummary",
        value: function resolveSummary(staticSymbol) {
          var rootSymbol = staticSymbol.members.length ? this.staticSymbolCache.get(staticSymbol.filePath, staticSymbol.name) : staticSymbol;
          var summary = this.summaryCache.get(rootSymbol);

          if (!summary) {
            this._loadSummaryFile(staticSymbol.filePath);

            summary = this.summaryCache.get(staticSymbol);
          }

          return rootSymbol === staticSymbol && summary || null;
        }
      }, {
        key: "getSymbolsOf",
        value: function getSymbolsOf(filePath) {
          if (this._loadSummaryFile(filePath)) {
            return Array.from(this.summaryCache.keys()).filter(function (symbol) {
              return symbol.filePath === filePath;
            });
          }

          return null;
        }
      }, {
        key: "getImportAs",
        value: function getImportAs(staticSymbol) {
          staticSymbol.assertNoMembers();
          return this.importAs.get(staticSymbol);
        }
        /**
         * Converts a file path to a module name that can be used as an `import`.
         */

      }, {
        key: "getKnownModuleName",
        value: function getKnownModuleName(importedFilePath) {
          return this.knownFileNameToModuleNames.get(importedFilePath) || null;
        }
      }, {
        key: "addSummary",
        value: function addSummary(summary) {
          this.summaryCache.set(summary.symbol, summary);
        }
      }, {
        key: "_loadSummaryFile",
        value: function _loadSummaryFile(filePath) {
          var _this284 = this;

          var hasSummary = this.loadedFilePaths.get(filePath);

          if (hasSummary != null) {
            return hasSummary;
          }

          var json = null;

          if (this.isLibraryFile(filePath)) {
            var summaryFilePath = summaryFileName(filePath);

            try {
              json = this.host.loadSummary(summaryFilePath);
            } catch (e) {
              console.error("Error loading summary file ".concat(summaryFilePath));
              throw e;
            }
          }

          hasSummary = json != null;
          this.loadedFilePaths.set(filePath, hasSummary);

          if (json) {
            var _deserializeSummaries = deserializeSummaries(this.staticSymbolCache, this, filePath, json),
                moduleName = _deserializeSummaries.moduleName,
                summaries = _deserializeSummaries.summaries,
                importAs = _deserializeSummaries.importAs;

            summaries.forEach(function (summary) {
              return _this284.summaryCache.set(summary.symbol, summary);
            });

            if (moduleName) {
              this.knownFileNameToModuleNames.set(filePath, moduleName);
            }

            importAs.forEach(function (importAs) {
              _this284.importAs.set(importAs.symbol, importAs.importAs);
            });
          }

          return hasSummary;
        }
      }]);

      return AotSummaryResolver;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function createAotUrlResolver(host) {
      return {
        resolve: function resolve(basePath, url) {
          var filePath = host.resourceNameToFileName(url, basePath);

          if (!filePath) {
            throw syntaxError("Couldn't resolve resource ".concat(url, " from ").concat(basePath));
          }

          return filePath;
        }
      };
    }
    /**
     * Creates a new AotCompiler based on options and a host.
     */


    function createAotCompiler(compilerHost, options, errorCollector) {
      var translations = options.translations || '';
      var urlResolver = createAotUrlResolver(compilerHost);
      var symbolCache = new StaticSymbolCache();
      var summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);
      var symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);
      var staticReflector = new StaticReflector(summaryResolver, symbolResolver, [], [], errorCollector);
      var htmlParser;

      if (!!options.enableIvy) {
        // Ivy handles i18n at the compiler level so we must use a regular parser
        htmlParser = new HtmlParser();
      } else {
        htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, options.missingTranslation, console);
      }

      var config = new CompilerConfig({
        defaultEncapsulation: ViewEncapsulation.Emulated,
        useJit: false,
        missingTranslation: options.missingTranslation,
        preserveWhitespaces: options.preserveWhitespaces,
        strictInjectionParameters: options.strictInjectionParameters
      });
      var normalizer = new DirectiveNormalizer({
        get: function get(url) {
          return compilerHost.loadResource(url);
        }
      }, urlResolver, htmlParser, config);
      var expressionParser = new Parser$1(new Lexer());
      var elementSchemaRegistry = new DomElementSchemaRegistry();
      var tmplParser = new TemplateParser(config, staticReflector, expressionParser, elementSchemaRegistry, htmlParser, console, []);
      var resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector, errorCollector); // TODO(vicb): do not pass options.i18nFormat here

      var viewCompiler = new ViewCompiler(staticReflector);
      var typeCheckCompiler = new TypeCheckCompiler(options, staticReflector);
      var compiler = new AotCompiler(config, options, compilerHost, staticReflector, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, typeCheckCompiler, new NgModuleCompiler(staticReflector), new InjectableCompiler(staticReflector, !!options.enableIvy), new TypeScriptEmitter(), summaryResolver, symbolResolver);
      return {
        compiler: compiler,
        reflector: staticReflector
      };
    }

    var SummaryResolver = function SummaryResolver() {
      _classCallCheck(this, SummaryResolver);
    };

    var JitSummaryResolver =
    /*#__PURE__*/
    function () {
      function JitSummaryResolver() {
        _classCallCheck(this, JitSummaryResolver);

        this._summaries = new Map();
      }

      _createClass(JitSummaryResolver, [{
        key: "isLibraryFile",
        value: function isLibraryFile() {
          return false;
        }
      }, {
        key: "toSummaryFileName",
        value: function toSummaryFileName(fileName) {
          return fileName;
        }
      }, {
        key: "fromSummaryFileName",
        value: function fromSummaryFileName(fileName) {
          return fileName;
        }
      }, {
        key: "resolveSummary",
        value: function resolveSummary(reference) {
          return this._summaries.get(reference) || null;
        }
      }, {
        key: "getSymbolsOf",
        value: function getSymbolsOf() {
          return [];
        }
      }, {
        key: "getImportAs",
        value: function getImportAs(reference) {
          return reference;
        }
      }, {
        key: "getKnownModuleName",
        value: function getKnownModuleName(fileName) {
          return null;
        }
      }, {
        key: "addSummary",
        value: function addSummary(summary) {
          this._summaries.set(summary.symbol, summary);
        }
      }]);

      return JitSummaryResolver;
    }();

    function interpretStatements(statements, reflector) {
      var ctx = new _ExecutionContext(null, null, null, new Map());
      var visitor = new StatementInterpreter(reflector);
      visitor.visitAllStatements(statements, ctx);
      var result = {};
      ctx.exports.forEach(function (exportName) {
        result[exportName] = ctx.vars.get(exportName);
      });
      return result;
    }

    function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
      var childCtx = ctx.createChildWihtLocalVars();

      for (var i = 0; i < varNames.length; i++) {
        childCtx.vars.set(varNames[i], varValues[i]);
      }

      var result = visitor.visitAllStatements(statements, childCtx);
      return result ? result.value : null;
    }

    var _ExecutionContext =
    /*#__PURE__*/
    function () {
      function _ExecutionContext(parent, instance, className, vars) {
        _classCallCheck(this, _ExecutionContext);

        this.parent = parent;
        this.instance = instance;
        this.className = className;
        this.vars = vars;
        this.exports = [];
      }

      _createClass(_ExecutionContext, [{
        key: "createChildWihtLocalVars",
        value: function createChildWihtLocalVars() {
          return new _ExecutionContext(this, this.instance, this.className, new Map());
        }
      }]);

      return _ExecutionContext;
    }();

    var ReturnValue = function ReturnValue(value) {
      _classCallCheck(this, ReturnValue);

      this.value = value;
    };

    function createDynamicClass(_classStmt, _ctx, _visitor) {
      var propertyDescriptors = {};

      _classStmt.getters.forEach(function (getter) {
        // Note: use `function` instead of arrow function to capture `this`
        propertyDescriptors[getter.name] = {
          configurable: false,
          get: function get() {
            var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
            return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);
          }
        };
      });

      _classStmt.methods.forEach(function (method) {
        var paramNames = method.params.map(function (param) {
          return param.name;
        }); // Note: use `function` instead of arrow function to capture `this`

        propertyDescriptors[method.name] = {
          writable: false,
          configurable: false,
          value: function value() {
            var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);

            for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
              args[_key6] = arguments[_key6];
            }

            return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);
          }
        };
      });

      var ctorParamNames = _classStmt.constructorMethod.params.map(function (param) {
        return param.name;
      }); // Note: use `function` instead of arrow function to capture `this`


      var ctor = function ctor() {
        var _this285 = this;

        var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);

        _classStmt.fields.forEach(function (field) {
          _this285[field.name] = undefined;
        });

        for (var _len6 = arguments.length, args = new Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {
          args[_key7] = arguments[_key7];
        }

        _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);
      };

      var superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;
      ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);
      return ctor;
    }

    var StatementInterpreter =
    /*#__PURE__*/
    function () {
      function StatementInterpreter(reflector) {
        _classCallCheck(this, StatementInterpreter);

        this.reflector = reflector;
      }

      _createClass(StatementInterpreter, [{
        key: "debugAst",
        value: function debugAst(ast) {
          return debugOutputAstAsTypeScript(ast);
        }
      }, {
        key: "visitDeclareVarStmt",
        value: function visitDeclareVarStmt(stmt, ctx) {
          var initialValue = stmt.value ? stmt.value.visitExpression(this, ctx) : undefined;
          ctx.vars.set(stmt.name, initialValue);

          if (stmt.hasModifier(StmtModifier.Exported)) {
            ctx.exports.push(stmt.name);
          }

          return null;
        }
      }, {
        key: "visitWriteVarExpr",
        value: function visitWriteVarExpr(expr, ctx) {
          var value = expr.value.visitExpression(this, ctx);
          var currCtx = ctx;

          while (currCtx != null) {
            if (currCtx.vars.has(expr.name)) {
              currCtx.vars.set(expr.name, value);
              return value;
            }

            currCtx = currCtx.parent;
          }

          throw new Error("Not declared variable ".concat(expr.name));
        }
      }, {
        key: "visitWrappedNodeExpr",
        value: function visitWrappedNodeExpr(ast, ctx) {
          throw new Error('Cannot interpret a WrappedNodeExpr.');
        }
      }, {
        key: "visitTypeofExpr",
        value: function visitTypeofExpr(ast, ctx) {
          throw new Error('Cannot interpret a TypeofExpr');
        }
      }, {
        key: "visitReadVarExpr",
        value: function visitReadVarExpr(ast, ctx) {
          var varName = ast.name;

          if (ast.builtin != null) {
            switch (ast.builtin) {
              case BuiltinVar.Super:
                return Object.getPrototypeOf(ctx.instance);

              case BuiltinVar.This:
                return ctx.instance;

              case BuiltinVar.CatchError:
                varName = CATCH_ERROR_VAR$2;
                break;

              case BuiltinVar.CatchStack:
                varName = CATCH_STACK_VAR$2;
                break;

              default:
                throw new Error("Unknown builtin variable ".concat(ast.builtin));
            }
          }

          var currCtx = ctx;

          while (currCtx != null) {
            if (currCtx.vars.has(varName)) {
              return currCtx.vars.get(varName);
            }

            currCtx = currCtx.parent;
          }

          throw new Error("Not declared variable ".concat(varName));
        }
      }, {
        key: "visitWriteKeyExpr",
        value: function visitWriteKeyExpr(expr, ctx) {
          var receiver = expr.receiver.visitExpression(this, ctx);
          var index = expr.index.visitExpression(this, ctx);
          var value = expr.value.visitExpression(this, ctx);
          receiver[index] = value;
          return value;
        }
      }, {
        key: "visitWritePropExpr",
        value: function visitWritePropExpr(expr, ctx) {
          var receiver = expr.receiver.visitExpression(this, ctx);
          var value = expr.value.visitExpression(this, ctx);
          receiver[expr.name] = value;
          return value;
        }
      }, {
        key: "visitInvokeMethodExpr",
        value: function visitInvokeMethodExpr(expr, ctx) {
          var receiver = expr.receiver.visitExpression(this, ctx);
          var args = this.visitAllExpressions(expr.args, ctx);
          var result;

          if (expr.builtin != null) {
            switch (expr.builtin) {
              case BuiltinMethod.ConcatArray:
                result = receiver.concat.apply(receiver, _toConsumableArray(args));
                break;

              case BuiltinMethod.SubscribeObservable:
                result = receiver.subscribe({
                  next: args[0]
                });
                break;

              case BuiltinMethod.Bind:
                result = receiver.bind.apply(receiver, _toConsumableArray(args));
                break;

              default:
                throw new Error("Unknown builtin method ".concat(expr.builtin));
            }
          } else {
            result = receiver[expr.name].apply(receiver, args);
          }

          return result;
        }
      }, {
        key: "visitInvokeFunctionExpr",
        value: function visitInvokeFunctionExpr(stmt, ctx) {
          var args = this.visitAllExpressions(stmt.args, ctx);
          var fnExpr = stmt.fn;

          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
            ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);
            return null;
          } else {
            var _fn = stmt.fn.visitExpression(this, ctx);

            return _fn.apply(null, args);
          }
        }
      }, {
        key: "visitReturnStmt",
        value: function visitReturnStmt(stmt, ctx) {
          return new ReturnValue(stmt.value.visitExpression(this, ctx));
        }
      }, {
        key: "visitDeclareClassStmt",
        value: function visitDeclareClassStmt(stmt, ctx) {
          var clazz = createDynamicClass(stmt, ctx, this);
          ctx.vars.set(stmt.name, clazz);

          if (stmt.hasModifier(StmtModifier.Exported)) {
            ctx.exports.push(stmt.name);
          }

          return null;
        }
      }, {
        key: "visitExpressionStmt",
        value: function visitExpressionStmt(stmt, ctx) {
          return stmt.expr.visitExpression(this, ctx);
        }
      }, {
        key: "visitIfStmt",
        value: function visitIfStmt(stmt, ctx) {
          var condition = stmt.condition.visitExpression(this, ctx);

          if (condition) {
            return this.visitAllStatements(stmt.trueCase, ctx);
          } else if (stmt.falseCase != null) {
            return this.visitAllStatements(stmt.falseCase, ctx);
          }

          return null;
        }
      }, {
        key: "visitTryCatchStmt",
        value: function visitTryCatchStmt(stmt, ctx) {
          try {
            return this.visitAllStatements(stmt.bodyStmts, ctx);
          } catch (e) {
            var childCtx = ctx.createChildWihtLocalVars();
            childCtx.vars.set(CATCH_ERROR_VAR$2, e);
            childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);
            return this.visitAllStatements(stmt.catchStmts, childCtx);
          }
        }
      }, {
        key: "visitThrowStmt",
        value: function visitThrowStmt(stmt, ctx) {
          throw stmt.error.visitExpression(this, ctx);
        }
      }, {
        key: "visitCommentStmt",
        value: function visitCommentStmt(stmt, context) {
          return null;
        }
      }, {
        key: "visitJSDocCommentStmt",
        value: function visitJSDocCommentStmt(stmt, context) {
          return null;
        }
      }, {
        key: "visitInstantiateExpr",
        value: function visitInstantiateExpr(ast, ctx) {
          var args = this.visitAllExpressions(ast.args, ctx);
          var clazz = ast.classExpr.visitExpression(this, ctx);
          return _construct(clazz, _toConsumableArray(args));
        }
      }, {
        key: "visitLiteralExpr",
        value: function visitLiteralExpr(ast, ctx) {
          return ast.value;
        }
      }, {
        key: "visitLocalizedString",
        value: function visitLocalizedString(ast, context) {
          return null;
        }
      }, {
        key: "visitExternalExpr",
        value: function visitExternalExpr(ast, ctx) {
          return this.reflector.resolveExternalReference(ast.value);
        }
      }, {
        key: "visitConditionalExpr",
        value: function visitConditionalExpr(ast, ctx) {
          if (ast.condition.visitExpression(this, ctx)) {
            return ast.trueCase.visitExpression(this, ctx);
          } else if (ast.falseCase != null) {
            return ast.falseCase.visitExpression(this, ctx);
          }

          return null;
        }
      }, {
        key: "visitNotExpr",
        value: function visitNotExpr(ast, ctx) {
          return !ast.condition.visitExpression(this, ctx);
        }
      }, {
        key: "visitAssertNotNullExpr",
        value: function visitAssertNotNullExpr(ast, ctx) {
          return ast.condition.visitExpression(this, ctx);
        }
      }, {
        key: "visitCastExpr",
        value: function visitCastExpr(ast, ctx) {
          return ast.value.visitExpression(this, ctx);
        }
      }, {
        key: "visitFunctionExpr",
        value: function visitFunctionExpr(ast, ctx) {
          var paramNames = ast.params.map(function (param) {
            return param.name;
          });
          return _declareFn(paramNames, ast.statements, ctx, this);
        }
      }, {
        key: "visitDeclareFunctionStmt",
        value: function visitDeclareFunctionStmt(stmt, ctx) {
          var paramNames = stmt.params.map(function (param) {
            return param.name;
          });
          ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));

          if (stmt.hasModifier(StmtModifier.Exported)) {
            ctx.exports.push(stmt.name);
          }

          return null;
        }
      }, {
        key: "visitBinaryOperatorExpr",
        value: function visitBinaryOperatorExpr(ast, ctx) {
          var _this286 = this;

          var lhs = function lhs() {
            return ast.lhs.visitExpression(_this286, ctx);
          };

          var rhs = function rhs() {
            return ast.rhs.visitExpression(_this286, ctx);
          };

          switch (ast.operator) {
            case BinaryOperator.Equals:
              return lhs() == rhs();

            case BinaryOperator.Identical:
              return lhs() === rhs();

            case BinaryOperator.NotEquals:
              return lhs() != rhs();

            case BinaryOperator.NotIdentical:
              return lhs() !== rhs();

            case BinaryOperator.And:
              return lhs() && rhs();

            case BinaryOperator.Or:
              return lhs() || rhs();

            case BinaryOperator.Plus:
              return lhs() + rhs();

            case BinaryOperator.Minus:
              return lhs() - rhs();

            case BinaryOperator.Divide:
              return lhs() / rhs();

            case BinaryOperator.Multiply:
              return lhs() * rhs();

            case BinaryOperator.Modulo:
              return lhs() % rhs();

            case BinaryOperator.Lower:
              return lhs() < rhs();

            case BinaryOperator.LowerEquals:
              return lhs() <= rhs();

            case BinaryOperator.Bigger:
              return lhs() > rhs();

            case BinaryOperator.BiggerEquals:
              return lhs() >= rhs();

            default:
              throw new Error("Unknown operator ".concat(ast.operator));
          }
        }
      }, {
        key: "visitReadPropExpr",
        value: function visitReadPropExpr(ast, ctx) {
          var result;
          var receiver = ast.receiver.visitExpression(this, ctx);
          result = receiver[ast.name];
          return result;
        }
      }, {
        key: "visitReadKeyExpr",
        value: function visitReadKeyExpr(ast, ctx) {
          var receiver = ast.receiver.visitExpression(this, ctx);
          var prop = ast.index.visitExpression(this, ctx);
          return receiver[prop];
        }
      }, {
        key: "visitLiteralArrayExpr",
        value: function visitLiteralArrayExpr(ast, ctx) {
          return this.visitAllExpressions(ast.entries, ctx);
        }
      }, {
        key: "visitLiteralMapExpr",
        value: function visitLiteralMapExpr(ast, ctx) {
          var _this287 = this;

          var result = {};
          ast.entries.forEach(function (entry) {
            return result[entry.key] = entry.value.visitExpression(_this287, ctx);
          });
          return result;
        }
      }, {
        key: "visitCommaExpr",
        value: function visitCommaExpr(ast, context) {
          var values = this.visitAllExpressions(ast.parts, context);
          return values[values.length - 1];
        }
      }, {
        key: "visitAllExpressions",
        value: function visitAllExpressions(expressions, ctx) {
          var _this288 = this;

          return expressions.map(function (expr) {
            return expr.visitExpression(_this288, ctx);
          });
        }
      }, {
        key: "visitAllStatements",
        value: function visitAllStatements(statements, ctx) {
          for (var i = 0; i < statements.length; i++) {
            var stmt = statements[i];
            var val = stmt.visitStatement(this, ctx);

            if (val instanceof ReturnValue) {
              return val;
            }
          }

          return null;
        }
      }]);

      return StatementInterpreter;
    }();

    function _declareFn(varNames, statements, ctx, visitor) {
      return function () {
        for (var _len7 = arguments.length, args = new Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {
          args[_key8] = arguments[_key8];
        }

        return _executeFunctionStatements(varNames, args, statements, ctx, visitor);
      };
    }

    var CATCH_ERROR_VAR$2 = 'error';
    var CATCH_STACK_VAR$2 = 'stack';
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * An internal module of the Angular compiler that begins with component types,
     * extracts templates, and eventually produces a compiled version of the component
     * ready for linking into an application.
     *
     * @security  When compiling templates at runtime, you must ensure that the entire template comes
     * from a trusted source. Attacker-controlled data introduced by a template could expose your
     * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).
     */

    var JitCompiler =
    /*#__PURE__*/
    function () {
      function JitCompiler(_metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _reflector, _jitEvaluator, _compilerConfig, _console, getExtraNgModuleProviders) {
        _classCallCheck(this, JitCompiler);

        this._metadataResolver = _metadataResolver;
        this._templateParser = _templateParser;
        this._styleCompiler = _styleCompiler;
        this._viewCompiler = _viewCompiler;
        this._ngModuleCompiler = _ngModuleCompiler;
        this._summaryResolver = _summaryResolver;
        this._reflector = _reflector;
        this._jitEvaluator = _jitEvaluator;
        this._compilerConfig = _compilerConfig;
        this._console = _console;
        this.getExtraNgModuleProviders = getExtraNgModuleProviders;
        this._compiledTemplateCache = new Map();
        this._compiledHostTemplateCache = new Map();
        this._compiledDirectiveWrapperCache = new Map();
        this._compiledNgModuleCache = new Map();
        this._sharedStylesheetCount = 0;
        this._addedAotSummaries = new Set();
      }

      _createClass(JitCompiler, [{
        key: "compileModuleSync",
        value: function compileModuleSync(moduleType) {
          return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));
        }
      }, {
        key: "compileModuleAsync",
        value: function compileModuleAsync(moduleType) {
          return Promise.resolve(this._compileModuleAndComponents(moduleType, false));
        }
      }, {
        key: "compileModuleAndAllComponentsSync",
        value: function compileModuleAndAllComponentsSync(moduleType) {
          return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));
        }
      }, {
        key: "compileModuleAndAllComponentsAsync",
        value: function compileModuleAndAllComponentsAsync(moduleType) {
          return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));
        }
      }, {
        key: "getComponentFactory",
        value: function getComponentFactory(component) {
          var summary = this._metadataResolver.getDirectiveSummary(component);

          return summary.componentFactory;
        }
      }, {
        key: "loadAotSummaries",
        value: function loadAotSummaries(summaries) {
          this.clearCache();

          this._addAotSummaries(summaries);
        }
      }, {
        key: "_addAotSummaries",
        value: function _addAotSummaries(fn) {
          if (this._addedAotSummaries.has(fn)) {
            return;
          }

          this._addedAotSummaries.add(fn);

          var summaries = fn();

          for (var i = 0; i < summaries.length; i++) {
            var entry = summaries[i];

            if (typeof entry === 'function') {
              this._addAotSummaries(entry);
            } else {
              var summary = entry;

              this._summaryResolver.addSummary({
                symbol: summary.type.reference,
                metadata: null,
                type: summary
              });
            }
          }
        }
      }, {
        key: "hasAotSummary",
        value: function hasAotSummary(ref) {
          return !!this._summaryResolver.resolveSummary(ref);
        }
      }, {
        key: "_filterJitIdentifiers",
        value: function _filterJitIdentifiers(ids) {
          var _this289 = this;

          return ids.map(function (mod) {
            return mod.reference;
          }).filter(function (ref) {
            return !_this289.hasAotSummary(ref);
          });
        }
      }, {
        key: "_compileModuleAndComponents",
        value: function _compileModuleAndComponents(moduleType, isSync) {
          var _this290 = this;

          return SyncAsync.then(this._loadModules(moduleType, isSync), function () {
            _this290._compileComponents(moduleType, null);

            return _this290._compileModule(moduleType);
          });
        }
      }, {
        key: "_compileModuleAndAllComponents",
        value: function _compileModuleAndAllComponents(moduleType, isSync) {
          var _this291 = this;

          return SyncAsync.then(this._loadModules(moduleType, isSync), function () {
            var componentFactories = [];

            _this291._compileComponents(moduleType, componentFactories);

            return {
              ngModuleFactory: _this291._compileModule(moduleType),
              componentFactories: componentFactories
            };
          });
        }
      }, {
        key: "_loadModules",
        value: function _loadModules(mainModule, isSync) {
          var _this292 = this;

          var loading = [];

          var mainNgModule = this._metadataResolver.getNgModuleMetadata(mainModule); // Note: for runtime compilation, we want to transitively compile all modules,
          // so we also need to load the declared directives / pipes for all nested modules.


          this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach(function (nestedNgModule) {
            // getNgModuleMetadata only returns null if the value passed in is not an NgModule
            var moduleMeta = _this292._metadataResolver.getNgModuleMetadata(nestedNgModule);

            _this292._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach(function (ref) {
              var promise = _this292._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);

              if (promise) {
                loading.push(promise);
              }
            });

            _this292._filterJitIdentifiers(moduleMeta.declaredPipes).forEach(function (ref) {
              return _this292._metadataResolver.getOrLoadPipeMetadata(ref);
            });
          });

          return SyncAsync.all(loading);
        }
      }, {
        key: "_compileModule",
        value: function _compileModule(moduleType) {
          var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);

          if (!ngModuleFactory) {
            var moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType); // Always provide a bound Compiler


            var extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);
            var outputCtx = createOutputContext();

            var compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);

            ngModuleFactory = this._interpretOrJit(ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];

            this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);
          }

          return ngModuleFactory;
        }
        /**
         * @internal
         */

      }, {
        key: "_compileComponents",
        value: function _compileComponents(mainModule, allComponentFactories) {
          var _this293 = this;

          var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);

          var moduleByJitDirective = new Map();
          var templates = new Set();

          var transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);

          transJitModules.forEach(function (localMod) {
            var localModuleMeta = _this293._metadataResolver.getNgModuleMetadata(localMod);

            _this293._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {
              moduleByJitDirective.set(dirRef, localModuleMeta);

              var dirMeta = _this293._metadataResolver.getDirectiveMetadata(dirRef);

              if (dirMeta.isComponent) {
                templates.add(_this293._createCompiledTemplate(dirMeta, localModuleMeta));

                if (allComponentFactories) {
                  var template = _this293._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);

                  templates.add(template);
                  allComponentFactories.push(dirMeta.componentFactory);
                }
              }
            });
          });
          transJitModules.forEach(function (localMod) {
            var localModuleMeta = _this293._metadataResolver.getNgModuleMetadata(localMod);

            _this293._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {
              var dirMeta = _this293._metadataResolver.getDirectiveMetadata(dirRef);

              if (dirMeta.isComponent) {
                dirMeta.entryComponents.forEach(function (entryComponentType) {
                  var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);
                  templates.add(_this293._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));
                });
              }
            });

            localModuleMeta.entryComponents.forEach(function (entryComponentType) {
              if (!_this293.hasAotSummary(entryComponentType.componentType)) {
                var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);
                templates.add(_this293._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));
              }
            });
          });
          templates.forEach(function (template) {
            return _this293._compileTemplate(template);
          });
        }
      }, {
        key: "clearCacheFor",
        value: function clearCacheFor(type) {
          this._compiledNgModuleCache.delete(type);

          this._metadataResolver.clearCacheFor(type);

          this._compiledHostTemplateCache.delete(type);

          var compiledTemplate = this._compiledTemplateCache.get(type);

          if (compiledTemplate) {
            this._compiledTemplateCache.delete(type);
          }
        }
      }, {
        key: "clearCache",
        value: function clearCache() {
          // Note: don't clear the _addedAotSummaries, as they don't change!
          this._metadataResolver.clearCache();

          this._compiledTemplateCache.clear();

          this._compiledHostTemplateCache.clear();

          this._compiledNgModuleCache.clear();
        }
      }, {
        key: "_createCompiledHostTemplate",
        value: function _createCompiledHostTemplate(compType, ngModule) {
          if (!ngModule) {
            throw new Error("Component ".concat(stringify(compType), " is not part of any NgModule or the module has not been imported into your module."));
          }

          var compiledTemplate = this._compiledHostTemplateCache.get(compType);

          if (!compiledTemplate) {
            var compMeta = this._metadataResolver.getDirectiveMetadata(compType);

            assertComponent(compMeta);

            var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta, compMeta.componentFactory.viewDefFactory);

            compiledTemplate = new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);

            this._compiledHostTemplateCache.set(compType, compiledTemplate);
          }

          return compiledTemplate;
        }
      }, {
        key: "_createCompiledTemplate",
        value: function _createCompiledTemplate(compMeta, ngModule) {
          var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);

          if (!compiledTemplate) {
            assertComponent(compMeta);
            compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);

            this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);
          }

          return compiledTemplate;
        }
      }, {
        key: "_compileTemplate",
        value: function _compileTemplate(template) {
          var _this294 = this;

          if (template.isCompiled) {
            return;
          }

          var compMeta = template.compMeta;
          var externalStylesheetsByModuleUrl = new Map();
          var outputContext = createOutputContext();

          var componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);

          compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {
            var compiledStylesheet = _this294._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);

            externalStylesheetsByModuleUrl.set(stylesheetMeta.moduleUrl, compiledStylesheet);
          });

          this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);

          var pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) {
            return _this294._metadataResolver.getPipeSummary(pipe.reference);
          });

          var _this$_parseTemplate3 = this._parseTemplate(compMeta, template.ngModule, template.directives),
              parsedTemplate = _this$_parseTemplate3.template,
              usedPipes = _this$_parseTemplate3.pipes;

          var compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, variable(componentStylesheet.stylesVar), usedPipes);

          var evalResult = this._interpretOrJit(templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);

          var viewClass = evalResult[compileResult.viewClassVar];
          var rendererType = evalResult[compileResult.rendererTypeVar];
          template.compiled(viewClass, rendererType);
        }
      }, {
        key: "_parseTemplate",
        value: function _parseTemplate(compMeta, ngModule, directiveIdentifiers) {
          var _this295 = this;

          // Note: ! is ok here as components always have a template.
          var preserveWhitespaces = compMeta.template.preserveWhitespaces;
          var directives = directiveIdentifiers.map(function (dir) {
            return _this295._metadataResolver.getDirectiveSummary(dir.reference);
          });
          var pipes = ngModule.transitiveModule.pipes.map(function (pipe) {
            return _this295._metadataResolver.getPipeSummary(pipe.reference);
          });
          return this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);
        }
      }, {
        key: "_resolveStylesCompileResult",
        value: function _resolveStylesCompileResult(result, externalStylesheetsByModuleUrl) {
          var _this296 = this;

          result.dependencies.forEach(function (dep, i) {
            var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);

            var nestedStylesArr = _this296._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);

            dep.setValue(nestedStylesArr);
          });
        }
      }, {
        key: "_resolveAndEvalStylesCompileResult",
        value: function _resolveAndEvalStylesCompileResult(result, externalStylesheetsByModuleUrl) {
          this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);

          return this._interpretOrJit(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];
        }
      }, {
        key: "_interpretOrJit",
        value: function _interpretOrJit(sourceUrl, statements) {
          if (!this._compilerConfig.useJit) {
            return interpretStatements(statements, this._reflector);
          } else {
            return this._jitEvaluator.evaluateStatements(sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);
          }
        }
      }]);

      return JitCompiler;
    }();

    var CompiledTemplate =
    /*#__PURE__*/
    function () {
      function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {
        _classCallCheck(this, CompiledTemplate);

        this.isHost = isHost;
        this.compType = compType;
        this.compMeta = compMeta;
        this.ngModule = ngModule;
        this.directives = directives;
        this._viewClass = null;
        this.isCompiled = false;
      }

      _createClass(CompiledTemplate, [{
        key: "compiled",
        value: function compiled(viewClass, rendererType) {
          this._viewClass = viewClass;
          this.compMeta.componentViewType.setDelegate(viewClass);

          for (var prop in rendererType) {
            this.compMeta.rendererType[prop] = rendererType[prop];
          }

          this.isCompiled = true;
        }
      }]);

      return CompiledTemplate;
    }();

    function assertComponent(meta) {
      if (!meta.isComponent) {
        throw new Error("Could not compile '".concat(identifierName(meta.type), "' because it is not a component."));
      }
    }

    function createOutputContext() {
      var importExpr$1 = function importExpr$1(symbol) {
        return importExpr({
          name: identifierName(symbol),
          moduleName: null,
          runtime: symbol
        });
      };

      return {
        statements: [],
        genFilePath: '',
        importExpr: importExpr$1,
        constantPool: new ConstantPool()
      };
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Provides access to reflection data about symbols that the compiler needs.
     */


    var CompileReflector = function CompileReflector() {
      _classCallCheck(this, CompileReflector);
    };
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Create a {@link UrlResolver} with no package prefix.
     */


    function createUrlResolverWithoutPackagePrefix() {
      return new UrlResolver();
    }

    function createOfflineCompileUrlResolver() {
      return new UrlResolver('.');
    }

    var UrlResolver =
    /*#__PURE__*/
    function () {
      function UrlResolverImpl() {
        var _packagePrefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _classCallCheck(this, UrlResolverImpl);

        this._packagePrefix = _packagePrefix;
      }
      /**
       * Resolves the `url` given the `baseUrl`:
       * - when the `url` is null, the `baseUrl` is returned,
       * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
       * `baseUrl` and `url`,
       * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
       * returned as is (ignoring the `baseUrl`)
       */


      _createClass(UrlResolverImpl, [{
        key: "resolve",
        value: function resolve(baseUrl, url) {
          var resolvedUrl = url;

          if (baseUrl != null && baseUrl.length > 0) {
            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
          }

          var resolvedParts = _split(resolvedUrl);

          var prefix = this._packagePrefix;

          if (prefix != null && resolvedParts != null && resolvedParts[_ComponentIndex.Scheme] == 'package') {
            var path = resolvedParts[_ComponentIndex.Path];
            prefix = prefix.replace(/\/+$/, '');
            path = path.replace(/^\/+/, '');
            return "".concat(prefix, "/").concat(path);
          }

          return resolvedUrl;
        }
      }]);

      return UrlResolverImpl;
    }();
    /**
     * Extract the scheme of a URL.
     */


    function getUrlScheme(url) {
      var match = _split(url);

      return match && match[_ComponentIndex.Scheme] || '';
    } // The code below is adapted from Traceur:
    // https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js

    /**
     * Builds a URI string from already-encoded parts.
     *
     * No encoding is performed.  Any component may be omitted as either null or
     * undefined.
     *
     * @param opt_scheme The scheme such as 'http'.
     * @param opt_userInfo The user name before the '@'.
     * @param opt_domain The domain such as 'www.google.com', already
     *     URI-encoded.
     * @param opt_port The port number.
     * @param opt_path The path, already URI-encoded.  If it is not
     *     empty, it must begin with a slash.
     * @param opt_queryData The URI-encoded query data.
     * @param opt_fragment The URI-encoded fragment identifier.
     * @return The fully combined URI.
     */


    function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
      var out = [];

      if (opt_scheme != null) {
        out.push(opt_scheme + ':');
      }

      if (opt_domain != null) {
        out.push('//');

        if (opt_userInfo != null) {
          out.push(opt_userInfo + '@');
        }

        out.push(opt_domain);

        if (opt_port != null) {
          out.push(':' + opt_port);
        }
      }

      if (opt_path != null) {
        out.push(opt_path);
      }

      if (opt_queryData != null) {
        out.push('?' + opt_queryData);
      }

      if (opt_fragment != null) {
        out.push('#' + opt_fragment);
      }

      return out.join('');
    }
    /**
     * A regular expression for breaking a URI into its component parts.
     *
     * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
     * As the "first-match-wins" algorithm is identical to the "greedy"
     * disambiguation method used by POSIX regular expressions, it is natural and
     * commonplace to use a regular expression for parsing the potential five
     * components of a URI reference.
     *
     * The following line is the regular expression for breaking-down a
     * well-formed URI reference into its components.
     *
     * <pre>
     * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
     *  12            3  4          5       6  7        8 9
     * </pre>
     *
     * The numbers in the second line above are only to assist readability; they
     * indicate the reference points for each subexpression (i.e., each paired
     * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
     * For example, matching the above expression to
     * <pre>
     *     http://www.ics.uci.edu/pub/ietf/uri/#Related
     * </pre>
     * results in the following subexpression matches:
     * <pre>
     *    $1 = http:
     *    $2 = http
     *    $3 = //www.ics.uci.edu
     *    $4 = www.ics.uci.edu
     *    $5 = /pub/ietf/uri/
     *    $6 = <undefined>
     *    $7 = <undefined>
     *    $8 = #Related
     *    $9 = Related
     * </pre>
     * where <undefined> indicates that the component is not present, as is the
     * case for the query component in the above example. Therefore, we can
     * determine the value of the five components as
     * <pre>
     *    scheme    = $2
     *    authority = $4
     *    path      = $5
     *    query     = $7
     *    fragment  = $9
     * </pre>
     *
     * The regular expression has been modified slightly to expose the
     * userInfo, domain, and port separately from the authority.
     * The modified version yields
     * <pre>
     *    $1 = http              scheme
     *    $2 = <undefined>       userInfo -\
     *    $3 = www.ics.uci.edu   domain     | authority
     *    $4 = <undefined>       port     -/
     *    $5 = /pub/ietf/uri/    path
     *    $6 = <undefined>       query without ?
     *    $7 = Related           fragment without #
     * </pre>
     * @internal
     */


    var _splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + // scheme - ignore special characters
    // used by other URL parts such as :,
    // ?, /, #, and .
    ':)?' + '(?://' + '(?:([^/?#]*)@)?' + // userInfo
    "([\\w\\d\\-\\u0100-\\uffff.%]*)" + // domain - restrict to letters,
    // digits, dashes, dots, percent
    // escapes, and unicode characters.
    '(?::([0-9]+))?' + // port
    ')?' + '([^?#]+)?' + // path
    '(?:\\?([^#]*))?' + // query
    '(?:#(.*))?' + // fragment
    '$');
    /**
     * The index of each URI component in the return value of goog.uri.utils.split.
     * @enum {number}
     */


    var _ComponentIndex;

    (function (_ComponentIndex) {
      _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
      _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
      _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
      _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
      _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
      _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
      _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
    })(_ComponentIndex || (_ComponentIndex = {}));
    /**
     * Splits a URI into its component parts.
     *
     * Each component can be accessed via the component indices; for example:
     * <pre>
     * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
     * </pre>
     *
     * @param uri The URI string to examine.
     * @return Each component still URI-encoded.
     *     Each component that is present will contain the encoded value, whereas
     *     components that are not present will be undefined or empty, depending
     *     on the browser's regular expression implementation.  Never null, since
     *     arbitrary strings may still look like path names.
     */


    function _split(uri) {
      return uri.match(_splitRe);
    }
    /**
      * Removes dot segments in given path component, as described in
      * RFC 3986, section 5.2.4.
      *
      * @param path A non-empty path component.
      * @return Path component with removed dot segments.
      */


    function _removeDotSegments(path) {
      if (path == '/') return '/';
      var leadingSlash = path[0] == '/' ? '/' : '';
      var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
      var segments = path.split('/');
      var out = [];
      var up = 0;

      for (var pos = 0; pos < segments.length; pos++) {
        var segment = segments[pos];

        switch (segment) {
          case '':
          case '.':
            break;

          case '..':
            if (out.length > 0) {
              out.pop();
            } else {
              up++;
            }

            break;

          default:
            out.push(segment);
        }
      }

      if (leadingSlash == '') {
        while (up-- > 0) {
          out.unshift('..');
        }

        if (out.length === 0) out.push('.');
      }

      return leadingSlash + out.join('/') + trailingSlash;
    }
    /**
     * Takes an array of the parts from split and canonicalizes the path part
     * and then joins all the parts.
     */


    function _joinAndCanonicalizePath(parts) {
      var path = parts[_ComponentIndex.Path];
      path = path == null ? '' : _removeDotSegments(path);
      parts[_ComponentIndex.Path] = path;
      return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
    }
    /**
     * Resolves a URL.
     * @param base The URL acting as the base URL.
     * @param to The URL to resolve.
     */


    function _resolveUrl(base, url) {
      var parts = _split(encodeURI(url));

      var baseParts = _split(base);

      if (parts[_ComponentIndex.Scheme] != null) {
        return _joinAndCanonicalizePath(parts);
      } else {
        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
      }

      for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
        if (parts[i] == null) {
          parts[i] = baseParts[i];
        }
      }

      if (parts[_ComponentIndex.Path][0] == '/') {
        return _joinAndCanonicalizePath(parts);
      }

      var path = baseParts[_ComponentIndex.Path];
      if (path == null) path = '/';
      var index = path.lastIndexOf('/');
      path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
      parts[_ComponentIndex.Path] = path;
      return _joinAndCanonicalizePath(parts);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var Extractor =
    /*#__PURE__*/
    function () {
      function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {
        _classCallCheck(this, Extractor);

        this.host = host;
        this.staticSymbolResolver = staticSymbolResolver;
        this.messageBundle = messageBundle;
        this.metadataResolver = metadataResolver;
      }

      _createClass(Extractor, [{
        key: "extract",
        value: function extract(rootFiles) {
          var _this297 = this;

          var _analyzeAndValidateNg = analyzeAndValidateNgModules(rootFiles, this.host, this.staticSymbolResolver, this.metadataResolver),
              files = _analyzeAndValidateNg.files,
              ngModules = _analyzeAndValidateNg.ngModules;

          return Promise.all(ngModules.map(function (ngModule) {
            return _this297.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false);
          })).then(function () {
            var errors = [];
            files.forEach(function (file) {
              var compMetas = [];
              file.directives.forEach(function (directiveType) {
                var dirMeta = _this297.metadataResolver.getDirectiveMetadata(directiveType);

                if (dirMeta && dirMeta.isComponent) {
                  compMetas.push(dirMeta);
                }
              });
              compMetas.forEach(function (compMeta) {
                var html = compMeta.template.template; // Template URL points to either an HTML or TS file depending on
                // whether the file is used with `templateUrl:` or `template:`,
                // respectively.

                var templateUrl = compMeta.template.templateUrl;
                var interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);
                errors.push.apply(errors, _toConsumableArray(_this297.messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)));
              });
            });

            if (errors.length) {
              throw new Error(errors.map(function (e) {
                return e.toString();
              }).join('\n'));
            }

            return _this297.messageBundle;
          });
        }
      }], [{
        key: "create",
        value: function create(host, locale) {
          var htmlParser = new HtmlParser();
          var urlResolver = createAotUrlResolver(host);
          var symbolCache = new StaticSymbolCache();
          var summaryResolver = new AotSummaryResolver(host, symbolCache);
          var staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);
          var staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);
          var config = new CompilerConfig({
            defaultEncapsulation: ViewEncapsulation.Emulated,
            useJit: false
          });
          var normalizer = new DirectiveNormalizer({
            get: function get(url) {
              return host.loadResource(url);
            }
          }, urlResolver, htmlParser, config);
          var elementSchemaRegistry = new DomElementSchemaRegistry();
          var resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector); // TODO(vicb): implicit tags & attributes

          var messageBundle = new MessageBundle(htmlParser, [], {}, locale);
          var extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);
          return {
            extractor: extractor,
            staticReflector: staticReflector
          };
        }
      }]);

      return Extractor;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Processes `Target`s with a given set of directives and performs a binding operation, which
     * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the
     * target.
     */


    var R3TargetBinder =
    /*#__PURE__*/
    function () {
      function R3TargetBinder(directiveMatcher) {
        _classCallCheck(this, R3TargetBinder);

        this.directiveMatcher = directiveMatcher;
      }
      /**
       * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains
       * metadata about the types referenced in the template.
       */


      _createClass(R3TargetBinder, [{
        key: "bind",
        value: function bind(target) {
          if (!target.template) {
            // TODO(alxhub): handle targets which contain things like HostBindings, etc.
            throw new Error('Binding without a template not yet supported');
          } // First, parse the template into a `Scope` structure. This operation captures the syntactic
          // scopes in the template and makes them available for later use.


          var scope = Scope.apply(target.template); // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:
          //   - directives: Map of nodes (elements & ng-templates) to the directives on them.
          //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims
          //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.
          //   - references: Map of #references to their targets.

          var _DirectiveBinder$appl = DirectiveBinder.apply(target.template, this.directiveMatcher),
              directives = _DirectiveBinder$appl.directives,
              bindings = _DirectiveBinder$appl.bindings,
              references = _DirectiveBinder$appl.references; // Finally, run the TemplateBinder to bind references, variables, and other entities within the
          // template. This extracts all the metadata that doesn't depend on directive matching.


          var _TemplateBinder$apply = TemplateBinder.apply(target.template, scope),
              expressions = _TemplateBinder$apply.expressions,
              symbols = _TemplateBinder$apply.symbols,
              nestingLevel = _TemplateBinder$apply.nestingLevel,
              usedPipes = _TemplateBinder$apply.usedPipes;

          return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, usedPipes);
        }
      }]);

      return R3TargetBinder;
    }();
    /**
     * Represents a binding scope within a template.
     *
     * Any variables, references, or other named entities declared within the template will
     * be captured and available by name in `namedEntities`. Additionally, child templates will
     * be analyzed and have their child `Scope`s available in `childScopes`.
     */


    var Scope =
    /*#__PURE__*/
    function () {
      function Scope(parentScope) {
        _classCallCheck(this, Scope);

        this.parentScope = parentScope;
        /**
         * Named members of the `Scope`, such as `Reference`s or `Variable`s.
         */

        this.namedEntities = new Map();
        /**
         * Child `Scope`s for immediately nested `Template`s.
         */

        this.childScopes = new Map();
      }
      /**
       * Process a template (either as a `Template` sub-template with variables, or a plain array of
       * template `Node`s) and construct its `Scope`.
       */


      _createClass(Scope, [{
        key: "ingest",

        /**
         * Internal method to process the template and populate the `Scope`.
         */
        value: function ingest(template) {
          var _this298 = this;

          if (template instanceof Template) {
            // Variables on an <ng-template> are defined in the inner scope.
            template.variables.forEach(function (node) {
              return _this298.visitVariable(node);
            }); // Process the nodes of the template.

            template.children.forEach(function (node) {
              return node.visit(_this298);
            });
          } else {
            // No overarching `Template` instance, so process the nodes directly.
            template.forEach(function (node) {
              return node.visit(_this298);
            });
          }
        }
      }, {
        key: "visitElement",
        value: function visitElement(element) {
          var _this299 = this;

          // `Element`s in the template may have `Reference`s which are captured in the scope.
          element.references.forEach(function (node) {
            return _this299.visitReference(node);
          }); // Recurse into the `Element`'s children.

          element.children.forEach(function (node) {
            return node.visit(_this299);
          });
        }
      }, {
        key: "visitTemplate",
        value: function visitTemplate(template) {
          var _this300 = this;

          // References on a <ng-template> are defined in the outer scope, so capture them before
          // processing the template's child scope.
          template.references.forEach(function (node) {
            return _this300.visitReference(node);
          }); // Next, create an inner scope and process the template within it.

          var scope = new Scope(this);
          scope.ingest(template);
          this.childScopes.set(template, scope);
        }
      }, {
        key: "visitVariable",
        value: function visitVariable(variable) {
          // Declare the variable if it's not already.
          this.maybeDeclare(variable);
        }
      }, {
        key: "visitReference",
        value: function visitReference(reference) {
          // Declare the variable if it's not already.
          this.maybeDeclare(reference);
        } // Unused visitors.

      }, {
        key: "visitContent",
        value: function visitContent(content) {}
      }, {
        key: "visitBoundAttribute",
        value: function visitBoundAttribute(attr) {}
      }, {
        key: "visitBoundEvent",
        value: function visitBoundEvent(event) {}
      }, {
        key: "visitBoundText",
        value: function visitBoundText(text) {}
      }, {
        key: "visitText",
        value: function visitText(text) {}
      }, {
        key: "visitTextAttribute",
        value: function visitTextAttribute(attr) {}
      }, {
        key: "visitIcu",
        value: function visitIcu(icu) {}
      }, {
        key: "maybeDeclare",
        value: function maybeDeclare(thing) {
          // Declare something with a name, as long as that name isn't taken.
          if (!this.namedEntities.has(thing.name)) {
            this.namedEntities.set(thing.name, thing);
          }
        }
        /**
         * Look up a variable within this `Scope`.
         *
         * This can recurse into a parent `Scope` if it's available.
         */

      }, {
        key: "lookup",
        value: function lookup(name) {
          if (this.namedEntities.has(name)) {
            // Found in the local scope.
            return this.namedEntities.get(name);
          } else if (this.parentScope !== undefined) {
            // Not in the local scope, but there's a parent scope so check there.
            return this.parentScope.lookup(name);
          } else {
            // At the top level and it wasn't found.
            return null;
          }
        }
        /**
         * Get the child scope for a `Template`.
         *
         * This should always be defined.
         */

      }, {
        key: "getChildScope",
        value: function getChildScope(template) {
          var res = this.childScopes.get(template);

          if (res === undefined) {
            throw new Error("Assertion error: child scope for ".concat(template, " not found"));
          }

          return res;
        }
      }], [{
        key: "apply",
        value: function apply(template) {
          var scope = new Scope();
          scope.ingest(template);
          return scope;
        }
      }]);

      return Scope;
    }();
    /**
     * Processes a template and matches directives on nodes (elements and templates).
     *
     * Usually used via the static `apply()` method.
     */


    var DirectiveBinder =
    /*#__PURE__*/
    function () {
      function DirectiveBinder(matcher, directives, bindings, references) {
        _classCallCheck(this, DirectiveBinder);

        this.matcher = matcher;
        this.directives = directives;
        this.bindings = bindings;
        this.references = references;
      }
      /**
       * Process a template (list of `Node`s) and perform directive matching against each node.
       *
       * @param template the list of template `Node`s to match (recursively).
       * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for
       * this template.
       * @returns three maps which contain information about directives in the template: the
       * `directives` map which lists directives matched on each node, the `bindings` map which
       * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`
       * map which resolves #references (`Reference`s) within the template to the named directive or
       * template node.
       */


      _createClass(DirectiveBinder, [{
        key: "ingest",
        value: function ingest(template) {
          var _this301 = this;

          template.forEach(function (node) {
            return node.visit(_this301);
          });
        }
      }, {
        key: "visitElement",
        value: function visitElement(element) {
          this.visitElementOrTemplate(element.name, element);
        }
      }, {
        key: "visitTemplate",
        value: function visitTemplate(template) {
          this.visitElementOrTemplate('ng-template', template);
        }
      }, {
        key: "visitElementOrTemplate",
        value: function visitElementOrTemplate(elementName, node) {
          var _this302 = this;

          // First, determine the HTML shape of the node for the purpose of directive matching.
          // Do this by building up a `CssSelector` for the node.
          var cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node)); // Next, use the `SelectorMatcher` to get the list of directives on the node.

          var directives = [];
          this.matcher.match(cssSelector, function (_, directive) {
            return directives.push(directive);
          });

          if (directives.length > 0) {
            this.directives.set(node, directives);
          } // Resolve any references that are created on this node.


          node.references.forEach(function (ref) {
            var dirTarget = null; // If the reference expression is empty, then it matches the "primary" directive on the node
            // (if there is one). Otherwise it matches the host node itself (either an element or
            // <ng-template> node).

            if (ref.value.trim() === '') {
              // This could be a reference to a component if there is one.
              dirTarget = directives.find(function (dir) {
                return dir.isComponent;
              }) || null;
            } else {
              // This should be a reference to a directive exported via exportAs.
              dirTarget = directives.find(function (dir) {
                return dir.exportAs !== null && dir.exportAs.some(function (value) {
                  return value === ref.value;
                });
              }) || null; // Check if a matching directive was found.

              if (dirTarget === null) {
                // No matching directive was found - this reference points to an unknown target. Leave it
                // unmapped.
                return;
              }
            }

            if (dirTarget !== null) {
              // This reference points to a directive.
              _this302.references.set(ref, {
                directive: dirTarget,
                node: node
              });
            } else {
              // This reference points to the node itself.
              _this302.references.set(ref, node);
            }
          });

          var setAttributeBinding = function setAttributeBinding(attribute, ioType) {
            var dir = directives.find(function (dir) {
              return dir[ioType].hasOwnProperty(attribute.name);
            });
            var binding = dir !== undefined ? dir : node;

            _this302.bindings.set(attribute, binding);
          }; // Node inputs (bound attributes) and text attributes can be bound to an
          // input on a directive.


          node.inputs.forEach(function (input) {
            return setAttributeBinding(input, 'inputs');
          });
          node.attributes.forEach(function (attr) {
            return setAttributeBinding(attr, 'inputs');
          });

          if (node instanceof Template) {
            node.templateAttrs.forEach(function (attr) {
              return setAttributeBinding(attr, 'inputs');
            });
          } // Node outputs (bound events) can be bound to an output on a directive.


          node.outputs.forEach(function (output) {
            return setAttributeBinding(output, 'outputs');
          }); // Recurse into the node's children.

          node.children.forEach(function (child) {
            return child.visit(_this302);
          });
        } // Unused visitors.

      }, {
        key: "visitContent",
        value: function visitContent(content) {}
      }, {
        key: "visitVariable",
        value: function visitVariable(variable) {}
      }, {
        key: "visitReference",
        value: function visitReference(reference) {}
      }, {
        key: "visitTextAttribute",
        value: function visitTextAttribute(attribute) {}
      }, {
        key: "visitBoundAttribute",
        value: function visitBoundAttribute(attribute) {}
      }, {
        key: "visitBoundEvent",
        value: function visitBoundEvent(attribute) {}
      }, {
        key: "visitBoundAttributeOrEvent",
        value: function visitBoundAttributeOrEvent(node) {}
      }, {
        key: "visitText",
        value: function visitText(text) {}
      }, {
        key: "visitBoundText",
        value: function visitBoundText(text) {}
      }, {
        key: "visitIcu",
        value: function visitIcu(icu) {}
      }], [{
        key: "apply",
        value: function apply(template, selectorMatcher) {
          var directives = new Map();
          var bindings = new Map();
          var references = new Map();
          var matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);
          matcher.ingest(template);
          return {
            directives: directives,
            bindings: bindings,
            references: references
          };
        }
      }]);

      return DirectiveBinder;
    }();
    /**
     * Processes a template and extract metadata about expressions and symbols within.
     *
     * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched
     * within the template in order to operate.
     *
     * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided
     * by overridden methods from that visitor.
     */


    var TemplateBinder =
    /*#__PURE__*/
    function (_RecursiveAstVisitor$2) {
      _inherits(TemplateBinder, _RecursiveAstVisitor$2);

      function TemplateBinder(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {
        var _this303;

        _classCallCheck(this, TemplateBinder);

        _this303 = _possibleConstructorReturn(this, _getPrototypeOf(TemplateBinder).call(this));
        _this303.bindings = bindings;
        _this303.symbols = symbols;
        _this303.usedPipes = usedPipes;
        _this303.nestingLevel = nestingLevel;
        _this303.scope = scope;
        _this303.template = template;
        _this303.level = level;
        _this303.pipesUsed = []; // Save a bit of processing time by constructing this closure in advance.

        _this303.visitNode = function (node) {
          return node.visit(_assertThisInitialized(_this303));
        };

        return _this303;
      }
      /**
       * Process a template and extract metadata about expressions and symbols within.
       *
       * @param template the nodes of the template to process
       * @param scope the `Scope` of the template being processed.
       * @returns three maps which contain metadata about the template: `expressions` which interprets
       * special `AST` nodes in expressions as pointing to references or variables declared within the
       * template, `symbols` which maps those variables and references to the nested `Template` which
       * declares them, if any, and `nestingLevel` which associates each `Template` with a integer
       * nesting level (how many levels deep within the template structure the `Template` is), starting
       * at 1.
       */


      _createClass(TemplateBinder, [{
        key: "ingest",
        value: function ingest(template) {
          if (template instanceof Template) {
            // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,
            // and references were all processed in the scope of the containing template.
            template.variables.forEach(this.visitNode);
            template.children.forEach(this.visitNode); // Set the nesting level.

            this.nestingLevel.set(template, this.level);
          } else {
            // Visit each node from the top-level template.
            template.forEach(this.visitNode);
          }
        }
      }, {
        key: "visitElement",
        value: function visitElement(element) {
          // Visit the inputs, outputs, and children of the element.
          element.inputs.forEach(this.visitNode);
          element.outputs.forEach(this.visitNode);
          element.children.forEach(this.visitNode);
        }
      }, {
        key: "visitTemplate",
        value: function visitTemplate(template) {
          // First, visit inputs, outputs and template attributes of the template node.
          template.inputs.forEach(this.visitNode);
          template.outputs.forEach(this.visitNode);
          template.templateAttrs.forEach(this.visitNode); // References are also evaluated in the outer context.

          template.references.forEach(this.visitNode); // Next, recurse into the template using its scope, and bumping the nesting level up by one.

          var childScope = this.scope.getChildScope(template);
          var binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);
          binder.ingest(template);
        }
      }, {
        key: "visitVariable",
        value: function visitVariable(variable) {
          // Register the `Variable` as a symbol in the current `Template`.
          if (this.template !== null) {
            this.symbols.set(variable, this.template);
          }
        }
      }, {
        key: "visitReference",
        value: function visitReference(reference) {
          // Register the `Reference` as a symbol in the current `Template`.
          if (this.template !== null) {
            this.symbols.set(reference, this.template);
          }
        } // Unused template visitors

      }, {
        key: "visitText",
        value: function visitText(text) {}
      }, {
        key: "visitContent",
        value: function visitContent(content) {}
      }, {
        key: "visitTextAttribute",
        value: function visitTextAttribute(attribute) {}
      }, {
        key: "visitIcu",
        value: function visitIcu(icu) {} // The remaining visitors are concerned with processing AST expressions within template bindings

      }, {
        key: "visitBoundAttribute",
        value: function visitBoundAttribute(attribute) {
          attribute.value.visit(this);
        }
      }, {
        key: "visitBoundEvent",
        value: function visitBoundEvent(event) {
          event.handler.visit(this);
        }
      }, {
        key: "visitBoundText",
        value: function visitBoundText(text) {
          text.value.visit(this);
        }
      }, {
        key: "visitPipe",
        value: function visitPipe(ast, context) {
          this.usedPipes.add(ast.name);
          return _get(_getPrototypeOf(TemplateBinder.prototype), "visitPipe", this).call(this, ast, context);
        } // These five types of AST expressions can refer to expression roots, which could be variables
        // or references in the current scope.

      }, {
        key: "visitPropertyRead",
        value: function visitPropertyRead(ast, context) {
          this.maybeMap(context, ast, ast.name);
          return _get(_getPrototypeOf(TemplateBinder.prototype), "visitPropertyRead", this).call(this, ast, context);
        }
      }, {
        key: "visitSafePropertyRead",
        value: function visitSafePropertyRead(ast, context) {
          this.maybeMap(context, ast, ast.name);
          return _get(_getPrototypeOf(TemplateBinder.prototype), "visitSafePropertyRead", this).call(this, ast, context);
        }
      }, {
        key: "visitPropertyWrite",
        value: function visitPropertyWrite(ast, context) {
          this.maybeMap(context, ast, ast.name);
          return _get(_getPrototypeOf(TemplateBinder.prototype), "visitPropertyWrite", this).call(this, ast, context);
        }
      }, {
        key: "visitMethodCall",
        value: function visitMethodCall(ast, context) {
          this.maybeMap(context, ast, ast.name);
          return _get(_getPrototypeOf(TemplateBinder.prototype), "visitMethodCall", this).call(this, ast, context);
        }
      }, {
        key: "visitSafeMethodCall",
        value: function visitSafeMethodCall(ast, context) {
          this.maybeMap(context, ast, ast.name);
          return _get(_getPrototypeOf(TemplateBinder.prototype), "visitSafeMethodCall", this).call(this, ast, context);
        }
      }, {
        key: "maybeMap",
        value: function maybeMap(scope, ast, name) {
          // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an
          // `AST` expression that maps to a `Variable` or `Reference`.
          if (!(ast.receiver instanceof ImplicitReceiver)) {
            return;
          } // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is
          // probably a property on the top-level component context.


          var target = this.scope.lookup(name);

          if (target !== null) {
            this.bindings.set(ast, target);
          }
        }
      }], [{
        key: "apply",
        value: function apply(template, scope) {
          var expressions = new Map();
          var symbols = new Map();
          var nestingLevel = new Map();
          var usedPipes = new Set(); // The top-level template has nesting level 0.

          var binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);
          binder.ingest(template);
          return {
            expressions: expressions,
            symbols: symbols,
            nestingLevel: nestingLevel,
            usedPipes: usedPipes
          };
        }
      }]);

      return TemplateBinder;
    }(RecursiveAstVisitor$1);
    /**
     * Metadata container for a `Target` that allows queries for specific bits of metadata.
     *
     * See `BoundTarget` for documentation on the individual methods.
     */


    var R3BoundTarget =
    /*#__PURE__*/
    function () {
      function R3BoundTarget(target, directives, bindings, references, exprTargets, symbols, nestingLevel, usedPipes) {
        _classCallCheck(this, R3BoundTarget);

        this.target = target;
        this.directives = directives;
        this.bindings = bindings;
        this.references = references;
        this.exprTargets = exprTargets;
        this.symbols = symbols;
        this.nestingLevel = nestingLevel;
        this.usedPipes = usedPipes;
      }

      _createClass(R3BoundTarget, [{
        key: "getDirectivesOfNode",
        value: function getDirectivesOfNode(node) {
          return this.directives.get(node) || null;
        }
      }, {
        key: "getReferenceTarget",
        value: function getReferenceTarget(ref) {
          return this.references.get(ref) || null;
        }
      }, {
        key: "getConsumerOfBinding",
        value: function getConsumerOfBinding(binding) {
          return this.bindings.get(binding) || null;
        }
      }, {
        key: "getExpressionTarget",
        value: function getExpressionTarget(expr) {
          return this.exprTargets.get(expr) || null;
        }
      }, {
        key: "getTemplateOfSymbol",
        value: function getTemplateOfSymbol(symbol) {
          return this.symbols.get(symbol) || null;
        }
      }, {
        key: "getNestingLevel",
        value: function getNestingLevel(template) {
          return this.nestingLevel.get(template) || 0;
        }
      }, {
        key: "getUsedDirectives",
        value: function getUsedDirectives() {
          var set = new Set();
          this.directives.forEach(function (dirs) {
            return dirs.forEach(function (dir) {
              return set.add(dir);
            });
          });
          return Array.from(set.values());
        }
      }, {
        key: "getUsedPipes",
        value: function getUsedPipes() {
          return Array.from(this.usedPipes);
        }
      }]);

      return R3BoundTarget;
    }();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // This file only reexports content of the `src` folder. Keep it that way.
    // This function call has a global side effects and publishes the compiler into global namespace for
    // the late binding of the Compiler to the @angular/core for jit compilation.


    publishFacade(_global);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // This file only reexports content of the `src` folder. Keep it that way.

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    //# sourceMappingURL=compiler.js.map

    /***/
  },

  /***/
  "./node_modules/moment/locale sync recursive ^\\.\\/.*$":
  /*!**************************************************!*\
    !*** ./node_modules/moment/locale sync ^\.\/.*$ ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesMomentLocaleSyncRecursive$(module, exports, __webpack_require__) {
    var map = {
      "./af": "./node_modules/moment/locale/af.js",
      "./af.js": "./node_modules/moment/locale/af.js",
      "./ar": "./node_modules/moment/locale/ar.js",
      "./ar-dz": "./node_modules/moment/locale/ar-dz.js",
      "./ar-dz.js": "./node_modules/moment/locale/ar-dz.js",
      "./ar-kw": "./node_modules/moment/locale/ar-kw.js",
      "./ar-kw.js": "./node_modules/moment/locale/ar-kw.js",
      "./ar-ly": "./node_modules/moment/locale/ar-ly.js",
      "./ar-ly.js": "./node_modules/moment/locale/ar-ly.js",
      "./ar-ma": "./node_modules/moment/locale/ar-ma.js",
      "./ar-ma.js": "./node_modules/moment/locale/ar-ma.js",
      "./ar-sa": "./node_modules/moment/locale/ar-sa.js",
      "./ar-sa.js": "./node_modules/moment/locale/ar-sa.js",
      "./ar-tn": "./node_modules/moment/locale/ar-tn.js",
      "./ar-tn.js": "./node_modules/moment/locale/ar-tn.js",
      "./ar.js": "./node_modules/moment/locale/ar.js",
      "./az": "./node_modules/moment/locale/az.js",
      "./az.js": "./node_modules/moment/locale/az.js",
      "./be": "./node_modules/moment/locale/be.js",
      "./be.js": "./node_modules/moment/locale/be.js",
      "./bg": "./node_modules/moment/locale/bg.js",
      "./bg.js": "./node_modules/moment/locale/bg.js",
      "./bm": "./node_modules/moment/locale/bm.js",
      "./bm.js": "./node_modules/moment/locale/bm.js",
      "./bn": "./node_modules/moment/locale/bn.js",
      "./bn.js": "./node_modules/moment/locale/bn.js",
      "./bo": "./node_modules/moment/locale/bo.js",
      "./bo.js": "./node_modules/moment/locale/bo.js",
      "./br": "./node_modules/moment/locale/br.js",
      "./br.js": "./node_modules/moment/locale/br.js",
      "./bs": "./node_modules/moment/locale/bs.js",
      "./bs.js": "./node_modules/moment/locale/bs.js",
      "./ca": "./node_modules/moment/locale/ca.js",
      "./ca.js": "./node_modules/moment/locale/ca.js",
      "./cs": "./node_modules/moment/locale/cs.js",
      "./cs.js": "./node_modules/moment/locale/cs.js",
      "./cv": "./node_modules/moment/locale/cv.js",
      "./cv.js": "./node_modules/moment/locale/cv.js",
      "./cy": "./node_modules/moment/locale/cy.js",
      "./cy.js": "./node_modules/moment/locale/cy.js",
      "./da": "./node_modules/moment/locale/da.js",
      "./da.js": "./node_modules/moment/locale/da.js",
      "./de": "./node_modules/moment/locale/de.js",
      "./de-at": "./node_modules/moment/locale/de-at.js",
      "./de-at.js": "./node_modules/moment/locale/de-at.js",
      "./de-ch": "./node_modules/moment/locale/de-ch.js",
      "./de-ch.js": "./node_modules/moment/locale/de-ch.js",
      "./de.js": "./node_modules/moment/locale/de.js",
      "./dv": "./node_modules/moment/locale/dv.js",
      "./dv.js": "./node_modules/moment/locale/dv.js",
      "./el": "./node_modules/moment/locale/el.js",
      "./el.js": "./node_modules/moment/locale/el.js",
      "./en-SG": "./node_modules/moment/locale/en-SG.js",
      "./en-SG.js": "./node_modules/moment/locale/en-SG.js",
      "./en-au": "./node_modules/moment/locale/en-au.js",
      "./en-au.js": "./node_modules/moment/locale/en-au.js",
      "./en-ca": "./node_modules/moment/locale/en-ca.js",
      "./en-ca.js": "./node_modules/moment/locale/en-ca.js",
      "./en-gb": "./node_modules/moment/locale/en-gb.js",
      "./en-gb.js": "./node_modules/moment/locale/en-gb.js",
      "./en-ie": "./node_modules/moment/locale/en-ie.js",
      "./en-ie.js": "./node_modules/moment/locale/en-ie.js",
      "./en-il": "./node_modules/moment/locale/en-il.js",
      "./en-il.js": "./node_modules/moment/locale/en-il.js",
      "./en-nz": "./node_modules/moment/locale/en-nz.js",
      "./en-nz.js": "./node_modules/moment/locale/en-nz.js",
      "./eo": "./node_modules/moment/locale/eo.js",
      "./eo.js": "./node_modules/moment/locale/eo.js",
      "./es": "./node_modules/moment/locale/es.js",
      "./es-do": "./node_modules/moment/locale/es-do.js",
      "./es-do.js": "./node_modules/moment/locale/es-do.js",
      "./es-us": "./node_modules/moment/locale/es-us.js",
      "./es-us.js": "./node_modules/moment/locale/es-us.js",
      "./es.js": "./node_modules/moment/locale/es.js",
      "./et": "./node_modules/moment/locale/et.js",
      "./et.js": "./node_modules/moment/locale/et.js",
      "./eu": "./node_modules/moment/locale/eu.js",
      "./eu.js": "./node_modules/moment/locale/eu.js",
      "./fa": "./node_modules/moment/locale/fa.js",
      "./fa.js": "./node_modules/moment/locale/fa.js",
      "./fi": "./node_modules/moment/locale/fi.js",
      "./fi.js": "./node_modules/moment/locale/fi.js",
      "./fo": "./node_modules/moment/locale/fo.js",
      "./fo.js": "./node_modules/moment/locale/fo.js",
      "./fr": "./node_modules/moment/locale/fr.js",
      "./fr-ca": "./node_modules/moment/locale/fr-ca.js",
      "./fr-ca.js": "./node_modules/moment/locale/fr-ca.js",
      "./fr-ch": "./node_modules/moment/locale/fr-ch.js",
      "./fr-ch.js": "./node_modules/moment/locale/fr-ch.js",
      "./fr.js": "./node_modules/moment/locale/fr.js",
      "./fy": "./node_modules/moment/locale/fy.js",
      "./fy.js": "./node_modules/moment/locale/fy.js",
      "./ga": "./node_modules/moment/locale/ga.js",
      "./ga.js": "./node_modules/moment/locale/ga.js",
      "./gd": "./node_modules/moment/locale/gd.js",
      "./gd.js": "./node_modules/moment/locale/gd.js",
      "./gl": "./node_modules/moment/locale/gl.js",
      "./gl.js": "./node_modules/moment/locale/gl.js",
      "./gom-latn": "./node_modules/moment/locale/gom-latn.js",
      "./gom-latn.js": "./node_modules/moment/locale/gom-latn.js",
      "./gu": "./node_modules/moment/locale/gu.js",
      "./gu.js": "./node_modules/moment/locale/gu.js",
      "./he": "./node_modules/moment/locale/he.js",
      "./he.js": "./node_modules/moment/locale/he.js",
      "./hi": "./node_modules/moment/locale/hi.js",
      "./hi.js": "./node_modules/moment/locale/hi.js",
      "./hr": "./node_modules/moment/locale/hr.js",
      "./hr.js": "./node_modules/moment/locale/hr.js",
      "./hu": "./node_modules/moment/locale/hu.js",
      "./hu.js": "./node_modules/moment/locale/hu.js",
      "./hy-am": "./node_modules/moment/locale/hy-am.js",
      "./hy-am.js": "./node_modules/moment/locale/hy-am.js",
      "./id": "./node_modules/moment/locale/id.js",
      "./id.js": "./node_modules/moment/locale/id.js",
      "./is": "./node_modules/moment/locale/is.js",
      "./is.js": "./node_modules/moment/locale/is.js",
      "./it": "./node_modules/moment/locale/it.js",
      "./it-ch": "./node_modules/moment/locale/it-ch.js",
      "./it-ch.js": "./node_modules/moment/locale/it-ch.js",
      "./it.js": "./node_modules/moment/locale/it.js",
      "./ja": "./node_modules/moment/locale/ja.js",
      "./ja.js": "./node_modules/moment/locale/ja.js",
      "./jv": "./node_modules/moment/locale/jv.js",
      "./jv.js": "./node_modules/moment/locale/jv.js",
      "./ka": "./node_modules/moment/locale/ka.js",
      "./ka.js": "./node_modules/moment/locale/ka.js",
      "./kk": "./node_modules/moment/locale/kk.js",
      "./kk.js": "./node_modules/moment/locale/kk.js",
      "./km": "./node_modules/moment/locale/km.js",
      "./km.js": "./node_modules/moment/locale/km.js",
      "./kn": "./node_modules/moment/locale/kn.js",
      "./kn.js": "./node_modules/moment/locale/kn.js",
      "./ko": "./node_modules/moment/locale/ko.js",
      "./ko.js": "./node_modules/moment/locale/ko.js",
      "./ku": "./node_modules/moment/locale/ku.js",
      "./ku.js": "./node_modules/moment/locale/ku.js",
      "./ky": "./node_modules/moment/locale/ky.js",
      "./ky.js": "./node_modules/moment/locale/ky.js",
      "./lb": "./node_modules/moment/locale/lb.js",
      "./lb.js": "./node_modules/moment/locale/lb.js",
      "./lo": "./node_modules/moment/locale/lo.js",
      "./lo.js": "./node_modules/moment/locale/lo.js",
      "./lt": "./node_modules/moment/locale/lt.js",
      "./lt.js": "./node_modules/moment/locale/lt.js",
      "./lv": "./node_modules/moment/locale/lv.js",
      "./lv.js": "./node_modules/moment/locale/lv.js",
      "./me": "./node_modules/moment/locale/me.js",
      "./me.js": "./node_modules/moment/locale/me.js",
      "./mi": "./node_modules/moment/locale/mi.js",
      "./mi.js": "./node_modules/moment/locale/mi.js",
      "./mk": "./node_modules/moment/locale/mk.js",
      "./mk.js": "./node_modules/moment/locale/mk.js",
      "./ml": "./node_modules/moment/locale/ml.js",
      "./ml.js": "./node_modules/moment/locale/ml.js",
      "./mn": "./node_modules/moment/locale/mn.js",
      "./mn.js": "./node_modules/moment/locale/mn.js",
      "./mr": "./node_modules/moment/locale/mr.js",
      "./mr.js": "./node_modules/moment/locale/mr.js",
      "./ms": "./node_modules/moment/locale/ms.js",
      "./ms-my": "./node_modules/moment/locale/ms-my.js",
      "./ms-my.js": "./node_modules/moment/locale/ms-my.js",
      "./ms.js": "./node_modules/moment/locale/ms.js",
      "./mt": "./node_modules/moment/locale/mt.js",
      "./mt.js": "./node_modules/moment/locale/mt.js",
      "./my": "./node_modules/moment/locale/my.js",
      "./my.js": "./node_modules/moment/locale/my.js",
      "./nb": "./node_modules/moment/locale/nb.js",
      "./nb.js": "./node_modules/moment/locale/nb.js",
      "./ne": "./node_modules/moment/locale/ne.js",
      "./ne.js": "./node_modules/moment/locale/ne.js",
      "./nl": "./node_modules/moment/locale/nl.js",
      "./nl-be": "./node_modules/moment/locale/nl-be.js",
      "./nl-be.js": "./node_modules/moment/locale/nl-be.js",
      "./nl.js": "./node_modules/moment/locale/nl.js",
      "./nn": "./node_modules/moment/locale/nn.js",
      "./nn.js": "./node_modules/moment/locale/nn.js",
      "./pa-in": "./node_modules/moment/locale/pa-in.js",
      "./pa-in.js": "./node_modules/moment/locale/pa-in.js",
      "./pl": "./node_modules/moment/locale/pl.js",
      "./pl.js": "./node_modules/moment/locale/pl.js",
      "./pt": "./node_modules/moment/locale/pt.js",
      "./pt-br": "./node_modules/moment/locale/pt-br.js",
      "./pt-br.js": "./node_modules/moment/locale/pt-br.js",
      "./pt.js": "./node_modules/moment/locale/pt.js",
      "./ro": "./node_modules/moment/locale/ro.js",
      "./ro.js": "./node_modules/moment/locale/ro.js",
      "./ru": "./node_modules/moment/locale/ru.js",
      "./ru.js": "./node_modules/moment/locale/ru.js",
      "./sd": "./node_modules/moment/locale/sd.js",
      "./sd.js": "./node_modules/moment/locale/sd.js",
      "./se": "./node_modules/moment/locale/se.js",
      "./se.js": "./node_modules/moment/locale/se.js",
      "./si": "./node_modules/moment/locale/si.js",
      "./si.js": "./node_modules/moment/locale/si.js",
      "./sk": "./node_modules/moment/locale/sk.js",
      "./sk.js": "./node_modules/moment/locale/sk.js",
      "./sl": "./node_modules/moment/locale/sl.js",
      "./sl.js": "./node_modules/moment/locale/sl.js",
      "./sq": "./node_modules/moment/locale/sq.js",
      "./sq.js": "./node_modules/moment/locale/sq.js",
      "./sr": "./node_modules/moment/locale/sr.js",
      "./sr-cyrl": "./node_modules/moment/locale/sr-cyrl.js",
      "./sr-cyrl.js": "./node_modules/moment/locale/sr-cyrl.js",
      "./sr.js": "./node_modules/moment/locale/sr.js",
      "./ss": "./node_modules/moment/locale/ss.js",
      "./ss.js": "./node_modules/moment/locale/ss.js",
      "./sv": "./node_modules/moment/locale/sv.js",
      "./sv.js": "./node_modules/moment/locale/sv.js",
      "./sw": "./node_modules/moment/locale/sw.js",
      "./sw.js": "./node_modules/moment/locale/sw.js",
      "./ta": "./node_modules/moment/locale/ta.js",
      "./ta.js": "./node_modules/moment/locale/ta.js",
      "./te": "./node_modules/moment/locale/te.js",
      "./te.js": "./node_modules/moment/locale/te.js",
      "./tet": "./node_modules/moment/locale/tet.js",
      "./tet.js": "./node_modules/moment/locale/tet.js",
      "./tg": "./node_modules/moment/locale/tg.js",
      "./tg.js": "./node_modules/moment/locale/tg.js",
      "./th": "./node_modules/moment/locale/th.js",
      "./th.js": "./node_modules/moment/locale/th.js",
      "./tl-ph": "./node_modules/moment/locale/tl-ph.js",
      "./tl-ph.js": "./node_modules/moment/locale/tl-ph.js",
      "./tlh": "./node_modules/moment/locale/tlh.js",
      "./tlh.js": "./node_modules/moment/locale/tlh.js",
      "./tr": "./node_modules/moment/locale/tr.js",
      "./tr.js": "./node_modules/moment/locale/tr.js",
      "./tzl": "./node_modules/moment/locale/tzl.js",
      "./tzl.js": "./node_modules/moment/locale/tzl.js",
      "./tzm": "./node_modules/moment/locale/tzm.js",
      "./tzm-latn": "./node_modules/moment/locale/tzm-latn.js",
      "./tzm-latn.js": "./node_modules/moment/locale/tzm-latn.js",
      "./tzm.js": "./node_modules/moment/locale/tzm.js",
      "./ug-cn": "./node_modules/moment/locale/ug-cn.js",
      "./ug-cn.js": "./node_modules/moment/locale/ug-cn.js",
      "./uk": "./node_modules/moment/locale/uk.js",
      "./uk.js": "./node_modules/moment/locale/uk.js",
      "./ur": "./node_modules/moment/locale/ur.js",
      "./ur.js": "./node_modules/moment/locale/ur.js",
      "./uz": "./node_modules/moment/locale/uz.js",
      "./uz-latn": "./node_modules/moment/locale/uz-latn.js",
      "./uz-latn.js": "./node_modules/moment/locale/uz-latn.js",
      "./uz.js": "./node_modules/moment/locale/uz.js",
      "./vi": "./node_modules/moment/locale/vi.js",
      "./vi.js": "./node_modules/moment/locale/vi.js",
      "./x-pseudo": "./node_modules/moment/locale/x-pseudo.js",
      "./x-pseudo.js": "./node_modules/moment/locale/x-pseudo.js",
      "./yo": "./node_modules/moment/locale/yo.js",
      "./yo.js": "./node_modules/moment/locale/yo.js",
      "./zh-cn": "./node_modules/moment/locale/zh-cn.js",
      "./zh-cn.js": "./node_modules/moment/locale/zh-cn.js",
      "./zh-hk": "./node_modules/moment/locale/zh-hk.js",
      "./zh-hk.js": "./node_modules/moment/locale/zh-hk.js",
      "./zh-tw": "./node_modules/moment/locale/zh-tw.js",
      "./zh-tw.js": "./node_modules/moment/locale/zh-tw.js"
    };

    function webpackContext(req) {
      var id = webpackContextResolve(req);
      return __webpack_require__(id);
    }

    function webpackContextResolve(req) {
      if (!__webpack_require__.o(map, req)) {
        var e = new Error("Cannot find module '" + req + "'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
      }

      return map[req];
    }

    webpackContext.keys = function webpackContextKeys() {
      return Object.keys(map);
    };

    webpackContext.resolve = webpackContextResolve;
    module.exports = webpackContext;
    webpackContext.id = "./node_modules/moment/locale sync recursive ^\\.\\/.*$";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/app.component.html":
  /*!**************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/app.component.html ***!
    \**************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppAppComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<router-outlet></router-outlet>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/calendar/calendar.component.html":
  /*!***************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/calendar/calendar.component.html ***!
    \***************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsCalendarCalendarComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<p>calendar works!</p>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/area-chart/area-chart.component.html":
  /*!**************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/area-chart/area-chart.component.html ***!
    \**************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsChartsAreaChartAreaChartComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div class=\"chart-area\">\n    <canvas id=\"myAreaChart\"></canvas>\n  </div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/bar-chart/bar-chart.component.html":
  /*!************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/bar-chart/bar-chart.component.html ***!
    \************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsChartsBarChartBarChartComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div class=\"chart-area\">\n    <canvas id=\"myBarChart\"></canvas>\n  </div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/charts.component.html":
  /*!***********************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/charts.component.html ***!
    \***********************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsChartsChartsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Heading -->\r\n<h1 class=\"h3 mb-2 text-gray-800\">Charts</h1>\r\n<p class=\"mb-4\">Chart.js is a third party plugin that is used to generate the charts in this theme. The charts below have been customized - for further customization options, please visit the <a target=\"_blank\" href=\"https://www.chartjs.org/docs/latest/\">official Chart.js documentation</a>.</p>\r\n\r\n<!-- Content Row -->\r\n<div class=\"row\">\r\n\r\n  <div class=\"col-xl-8 col-lg-7\">\r\n\r\n    <!-- Area Chart -->\r\n    <div class=\"card shadow mb-4\">\r\n      <div class=\"card-header py-3\">\r\n        <h6 class=\"m-0 font-weight-bold text-primary\">Area Chart</h6>\r\n      </div>\r\n      <div class=\"card-body\">\r\n        <app-area-chart\r\n        [labels]=\"labels\"\r\n        [data]=\"data\"\r\n        ></app-area-chart>\r\n        <hr>\r\n        Styling for the area chart can be found in the <code>/js/demo/chart-area-demo.js</code> file.\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Bar Chart -->\r\n    <div class=\"card shadow mb-4\">\r\n      <div class=\"card-header py-3\">\r\n        <h6 class=\"m-0 font-weight-bold text-primary\">Bar Chart</h6>\r\n      </div>\r\n      <div class=\"card-body\">\r\n        <app-bar-chart\r\n        [labels]=\"labels\"\r\n        [data]=\"data\"\r\n        ></app-bar-chart>\r\n        <hr>\r\n        Styling for the bar chart can be found in the <code>/js/demo/chart-bar-demo.js</code> file.\r\n      </div>\r\n    </div>\r\n\r\n  </div>\r\n\r\n  <!-- Donut Chart -->\r\n  <div class=\"col-xl-4 col-lg-5\">\r\n    <div class=\"card shadow mb-4\">\r\n      <!-- Card Header - Dropdown -->\r\n      <div class=\"card-header py-3\">\r\n        <h6 class=\"m-0 font-weight-bold text-primary\">Donut Chart</h6>\r\n      </div>\r\n      <!-- Card Body -->\r\n      <div class=\"card-body\">\r\n        <app-pie-chart\r\n        [labels]=\"labels\"\r\n        [data]=\"data\"\r\n        ></app-pie-chart>\r\n        <hr>\r\n        Styling for the donut chart can be found in the <code>/js/demo/chart-pie-demo.js</code> file.\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"card shadow mb-4\">\r\n      <!-- Card Header - Dropdown -->\r\n      <div class=\"card-header py-3\">\r\n        <h6 class=\"m-0 font-weight-bold text-primary\">Progress Bar</h6>\r\n      </div>\r\n      <!-- Card Body -->\r\n      <div class=\"card-body\">\r\n        <app-progress-bar></app-progress-bar>\r\n        <hr>\r\n        Styling for the donut chart can be found in the <code>/js/demo/chart-pie-demo.js</code> file.\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n\r\n\r\n\r\n</div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/pie-chart/pie-chart.component.html":
  /*!************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/pie-chart/pie-chart.component.html ***!
    \************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsChartsPieChartPieChartComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div class=\"chart-area\">\n    <canvas id=\"myPieChart\"></canvas>\n</div>\n<div class=\"mt-4 text-center small\">\n  <span class=\"mr-2\" *ngFor=\"let label of labels, let i = index\">\n    <i class=\"fas fa-circle\" [style]=\"{color:bgColors[i]}\"></i> {{label}}\n  </span>\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/alerts/alerts.component.html":
  /*!******************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/alerts/alerts.component.html ***!
    \******************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsCommonAlertsAlertsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Nav Item - Alerts -->\r\n<li class=\"nav-item dropdown no-arrow mx-1\">\r\n    <a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"alertsDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\r\n      <i class=\"fas fa-bell fa-fw\"></i>\r\n      <!-- Counter - Alerts -->\r\n      <span class=\"badge badge-danger badge-counter\">3+</span>\r\n    </a>\r\n    <!-- Dropdown - Alerts -->\r\n    <div class=\"dropdown-list dropdown-menu dropdown-menu-right shadow animated--grow-in\" aria-labelledby=\"alertsDropdown\">\r\n      <h6 class=\"dropdown-header\">\r\n        Alerts Center\r\n      </h6>\r\n      <a class=\"dropdown-item d-flex align-items-center\" href=\"#\">\r\n        <div class=\"mr-3\">\r\n          <div class=\"icon-circle bg-primary\">\r\n            <i class=\"fas fa-file-alt text-white\"></i>\r\n          </div>\r\n        </div>\r\n        <div>\r\n          <div class=\"small text-gray-500\">December 12, 2019</div>\r\n          <span class=\"font-weight-bold\">A new monthly report is ready to download!</span>\r\n        </div>\r\n      </a>\r\n      <a class=\"dropdown-item d-flex align-items-center\" href=\"#\">\r\n        <div class=\"mr-3\">\r\n          <div class=\"icon-circle bg-success\">\r\n            <i class=\"fas fa-donate text-white\"></i>\r\n          </div>\r\n        </div>\r\n        <div>\r\n          <div class=\"small text-gray-500\">December 7, 2019</div>\r\n          $290.29 has been deposited into your account!\r\n        </div>\r\n      </a>\r\n      <a class=\"dropdown-item d-flex align-items-center\" href=\"#\">\r\n        <div class=\"mr-3\">\r\n          <div class=\"icon-circle bg-warning\">\r\n            <i class=\"fas fa-exclamation-triangle text-white\"></i>\r\n          </div>\r\n        </div>\r\n        <div>\r\n          <div class=\"small text-gray-500\">December 2, 2019</div>\r\n          Spending Alert: We've noticed unusually high spending for your account.\r\n        </div>\r\n      </a>\r\n      <a class=\"dropdown-item text-center small text-gray-500\" href=\"#\">Show All Alerts</a>\r\n    </div>\r\n  </li>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/footer/footer.component.html":
  /*!******************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/footer/footer.component.html ***!
    \******************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsCommonFooterFooterComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Footer -->\r\n<footer class=\"sticky-footer bg-white\">\r\n    <div class=\"container my-auto\">\r\n      <div class=\"copyright text-center my-auto\">\r\n        <span>Copyright &copy; Your Website 2020</span>\r\n      </div>\r\n    </div>\r\n  </footer>\r\n  <!-- End of Footer -->";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/logout/logout.component.html":
  /*!******************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/logout/logout.component.html ***!
    \******************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsCommonLogoutLogoutComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Logout Modal-->\r\n<div class=\"modal fade\" id=\"logoutModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"exampleModalLabel\" aria-hidden=\"true\">\r\n    <div class=\"modal-dialog\" role=\"document\">\r\n      <div class=\"modal-content\">\r\n        <div class=\"modal-header\">\r\n          <h5 class=\"modal-title\" id=\"exampleModalLabel\">¿Listo Para Irte?</h5>\r\n          <button class=\"close\" type=\"button\" data-dismiss=\"modal\" aria-label=\"Close\">\r\n            <span aria-hidden=\"true\">×</span>\r\n          </button>\r\n        </div>\r\n        <div class=\"modal-body\">Seleciona \"Salir\" aquí abajo para terminar esta sesión.</div>\r\n        <div class=\"modal-footer\">\r\n          <button class=\"btn btn-secondary\" type=\"button\" data-dismiss=\"modal\">Cancelar</button>\r\n          <a class=\"btn btn-primary\" (click)=\"logout()\">Salir</a>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/message/message.component.html":
  /*!********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/message/message.component.html ***!
    \********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsCommonMessageMessageComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = " <!-- Nav Item - Messages -->\r\n <li class=\"nav-item dropdown no-arrow mx-1\">\r\n    <a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"messagesDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\r\n      <i class=\"fas fa-envelope fa-fw\"></i>\r\n      <!-- Counter - Messages -->\r\n      <span class=\"badge badge-danger badge-counter\">7</span>\r\n    </a>\r\n    <!-- Dropdown - Messages -->\r\n    <div class=\"dropdown-list dropdown-menu dropdown-menu-right shadow animated--grow-in\" aria-labelledby=\"messagesDropdown\">\r\n      <h6 class=\"dropdown-header\">\r\n        Message Center\r\n      </h6>\r\n      <a class=\"dropdown-item d-flex align-items-center\" href=\"#\">\r\n        <div class=\"dropdown-list-image mr-3\">\r\n          <img class=\"rounded-circle\" src=\"https://source.unsplash.com/fn_BT9fwg_E/60x60\" alt=\"\">\r\n          <div class=\"status-indicator bg-success\"></div>\r\n        </div>\r\n        <div class=\"font-weight-bold\">\r\n          <div class=\"text-truncate\">Hi there! I am wondering if you can help me with a problem I've been having.</div>\r\n          <div class=\"small text-gray-500\">Emily Fowler · 58m</div>\r\n        </div>\r\n      </a>\r\n      <a class=\"dropdown-item d-flex align-items-center\" href=\"#\">\r\n        <div class=\"dropdown-list-image mr-3\">\r\n          <img class=\"rounded-circle\" src=\"https://source.unsplash.com/AU4VPcFN4LE/60x60\" alt=\"\">\r\n          <div class=\"status-indicator\"></div>\r\n        </div>\r\n        <div>\r\n          <div class=\"text-truncate\">I have the photos that you ordered last month, how would you like them sent to you?</div>\r\n          <div class=\"small text-gray-500\">Jae Chun · 1d</div>\r\n        </div>\r\n      </a>\r\n      <a class=\"dropdown-item d-flex align-items-center\" href=\"#\">\r\n        <div class=\"dropdown-list-image mr-3\">\r\n          <img class=\"rounded-circle\" src=\"https://source.unsplash.com/CS2uCrpNzJY/60x60\" alt=\"\">\r\n          <div class=\"status-indicator bg-warning\"></div>\r\n        </div>\r\n        <div>\r\n          <div class=\"text-truncate\">Last month's report looks great, I am very happy with the progress so far, keep up the good work!</div>\r\n          <div class=\"small text-gray-500\">Morgan Alvarez · 2d</div>\r\n        </div>\r\n      </a>\r\n      <a class=\"dropdown-item d-flex align-items-center\" href=\"#\">\r\n        <div class=\"dropdown-list-image mr-3\">\r\n          <img class=\"rounded-circle\" src=\"https://source.unsplash.com/Mv9hjnEUHR4/60x60\" alt=\"\">\r\n          <div class=\"status-indicator bg-success\"></div>\r\n        </div>\r\n        <div>\r\n          <div class=\"text-truncate\">Am I a good boy? The reason I ask is because someone told me that people say this to all dogs, even if they aren't good...</div>\r\n          <div class=\"small text-gray-500\">Chicken the Dog · 2w</div>\r\n        </div>\r\n      </a>\r\n      <a class=\"dropdown-item text-center small text-gray-500\" href=\"#\">Read More Messages</a>\r\n    </div>\r\n  </li>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/search/search.component.html":
  /*!******************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/search/search.component.html ***!
    \******************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsCommonSearchSearchComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Topbar Search -->\r\n<form class=\"d-none d-sm-inline-block form-inline mr-auto ml-md-3 my-2 my-md-0 mw-100 navbar-search\">\r\n    <div class=\"input-group\">\r\n      <input type=\"text\" class=\"form-control bg-light border-0 small\" placeholder=\"Search for...\" aria-label=\"Search\" aria-describedby=\"basic-addon2\">\r\n      <div class=\"input-group-append\">\r\n        <button class=\"btn btn-primary\" type=\"button\">\r\n          <i class=\"fas fa-search fa-sm\"></i>\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </form>\r\n\r\n  <!-- Nav Item - Search Dropdown (Visible Only XS) -->\r\n  <li class=\"nav-item dropdown no-arrow d-sm-none\">\r\n    <a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"searchDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\r\n      <i class=\"fas fa-search fa-fw\"></i>\r\n    </a>\r\n    <!-- Dropdown - Messages -->\r\n    <div class=\"dropdown-menu dropdown-menu-right p-3 shadow animated--grow-in\" aria-labelledby=\"searchDropdown\">\r\n      <form class=\"form-inline mr-auto w-100 navbar-search\">\r\n        <div class=\"input-group\">\r\n          <input type=\"text\" class=\"form-control bg-light border-0 small\" placeholder=\"Search for...\" aria-label=\"Search\" aria-describedby=\"basic-addon2\">\r\n          <div class=\"input-group-append\">\r\n            <button class=\"btn btn-primary\" type=\"button\">\r\n              <i class=\"fas fa-search fa-sm\"></i>\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </form>\r\n    </div>\r\n  </li>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/sidebar/sidebar.component.html":
  /*!********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/sidebar/sidebar.component.html ***!
    \********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsCommonSidebarSidebarComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Sidebar -->\r\n<ul class=\"navbar-nav bg-gradient-primary sidebar sidebar-dark accordion h-100\" id=\"accordionSidebar\" #accordionSidebar>\r\n\r\n    <!-- Sidebar - Brand -->\r\n    <a class=\"sidebar-brand d-flex align-items-center justify-content-center\" routerLink=\"/dashboard\">\r\n      <div class=\"sidebar-brand-icon rotate-n-15\">\r\n        <i class=\"fab fa-angular\"></i>\r\n      </div>\r\n      <div class=\"sidebar-brand-text mx-3\">{{webTitle}} <sup>{{webTitleSup}}</sup></div>\r\n    </a>\r\n\r\n    <!-- Divider -->\r\n    <hr class=\"sidebar-divider my-0\">\r\n\r\n    <div *ngFor=\"let group of menuGroups\" id=\"group_{{group.id}}\">\r\n      <!-- Heading -->\r\n      <div class=\"sidebar-heading\">\r\n        {{group.title}}\r\n      </div>\r\n      <!-- Nav Item - Dashboard -->\r\n      <li class=\"nav-item\" *ngFor=\"let menu of group.menu\" id=\"item_{{menu.id}}\">\r\n        <!-- MENU SIN SUBMENU -->\r\n        <div *ngIf=\"menu.link!=''\">  \r\n          <a class=\"nav-link\" routerLink=\"{{menu.link}}\">\r\n            <i class=\"{{menu.icon}}\"></i>\r\n            <span>{{menu.title}}</span>\r\n          </a>\r\n        </div>\r\n        \r\n        <!-- MENU CON SUBMENU -->\r\n        <div *ngIf=\"menu.link==''\" id=\"menu_{{menu.id}}\">          \r\n          <a class=\"nav-link collapsed\" id=\"menu_name_{{menu.id}}\" data-toggle=\"collapse\" (click)=\"toggleSubmenu(group.id, menu.id)\" style=\"cursor: pointer;\">\r\n            <i class=\"{{menu.icon}}\"></i>\r\n            <span>{{menu.title}}</span>\r\n          </a>\r\n          <!-- LISTA DE SUBMENUES -->\r\n          <div id=\"submenu_{{menu.id}}\" class=\"collapse\" aria-labelledby=\"headingTwo\" data-parent=\"#accordionSidebar\">\r\n            <div class=\"bg-white py-2 collapse-inner rounded\">\r\n              <h6 class=\"collapse-header\">{{menu.subtitle}}:</h6>\r\n              <a class=\"collapse-item\"*ngFor=\"let submenu of menu.submenu\" routerLink=\"{{submenu.link}}\">{{submenu.title}}</a>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n\r\n      </li>\r\n\r\n      <!-- Divider -->\r\n      <hr class=\"sidebar-divider\">\r\n    </div>\r\n\r\n    <!-- Sidebar Toggler (Sidebar) -->\r\n    <div class=\"text-center d-none d-md-inline\" (click)=\"toggle()\">\r\n      <button class=\"rounded-circle border-0\" id=\"sidebarToggle\"></button>\r\n    </div>\r\n\r\n  </ul>\r\n  <!-- End of Sidebar -->";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/topbar/topbar.component.html":
  /*!******************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/topbar/topbar.component.html ***!
    \******************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsCommonTopbarTopbarComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Topbar -->\r\n<nav class=\"navbar navbar-expand navbar-light bg-white topbar mb-4 static-top shadow\">\r\n\r\n    <!-- Sidebar Toggle (Topbar) -->\r\n    <button id=\"sidebarToggleTop\" class=\"btn btn-link d-md-none rounded-circle mr-3\" (click)=toggleSideBar()>\r\n      <i class=\"fa fa-bars\"></i>\r\n    </button>\r\n\r\n    <!-- Topbar Search -->\r\n    <app-search class=\"d-none d-md-inline\"></app-search>\r\n\r\n    <!-- Topbar Navbar -->\r\n    <ul class=\"navbar-nav ml-auto\">\r\n        <app-search class=\"d-sm-none d-xs-inline\"></app-search>\r\n      <!-- Nav Item - Alerts -->\r\n      <app-alerts></app-alerts>\r\n\r\n      <!-- Nav Item - Messages -->\r\n      <app-message></app-message>\r\n\r\n      <div class=\"topbar-divider d-none d-sm-block\"></div>\r\n\r\n      <!-- Nav Item - User Information -->\r\n      <app-user-info></app-user-info>\r\n\r\n    </ul>\r\n\r\n  </nav>\r\n  <!-- End of Topbar -->";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/user-info/user-info.component.html":
  /*!************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/user-info/user-info.component.html ***!
    \************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsCommonUserInfoUserInfoComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Nav Item - User Information -->\r\n<li class=\"nav-item dropdown no-arrow\">\r\n    <a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"userDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\r\n      <span class=\"mr-2 d-none d-lg-inline text-gray-600 small\">Daniel Boggiano</span>\r\n      <img class=\"img-profile rounded-circle\" src=\"http://138.197.196.196/api/imagenes/11.jpg\">\r\n    </a>\r\n    <!-- Dropdown - User Information -->\r\n    <div class=\"dropdown-menu dropdown-menu-right shadow animated--grow-in\" aria-labelledby=\"userDropdown\">\r\n      <a class=\"dropdown-item\" routerLink=\"profile\">\r\n        <i class=\"fas fa-user fa-sm fa-fw mr-2 text-gray-400\"></i>\r\n        Profile\r\n      </a>\r\n      <a class=\"dropdown-item\" routerLink=\"\">\r\n        <i class=\"fas fa-cogs fa-sm fa-fw mr-2 text-gray-400\"></i>\r\n        Settings\r\n      </a>\r\n      <a class=\"dropdown-item\" routerLink=\"\">\r\n        <i class=\"fas fa-list fa-sm fa-fw mr-2 text-gray-400\"></i>\r\n        Activity Log\r\n      </a>\r\n      <div class=\"dropdown-divider\"></div>\r\n      <a class=\"dropdown-item\" routerLink=\"/login\" data-toggle=\"modal\" data-target=\"#logoutModal\">\r\n        <i class=\"fas fa-sign-out-alt fa-sm fa-fw mr-2 text-gray-400\"></i>\r\n        Logout\r\n      </a>\r\n    </div>\r\n  </li>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/configuration/configuration.component.html":
  /*!*************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/configuration/configuration.component.html ***!
    \*************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsConfigurationConfigurationComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<p>configuration works!</p>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/dashboard/dashboard.component.html":
  /*!*****************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/dashboard/dashboard.component.html ***!
    \*****************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsDashboardDashboardComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Heading -->\r\n<div class=\"d-sm-flex align-items-center justify-content-between mb-4\">\r\n    <h1 class=\"h3 mb-0 text-gray-800\">Dashboard</h1>\r\n    <a href=\"#\" class=\"d-none d-sm-inline-block btn btn-sm btn-primary shadow-sm\"><i class=\"fas fa-download fa-sm text-white-50\"></i> Generate Report</a>\r\n  </div>\r\n\r\n  <!-- Content Row -->\r\n  <div class=\"row\">\r\n\r\n    <!-- Earnings (Monthly) Card Example -->\r\n    <div class=\"col-xl-3 col-md-6 mb-4\">\r\n      <div class=\"card border-left-primary shadow h-100 py-2\">\r\n        <div class=\"card-body\">\r\n          <div class=\"row no-gutters align-items-center\">\r\n            <div class=\"col mr-2\">\r\n              <div class=\"text-xs font-weight-bold text-primary text-uppercase mb-1\">Earnings (Monthly)</div>\r\n              <div class=\"h5 mb-0 font-weight-bold text-gray-800\">$40,000</div>\r\n            </div>\r\n            <div class=\"col-auto\">\r\n              <i class=\"fas fa-calendar fa-2x text-gray-300\"></i>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Earnings (Monthly) Card Example -->\r\n    <div class=\"col-xl-3 col-md-6 mb-4\">\r\n      <div class=\"card border-left-success shadow h-100 py-2\">\r\n        <div class=\"card-body\">\r\n          <div class=\"row no-gutters align-items-center\">\r\n            <div class=\"col mr-2\">\r\n              <div class=\"text-xs font-weight-bold text-success text-uppercase mb-1\">Earnings (Annual)</div>\r\n              <div class=\"h5 mb-0 font-weight-bold text-gray-800\">$215,000</div>\r\n            </div>\r\n            <div class=\"col-auto\">\r\n              <i class=\"fas fa-dollar-sign fa-2x text-gray-300\"></i>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Earnings (Monthly) Card Example -->\r\n    <div class=\"col-xl-3 col-md-6 mb-4\">\r\n      <div class=\"card border-left-info shadow h-100 py-2\">\r\n        <div class=\"card-body\">\r\n          <div class=\"row no-gutters align-items-center\">\r\n            <div class=\"col mr-2\">\r\n              <div class=\"text-xs font-weight-bold text-info text-uppercase mb-1\">Tasks</div>\r\n              <div class=\"row no-gutters align-items-center\">\r\n                <div class=\"col-auto\">\r\n                  <div class=\"h5 mb-0 mr-3 font-weight-bold text-gray-800\">50%</div>\r\n                </div>\r\n                <div class=\"col\">\r\n                  <div class=\"progress progress-sm mr-2\">\r\n                    <div class=\"progress-bar bg-info\" role=\"progressbar\" style=\"width: 50%\" aria-valuenow=\"50\" aria-valuemin=\"0\" aria-valuemax=\"100\"></div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n            <div class=\"col-auto\">\r\n              <i class=\"fas fa-clipboard-list fa-2x text-gray-300\"></i>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Pending Requests Card Example -->\r\n    <div class=\"col-xl-3 col-md-6 mb-4\">\r\n      <div class=\"card border-left-warning shadow h-100 py-2\">\r\n        <div class=\"card-body\">\r\n          <div class=\"row no-gutters align-items-center\">\r\n            <div class=\"col mr-2\">\r\n              <div class=\"text-xs font-weight-bold text-warning text-uppercase mb-1\">Pending Requests</div>\r\n              <div class=\"h5 mb-0 font-weight-bold text-gray-800\">18</div>\r\n            </div>\r\n            <div class=\"col-auto\">\r\n              <i class=\"fas fa-comments fa-2x text-gray-300\"></i>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <!-- Content Row -->\r\n\r\n  <div class=\"row\">\r\n\r\n    <!-- Area Chart -->\r\n    <!-- <div class=\"col-xl-8 col-lg-7\">\r\n      <div class=\"card shadow mb-4\"> -->\r\n        <!-- Card Header - Dropdown -->\r\n        <!-- <div class=\"card-header py-3 d-flex flex-row align-items-center justify-content-between\">\r\n          <h6 class=\"m-0 font-weight-bold text-primary\">Earnings Overview</h6>\r\n          <div class=\"dropdown no-arrow\">\r\n            <a class=\"dropdown-toggle\" href=\"#\" role=\"button\" id=\"dropdownMenuLink\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\r\n              <i class=\"fas fa-ellipsis-v fa-sm fa-fw text-gray-400\"></i>\r\n            </a>\r\n            <div class=\"dropdown-menu dropdown-menu-right shadow animated--fade-in\" aria-labelledby=\"dropdownMenuLink\">\r\n              <div class=\"dropdown-header\">Dropdown Header:</div>\r\n              <a class=\"dropdown-item\" href=\"#\">Action</a>\r\n              <a class=\"dropdown-item\" href=\"#\">Another action</a>\r\n              <div class=\"dropdown-divider\"></div>\r\n              <a class=\"dropdown-item\" href=\"#\">Something else here</a>\r\n            </div>\r\n          </div>\r\n        </div> -->\r\n        <!-- Card Body -->\r\n        <!-- <div class=\"card-body\">\r\n          \r\n            <app-area-chart\r\n                [labels]=\"labels\"\r\n                [data]=\"data\"\r\n            ></app-area-chart>\r\n          \r\n        </div>\r\n      </div>\r\n    </div> -->\r\n\r\n    <!-- Pie Chart -->\r\n    <!-- <div class=\"col-xl-4 col-lg-5\">\r\n      <div class=\"card shadow mb-4\"> -->\r\n        <!-- Card Header - Dropdown -->\r\n        <!-- <div class=\"card-header py-3 d-flex flex-row align-items-center justify-content-between\">\r\n          <h6 class=\"m-0 font-weight-bold text-primary\">Revenue Sources</h6>\r\n          <div class=\"dropdown no-arrow\">\r\n            <a class=\"dropdown-toggle\" href=\"#\" role=\"button\" id=\"dropdownMenuLink\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\r\n              <i class=\"fas fa-ellipsis-v fa-sm fa-fw text-gray-400\"></i>\r\n            </a>\r\n            <div class=\"dropdown-menu dropdown-menu-right shadow animated--fade-in\" aria-labelledby=\"dropdownMenuLink\">\r\n              <div class=\"dropdown-header\">Dropdown Header:</div>\r\n              <a class=\"dropdown-item\" href=\"#\">Action</a>\r\n              <a class=\"dropdown-item\" href=\"#\">Another action</a>\r\n              <div class=\"dropdown-divider\"></div>\r\n              <a class=\"dropdown-item\" href=\"#\">Something else here</a>\r\n            </div>\r\n          </div>\r\n        </div> -->\r\n        <!-- Card Body -->\r\n        <!-- <div class=\"card-body\">\r\n            <app-pie-chart\r\n            [labels]=\"labels2\"\r\n            [data]=\"data2\"\r\n            ></app-pie-chart>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div> -->\r\n\r\n  <!-- Content Row -->\r\n  <div class=\"row\">\r\n\r\n    <!-- Content Column -->\r\n    <div class=\"col-lg-6 mb-4\">\r\n\r\n      <!-- Project Card Example -->\r\n      <div class=\"card shadow mb-4\">\r\n        <div class=\"card-header py-3\">\r\n          <h6 class=\"m-0 font-weight-bold text-primary\">Projects</h6>\r\n        </div>\r\n        <div class=\"card-body\">\r\n          \r\n            <app-progress-bar></app-progress-bar>\r\n\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Color System -->\r\n      <div class=\"row\">\r\n        <div class=\"col-lg-6 mb-4\">\r\n          <div class=\"card bg-primary text-white shadow\">\r\n            <div class=\"card-body\">\r\n              Primary\r\n              <div class=\"text-white-50 small\">#4e73df</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"col-lg-6 mb-4\">\r\n          <div class=\"card bg-success text-white shadow\">\r\n            <div class=\"card-body\">\r\n              Success\r\n              <div class=\"text-white-50 small\">#1cc88a</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"col-lg-6 mb-4\">\r\n          <div class=\"card bg-info text-white shadow\">\r\n            <div class=\"card-body\">\r\n              Info\r\n              <div class=\"text-white-50 small\">#36b9cc</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"col-lg-6 mb-4\">\r\n          <div class=\"card bg-warning text-white shadow\">\r\n            <div class=\"card-body\">\r\n              Warning\r\n              <div class=\"text-white-50 small\">#f6c23e</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"col-lg-6 mb-4\">\r\n          <div class=\"card bg-danger text-white shadow\">\r\n            <div class=\"card-body\">\r\n              Danger\r\n              <div class=\"text-white-50 small\">#e74a3b</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"col-lg-6 mb-4\">\r\n          <div class=\"card bg-secondary text-white shadow\">\r\n            <div class=\"card-body\">\r\n              Secondary\r\n              <div class=\"text-white-50 small\">#858796</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n    </div>\r\n\r\n    <div class=\"col-lg-6 mb-4\">\r\n\r\n      <!-- Illustrations -->\r\n      <div class=\"card shadow mb-4\">\r\n        <div class=\"card-header py-3\">\r\n          <h6 class=\"m-0 font-weight-bold text-primary\">Illustrations</h6>\r\n        </div>\r\n        <div class=\"card-body\">\r\n          <div class=\"text-center\">\r\n            <img class=\"img-fluid px-3 px-sm-4 mt-3 mb-4\" style=\"width: 25rem;\" src=\"assets/img/undraw_posting_photo.svg\" alt=\"\">\r\n          </div>\r\n          <p>Add some quality, svg illustrations to your project courtesy of <a target=\"_blank\" rel=\"nofollow\" href=\"https://undraw.co/\">unDraw</a>, a constantly updated collection of beautiful svg images that you can use completely free and without attribution!</p>\r\n          <a target=\"_blank\" rel=\"nofollow\" href=\"https://undraw.co/\">Browse Illustrations on unDraw &rarr;</a>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Approach -->\r\n      <div class=\"card shadow mb-4\">\r\n        <div class=\"card-header py-3\">\r\n          <h6 class=\"m-0 font-weight-bold text-primary\">Development Approach</h6>\r\n        </div>\r\n        <div class=\"card-body\">\r\n          <p>SB Admin 2 makes extensive use of Bootstrap 4 utility classes in order to reduce CSS bloat and poor page performance. Custom CSS classes are used to create custom components and custom utility classes.</p>\r\n          <p class=\"mb-0\">Before working with this theme, you should become familiar with the Bootstrap framework, especially the utility classes.</p>\r\n        </div>\r\n      </div>\r\n\r\n    </div>\r\n  </div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/datatable.component.html":
  /*!*****************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/datatable.component.html ***!
    \*****************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsDatatableDatatableComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<h1 class=\"h3 mb-2 text-gray-800\">{{pageTitle}}</h1>\r\n<p class=\"mb-4\">{{pageDescription}}</p>\r\n\r\n<!-- DataTales Example -->\r\n<div class=\"card shadow mb-4\">\r\n\r\n    <div class=\"card-header py-3\">\r\n        <h6 class=\"m-0 font-weight-bold text-primary\">{{cardTitle}}\r\n            <button class=\"btn btn-primary mx-2 float-right\"><i class=\"fa fa-plus\"></i><span class=\"d-none d-md-inline\"> Agregar Usuario</span></button>\r\n        </h6>\r\n    </div>\r\n\r\n    <div class=\"card-body\">\r\n\r\n        <div class=\"card-title\">\r\n            <!-- SEARCH BUTTON -->\r\n            <form class=\" d-sm-inline-block form-inline mr-auto my-2 my-md-0 mw-100 navbar-search\" (submit)=\"loadData()\">\r\n                <div class=\"input-group\">\r\n                <input type=\"text\" class=\"form-control bg-light border-0 small\" placeholder=\"Filter...\" aria-label=\"Search\" aria-describedby=\"basic-addon2\" name=\"filterValue\" [(ngModel)]=\"filterValue\">\r\n                <div class=\"input-group-append\">\r\n                    <button class=\"btn btn-primary\" type=\"submit\">\r\n                    <i class=\"fas fa-search fa-sm\"></i><span class=\"d-none d-md-inlie\"> Search</span>\r\n                    </button>\r\n                </div>\r\n                </div>\r\n            </form>            \r\n            <app-filter-columns [columns]=\"tableColumns\" (loadColumns)=\"loadColumns($event)\"></app-filter-columns>\r\n            <app-reports *ngIf=\"dataSource\" [columns]=\"tableColumns\" [data]=\"csvData\"></app-reports>\r\n        </div>\r\n\r\n        <div class=\"d-none d-sm-block\" style=\"max-height: 500px; overflow-y: scroll;\">\r\n            <table mat-table [dataSource]=\"dataSource\" matSort class=\"w-100 table\" (matSortChange)=\"sortData($event)\">\r\n                <div *ngFor=\"let col of tableColumns\">\r\n                    <ng-container matColumnDef=\"{{col.id}}\">\r\n                        <th mat-header-cell *matHeaderCellDef mat-sort-header class=\"text text-primary p-2\" [hidden]=\"!col.visible\"><h6>{{col.title}}</h6></th>\r\n                        <td mat-cell *matCellDef=\"let element\" class=\"p-2\" [hidden]=\"!col.visible\">\r\n                            <span *ngIf=\"['options','createdAt','updatedAt','deletedAt'].indexOf(col.key) == -1\">{{ element[col.key] }}</span>\r\n                            <span *ngIf=\"['options','createdAt','updatedAt','deletedAt'].indexOf(col.key) > -1\">{{ element[col.key] }}</span>\r\n                            <span *ngIf=\"col.key=='options'\">\r\n                                <button class=\"btn btn-danger btn-circle btn-sm m-1\" (click)=\"delete(element.id)\"><i class=\"fa fa-trash\"></i></button>\r\n                                <button class=\"btn btn-primary btn-circle btn-sm m-1\" (click)=\"edit(element.id)\"><i class=\"fa fa-edit\"></i></button>\r\n                            </span>\r\n                        </td>\r\n                    </ng-container>\r\n                </div>\r\n                <tr mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"></tr>\r\n                <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"></tr>\r\n            </table>\r\n        </div>\r\n\r\n        <!-- RESPONSIVE -->\r\n        <div class=\"d-xs-block d-sm-none\" *ngIf=\"dataSource\" style=\"max-height: 600px; overflow-y: scroll;\">\r\n            <mat-accordion>\r\n                <mat-expansion-panel *ngFor=\"let data of dataSource.data\">\r\n                  <mat-expansion-panel-header>\r\n                    <mat-panel-title>\r\n                      {{data.nombre}}\r\n                    </mat-panel-title>\r\n                    <mat-panel-description>\r\n                      {{data.apellido}}\r\n                    </mat-panel-description>\r\n                  </mat-expansion-panel-header>\r\n                    <p>correo: {{data.correo}}</p>\r\n                    <hr>\r\n                    <p>creado: {{data.createdAt}}</p>\r\n                    <hr>\r\n                    <button class=\"btn btn-danger btn-sm m-1\" (click)=\"delete(data.id)\"><i class=\"fa fa-trash\"></i> Delete</button>\r\n                    <button class=\"btn btn-primary btn-sm m-1\" (click)=\"edit(data.id)\"><i class=\"fa fa-edit\"></i> Edit</button>\r\n                </mat-expansion-panel>\r\n              </mat-accordion>\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"card-footer\">\r\n        <app-paginator\r\n        [pageSize]=\"pageSize\"\r\n        [totalRows]=\"totalRows\"\r\n        [pageSizeOptions]=\"[10,20,50,100]\"\r\n        (loadSize)=\"loadSize($event)\"\r\n        (loadData)=\"loadData($event)\"\r\n        ></app-paginator>\r\n    </div>\r\n\r\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/filter-columns/filter-columns.component.html":
  /*!*************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/filter-columns/filter-columns.component.html ***!
    \*************************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsDatatableFilterColumnsFilterColumnsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<button class=\"btn btn-primary btn-icon-split btn-sm d-inline mx-2\" (click)=\"open(filters)\">\r\n  <span class=\"icon text-white-50\">\r\n    <i class=\"fas fa-filter\"></i>\r\n  </span>\r\n  <span class=\"text\"> Show/Hide</span>\r\n</button>\r\n<ng-template let-modal #filters>\r\n    <div class=\"modal-header\">\r\n        <h5 class=\"modal-title\" id=\"exampleModalLabel\">Choose The Columns</h5>\r\n        <button class=\"close\" type=\"button\" (click)=\"close()\">\r\n          <span aria-hidden=\"true\">×</span>\r\n        </button>\r\n      </div>\r\n      <div class=\"modal-body\">\r\n            <div>\r\n                <button *ngFor=\"let col of columns\" class=\"btn btn-small btn-block\" [ngClass]=\"(col.visible) ? 'btn-primary' : ''\" (click)=\"col.visible=!col.visible\">\r\n                    {{col.title}}\r\n                </button>\r\n            </div>\r\n      </div>\r\n      <div class=\"modal-footer\">\r\n        <button class=\"btn btn-secondary\" type=\"button\" (click)=\"close()\">Cerrar</button>\r\n        <button class=\"btn btn-primary\" type=\"button\" (click)=\"filtrar()\">filtrar</button>\r\n      </div>\r\n</ng-template>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/paginator/paginator.component.html":
  /*!***************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/paginator/paginator.component.html ***!
    \***************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsDatatablePaginatorPaginatorComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<form class=\"d-sm-inline-block form-inline ml-md-3 my-2 my-md-0 w-100 navbar-search float-right\">\r\n    <div class=\"input-group\">\r\n        <label for=\"totalRows\" class=\"form-control bg-light border-0 text-right d-none d-sm-inline\">Total Rows: {{totalRows}} </label>\r\n        <label for=\"pageSize\" class=\"form-control bg-light border-0 text-right d-none d-sm-inline\">Show: </label>\r\n        <select name=\"pageSize\" id=\"pageSize\" class=\"form-control bg-light small d-sm-block\" [(ngModel)]=\"pageSize\" (change)=\"changeSize();currentPage=1\">\r\n            <option *ngFor=\"let size of pageSizeOptions\" value=\"{{size}}\">{{size}} rows</option>\r\n        </select>\r\n        <label for=\"totalRows\" class=\"form-control bg-light border-0 text-right d-none d-sm-inline\">Pages: {{pages.length}} </label>\r\n        <nav aria-label=\"Page navigation example\">\r\n            <ul class=\"pagination\" style=\"cursor: pointer;\">\r\n                <li class=\"page-item mx-1\"><a class=\"page-link\" (click)=\"paginationFirst()\"><i class=\"fa fa-angle-double-left\"></i></a></li>\r\n                <li class=\"page-item mx-1\"><a class=\"page-link\" (click)=\"paginationPrev()\"><i class=\"fa fa-angle-left\"></i></a></li>\r\n                <!-- <li class=\"page-item btn btn-circle\" *ngFor=\"let page of pages\" [ngClass]=\"(currentPage == page) ? 'active' : ''\"><a class=\"page-link\" (click)=\"pagination(page)\">{{page}}</a></li> -->\r\n                <li class=\"page-item mx-1 btn btn-circle active\"><a class=\"page-link\">{{currentPage}}</a></li>\r\n                <li class=\"page-item mx-1\"><a class=\"page-link\" (click)=\"paginationNext()\"><i class=\"fa fa-angle-right\"></i></a></li>\r\n                <li class=\"page-item mx-1\"><a class=\"page-link\" (click)=\"paginationLast()\"><i class=\"fa fa-angle-double-right\"></i></a></li>\r\n            </ul>\r\n        </nav>\r\n    </div>\r\n</form>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/reports/reports.component.html":
  /*!***********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/reports/reports.component.html ***!
    \***********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsDatatableReportsReportsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<button class=\"btn btn-primary btn-icon-split btn-sm d-inline mx-2\" title=\"Download actual view as CSV file\" (click)=\"downloadCsv()\">\r\n    <span class=\"icon text-white-50\">\r\n      <i class=\"fas fa-download\"></i>\r\n    </span>\r\n    <span class=\"text\">CSV</span>\r\n</button>\r\n\r\n<angular2csv [data]=\"newData\" filename=\"csvFileName\" [options]=\"options\" #angular2Csv class=\"d-none\"></angular2csv>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/forms/forms.component.html":
  /*!*********************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/forms/forms.component.html ***!
    \*********************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsFormsFormsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<h1 class=\"h3 mb-2 text-gray-800\">{{pageTitle}}</h1>\r\n<p class=\"mb-4\">{{pageDescription}}</p>\r\n\r\n<!-- DataTales Example -->\r\n<div class=\"card shadow mb-4\">\r\n    <div class=\"card-header py-3\">\r\n        <h6 class=\"m-0 font-weight-bold text-primary\">{{cardTitle}}\r\n            <!-- <button class=\"btn btn-primary mx-2 float-right\"><i class=\"fa fa-plus\"></i><span class=\"d-none d-md-inline\"> Add Form</span></button> -->\r\n        </h6>\r\n    </div>\r\n    <div class=\"card-body\">\r\n        <form class=\"user row\" #Formulario (submit)=\"submitAction()\">\r\n            <div *ngFor=\"let campo of myFormFields\" class=\"form-group col-sm-12 col-md-6 col-lg-4\">\r\n                <label for=\"{{campo.name}}\" class=\"form-control-label  mx-2\">{{campo.placeholder}}:</label>\r\n                <span *ngIf=\"campo.tag=='input'\">\r\n                    <span *ngIf=\"['text','email','password','date','time','number'].indexOf(campo.type) > -1\">\r\n                        <input type=\"{{campo.type}}\" class=\"form-control form-control-user\" name=\"{{campo.name}}\" id=\"{{campo.name}}\" placeholder=\"{{campo.placeholder}}\" required=\"{{campo.required}}\" [(ngModel)]=\"myForm[campo.name]\"> \r\n                    </span>\r\n                    <span *ngIf=\"campo.type=='radio'\">\r\n                        <label *ngFor=\"let o of campo.options\" style=\"cursor: pointer;\">\r\n                            <input type=\"radio\" name=\"{{campo.name}}\" value=\"{{o.value}}\" class=\"d-inline mx-2\" required=\"{{campo.required}}\" [(ngModel)]=\"myForm[campo.name]\">{{o.text}}\r\n                        </label>\r\n                    </span>\r\n                    <span *ngIf=\"campo.type=='checkbox'\">\r\n                        <span *ngFor=\"let o of campo.options\" >\r\n                            <input type=\"checkbox\" name=\"{{o.value}}\" id=\"{{o.value}}\" value=\"{{o.value}}\" class=\"custom-control-input\" required=\"{{campo.required}}\" [(ngModel)]=\"myForm[campo.name][o.value]\">\r\n                            <label for=\"{{o.value}}\" class=\"custom-control-label d-inline-block mx-4\">{{o.text}}</label>\r\n                        </span>\r\n                    </span>\r\n                    <span *ngIf=\"campo.type=='file' || campo.type=='image'\">\r\n                        <input type=\"file\" name=\"{{campo.name}}\" id=\"{{campo.name}}\" class=\"d-none\" required=\"{{campo.required}}\" [(ngModel)]=\"myForm[campo.name]\">\r\n                        <label for=\"{{campo.name}}\" class=\"btn btn-primary btn-icon-split w-100 d-flex justify-content-start\" style=\"cursor: pointer;\">\r\n                            <span class=\"icon text-white-50\">\r\n                                <i class=\"fas fa-upload\"></i>\r\n                            </span>\r\n                            <span class=\"text\">{{campo.placeholder}}</span>\r\n                        </label>\r\n                    </span>\r\n                </span>\r\n                <span *ngIf=\"campo.tag=='select'\">\r\n                    <select name=\"{{campo.name}}\" id=\"{{campo.name}}\" class=\"form-control d-md-inline\" required=\"{{campo.required}}\" [(ngModel)]=\"myForm[campo.name]\">\r\n                        <option *ngFor=\"let o of campo.options\" value=\"{{o.value}}\">{{o.text}}</option>\r\n                    </select>\r\n                </span>\r\n                <span *ngIf=\"campo.tag=='textarea'\">\r\n                    <textarea name=\"{{campo.name}}\" id=\"{{campo.name}}\" cols=\"30\" rows=\"5\" class=\"form-control\" placeholder=\"{{campo.placeholder}}\" required=\"{{campo.required}}\" [(ngModel)]=\"myForm[campo.name]\"></textarea>\r\n                </span>\r\n                <p *ngIf=\"error[campo.id]\" class=\"text text-danger text-small ml-2\">{{error[campo.id]}}</p>\r\n            </div>\r\n            <button type=\"submit\" class=\"btn btn-success form-control\">Enviar Datos</button>\r\n        </form>\r\n    </div>\r\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/animaitions/animaitions.component.html":
  /*!*******************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/animaitions/animaitions.component.html ***!
    \*******************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsInterfaceAnimaitionsAnimaitionsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Heading -->\n<h1 class=\"h3 mb-1 text-gray-800\">Animation Utilities</h1>\n<p class=\"mb-4\">Bootstrap's default utility classes can be found on the official <a href=\"https://getbootstrap.com/docs\">Bootstrap Documentation</a> page. The custom utilities below were created to extend this theme past the default utility classes built into Bootstrap's framework.</p>\n\n<!-- Content Row -->\n<div class=\"row\">\n\n  <!-- Grow In Utility -->\n  <div class=\"col-lg-6\">\n\n    <div class=\"card position-relative\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Grow In Animation Utilty</h6>\n      </div>\n      <div class=\"card-body\">\n        <div class=\"mb-3\">\n          <code>.animated--grow-in</code>\n        </div>\n        <div class=\"small mb-1\">Navbar Dropdown Example:</div>\n        <nav class=\"navbar navbar-expand navbar-light bg-light mb-4\">\n          <a class=\"navbar-brand\" href=\"#\">Navbar</a>\n          <ul class=\"navbar-nav ml-auto\">\n            <li class=\"nav-item dropdown\">\n              <a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                Dropdown\n              </a>\n              <div class=\"dropdown-menu dropdown-menu-right animated--grow-in\" aria-labelledby=\"navbarDropdown\">\n                <a class=\"dropdown-item\" href=\"#\">Action</a>\n                <a class=\"dropdown-item\" href=\"#\">Another action</a>\n                <div class=\"dropdown-divider\"></div>\n                <a class=\"dropdown-item\" href=\"#\">Something else here</a>\n              </div>\n            </li>\n          </ul>\n        </nav>\n        <p class=\"mb-0 small\">Note: This utility animates the CSS transform property, meaning it will override any existing transforms on an element being animated! In this theme, the grow in animation is only being used on dropdowns within the navbar.</p>\n      </div>\n    </div>\n\n  </div>\n\n  <!-- Fade In Utility -->\n  <div class=\"col-lg-6\">\n\n    <div class=\"card position-relative\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Fade In Animation Utilty</h6>\n      </div>\n      <div class=\"card-body\">\n        <div class=\"mb-3\">\n          <code>.animated--fade-in</code>\n        </div>\n        <div class=\"small mb-1\">Navbar Dropdown Example:</div>\n        <nav class=\"navbar navbar-expand navbar-light bg-light mb-4\">\n          <a class=\"navbar-brand\" href=\"#\">Navbar</a>\n          <ul class=\"navbar-nav ml-auto\">\n            <li class=\"nav-item dropdown\">\n              <a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                Dropdown\n              </a>\n              <div class=\"dropdown-menu dropdown-menu-right animated--fade-in\" aria-labelledby=\"navbarDropdown\">\n                <a class=\"dropdown-item\" href=\"#\">Action</a>\n                <a class=\"dropdown-item\" href=\"#\">Another action</a>\n                <div class=\"dropdown-divider\"></div>\n                <a class=\"dropdown-item\" href=\"#\">Something else here</a>\n              </div>\n            </li>\n          </ul>\n        </nav>\n        <div class=\"small mb-1\">Dropdown Button Example:</div>\n        <div class=\"dropdown mb-4\">\n          <button class=\"btn btn-primary dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            Dropdown\n          </button>\n          <div class=\"dropdown-menu animated--fade-in\" aria-labelledby=\"dropdownMenuButton\">\n            <a class=\"dropdown-item\" href=\"#\">Action</a>\n            <a class=\"dropdown-item\" href=\"#\">Another action</a>\n            <a class=\"dropdown-item\" href=\"#\">Something else here</a>\n          </div>\n        </div>\n        <p class=\"mb-0 small\">Note: This utility animates the CSS opacity property, meaning it will override any existing opacity on an element being animated!</p>\n      </div>\n    </div>\n\n  </div>\n\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/blank/blank.component.html":
  /*!*******************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/blank/blank.component.html ***!
    \*******************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsInterfaceBlankBlankComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Heading -->\n<h1 class=\"h3 mb-4 text-gray-800\">Blank Page</h1>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/borders/borders.component.html":
  /*!***********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/borders/borders.component.html ***!
    \***********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsInterfaceBordersBordersComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Heading -->\n<h1 class=\"h3 mb-1 text-gray-800\">Border Utilities</h1>\n<p class=\"mb-4\">Bootstrap's default utility classes can be found on the official <a href=\"https://getbootstrap.com/docs\">Bootstrap Documentation</a> page. The custom utilities below were created to extend this theme past the default utility classes built into Bootstrap's framework.</p>\n\n<!-- Content Row -->\n<div class=\"row\">\n\n  <!-- Border Left Utilities -->\n  <div class=\"col-lg-6\">\n\n    <div class=\"card mb-4 py-3 border-left-primary\">\n      <div class=\"card-body\">\n        .border-left-primary\n      </div>\n    </div>\n\n    <div class=\"card mb-4 py-3 border-left-success\">\n      <div class=\"card-body\">\n        .border-left-success\n      </div>\n    </div>\n\n    <div class=\"card mb-4 py-3 border-left-info\">\n      <div class=\"card-body\">\n        .border-left-info\n      </div>\n    </div>\n\n    <div class=\"card mb-4 py-3 border-left-warning\">\n      <div class=\"card-body\">\n        .border-left-warning\n      </div>\n    </div>\n\n    <div class=\"card mb-4 py-3 border-left-danger\">\n      <div class=\"card-body\">\n        .border-left-danger\n      </div>\n    </div>\n\n  </div>\n\n  <!-- Border Bottom Utilities -->\n  <div class=\"col-lg-6\">\n\n    <div class=\"card mb-4 py-3 border-bottom-primary\">\n      <div class=\"card-body\">\n        .border-bottom-primary\n      </div>\n    </div>\n\n    <div class=\"card mb-4 py-3 border-bottom-success\">\n      <div class=\"card-body\">\n        .border-bottom-success\n      </div>\n    </div>\n\n    <div class=\"card mb-4 py-3 border-bottom-info\">\n      <div class=\"card-body\">\n        .border-bottom-info\n      </div>\n    </div>\n\n    <div class=\"card mb-4 py-3 border-bottom-warning\">\n      <div class=\"card-body\">\n        .border-bottom-warning\n      </div>\n    </div>\n\n    <div class=\"card mb-4 py-3 border-bottom-danger\">\n      <div class=\"card-body\">\n        .border-bottom-danger\n      </div>\n    </div>\n\n  </div>\n\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/buttons/buttons.component.html":
  /*!***********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/buttons/buttons.component.html ***!
    \***********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsInterfaceButtonsButtonsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Heading -->\n<h1 class=\"h3 mb-4 text-gray-800\">Buttons</h1>\n\n<div class=\"row\">\n\n  <div class=\"col-lg-6\">\n\n    <!-- Circle Buttons -->\n    <div class=\"card shadow mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Circle Buttons</h6>\n      </div>\n      <div class=\"card-body\">\n        <p>Use Font Awesome Icons (included with this theme package) along with the circle buttons as shown in the examples below!</p>\n        <!-- Circle Buttons (Default) -->\n        <div class=\"mb-2\">\n          <code>.btn-circle</code>\n        </div>\n        <a href=\"#\" class=\"btn btn-primary btn-circle\">\n          <i class=\"fab fa-facebook-f\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-success btn-circle\">\n          <i class=\"fas fa-check\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-info btn-circle\">\n          <i class=\"fas fa-info-circle\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-warning btn-circle\">\n          <i class=\"fas fa-exclamation-triangle\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-danger btn-circle\">\n          <i class=\"fas fa-trash\"></i>\n        </a>\n        <!-- Circle Buttons (Small) -->\n        <div class=\"mt-4 mb-2\">\n          <code>.btn-circle .btn-sm</code>\n        </div>\n        <a href=\"#\" class=\"btn btn-primary btn-circle btn-sm\">\n          <i class=\"fab fa-facebook-f\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-success btn-circle btn-sm\">\n          <i class=\"fas fa-check\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-info btn-circle btn-sm\">\n          <i class=\"fas fa-info-circle\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-warning btn-circle btn-sm\">\n          <i class=\"fas fa-exclamation-triangle\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-danger btn-circle btn-sm\">\n          <i class=\"fas fa-trash\"></i>\n        </a>\n        <!-- Circle Buttons (Large) -->\n        <div class=\"mt-4 mb-2\">\n          <code>.btn-circle .btn-lg</code>\n        </div>\n        <a href=\"#\" class=\"btn btn-primary btn-circle btn-lg\">\n          <i class=\"fab fa-facebook-f\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-success btn-circle btn-lg\">\n          <i class=\"fas fa-check\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-info btn-circle btn-lg\">\n          <i class=\"fas fa-info-circle\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-warning btn-circle btn-lg\">\n          <i class=\"fas fa-exclamation-triangle\"></i>\n        </a>\n        <a href=\"#\" class=\"btn btn-danger btn-circle btn-lg\">\n          <i class=\"fas fa-trash\"></i>\n        </a>\n      </div>\n    </div>\n\n    <!-- Brand Buttons -->\n    <div class=\"card shadow mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Brand Buttons</h6>\n      </div>\n      <div class=\"card-body\">\n        <p>Google and Facebook buttons are available featuring each company's respective brand color. They are used on the user login and registration pages.</p>\n        <p>You can create more custom buttons by adding a new color variable in the <code>_variables.scss</code> file and then using the Bootstrap button variant mixin to create a new style, as demonstrated in the <code>_buttons.scss</code> file.</p>\n        <a href=\"#\" class=\"btn btn-google btn-block\"><i class=\"fab fa-google fa-fw\"></i> .btn-google</a>\n        <a href=\"#\" class=\"btn btn-facebook btn-block\"><i class=\"fab fa-facebook-f fa-fw\"></i> .btn-facebook</a>\n\n      </div>\n    </div>\n\n  </div>\n\n  <div class=\"col-lg-6\">\n\n    <div class=\"card shadow mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Split Buttons with Icon</h6>\n      </div>\n      <div class=\"card-body\">\n        <p>Works with any button colors, just use the <code>.btn-icon-split</code> class and the markup in the examples below. The examples below also use the <code>.text-white-50</code> helper class on the icons for additional styling, but it is not required.</p>\n        <a href=\"#\" class=\"btn btn-primary btn-icon-split\">\n          <span class=\"icon text-white-50\">\n            <i class=\"fas fa-flag\"></i>\n          </span>\n          <span class=\"text\">Split Button Primary</span>\n        </a>\n        <div class=\"my-2\"></div>\n        <a href=\"#\" class=\"btn btn-success btn-icon-split\">\n          <span class=\"icon text-white-50\">\n            <i class=\"fas fa-check\"></i>\n          </span>\n          <span class=\"text\">Split Button Success</span>\n        </a>\n        <div class=\"my-2\"></div>\n        <a href=\"#\" class=\"btn btn-info btn-icon-split\">\n          <span class=\"icon text-white-50\">\n            <i class=\"fas fa-info-circle\"></i>\n          </span>\n          <span class=\"text\">Split Button Info</span>\n        </a>\n        <div class=\"my-2\"></div>\n        <a href=\"#\" class=\"btn btn-warning btn-icon-split\">\n          <span class=\"icon text-white-50\">\n            <i class=\"fas fa-exclamation-triangle\"></i>\n          </span>\n          <span class=\"text\">Split Button Warning</span>\n        </a>\n        <div class=\"my-2\"></div>\n        <a href=\"#\" class=\"btn btn-danger btn-icon-split\">\n          <span class=\"icon text-white-50\">\n            <i class=\"fas fa-trash\"></i>\n          </span>\n          <span class=\"text\">Split Button Danger</span>\n        </a>\n        <div class=\"my-2\"></div>\n        <a href=\"#\" class=\"btn btn-secondary btn-icon-split\">\n          <span class=\"icon text-white-50\">\n            <i class=\"fas fa-arrow-right\"></i>\n          </span>\n          <span class=\"text\">Split Button Secondary</span>\n        </a>\n        <div class=\"my-2\"></div>\n        <a href=\"#\" class=\"btn btn-light btn-icon-split\">\n          <span class=\"icon text-gray-600\">\n            <i class=\"fas fa-arrow-right\"></i>\n          </span>\n          <span class=\"text\">Split Button Primary</span>\n        </a>\n        <div class=\"mb-4\"></div>\n        <p>Also works with small and large button classes!</p>\n        <a href=\"#\" class=\"btn btn-primary btn-icon-split btn-sm\">\n          <span class=\"icon text-white-50\">\n            <i class=\"fas fa-flag\"></i>\n          </span>\n          <span class=\"text\">Split Button Small</span>\n        </a>\n        <div class=\"my-2\"></div>\n        <a href=\"#\" class=\"btn btn-primary btn-icon-split btn-lg\">\n          <span class=\"icon text-white-50\">\n            <i class=\"fas fa-flag\"></i>\n          </span>\n          <span class=\"text\">Split Button Large</span>\n        </a>\n      </div>\n    </div>\n\n  </div>\n\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/cards/cards.component.html":
  /*!*******************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/cards/cards.component.html ***!
    \*******************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsInterfaceCardsCardsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Heading -->\n<div class=\"d-sm-flex align-items-center justify-content-between mb-4\">\n    <h1 class=\"h3 mb-0 text-gray-800\">Cards</h1>\n  </div>\n\n  <div class=\"row\">\n\n    <!-- Earnings (Monthly) Card Example -->\n    <div class=\"col-xl-3 col-md-6 mb-4\">\n      <div class=\"card border-left-primary shadow h-100 py-2\">\n        <div class=\"card-body\">\n          <div class=\"row no-gutters align-items-center\">\n            <div class=\"col mr-2\">\n              <div class=\"text-xs font-weight-bold text-primary text-uppercase mb-1\">Earnings (Monthly)</div>\n              <div class=\"h5 mb-0 font-weight-bold text-gray-800\">$40,000</div>\n            </div>\n            <div class=\"col-auto\">\n              <i class=\"fas fa-calendar fa-2x text-gray-300\"></i>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Earnings (Monthly) Card Example -->\n    <div class=\"col-xl-3 col-md-6 mb-4\">\n      <div class=\"card border-left-success shadow h-100 py-2\">\n        <div class=\"card-body\">\n          <div class=\"row no-gutters align-items-center\">\n            <div class=\"col mr-2\">\n              <div class=\"text-xs font-weight-bold text-success text-uppercase mb-1\">Earnings (Annual)</div>\n              <div class=\"h5 mb-0 font-weight-bold text-gray-800\">$215,000</div>\n            </div>\n            <div class=\"col-auto\">\n              <i class=\"fas fa-dollar-sign fa-2x text-gray-300\"></i>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Earnings (Monthly) Card Example -->\n    <div class=\"col-xl-3 col-md-6 mb-4\">\n      <div class=\"card border-left-info shadow h-100 py-2\">\n        <div class=\"card-body\">\n          <div class=\"row no-gutters align-items-center\">\n            <div class=\"col mr-2\">\n              <div class=\"text-xs font-weight-bold text-info text-uppercase mb-1\">Tasks</div>\n              <div class=\"row no-gutters align-items-center\">\n                <div class=\"col-auto\">\n                  <div class=\"h5 mb-0 mr-3 font-weight-bold text-gray-800\">50%</div>\n                </div>\n                <div class=\"col\">\n                  <div class=\"progress progress-sm mr-2\">\n                    <div class=\"progress-bar bg-info\" role=\"progressbar\" style=\"width: 50%\" aria-valuenow=\"50\" aria-valuemin=\"0\" aria-valuemax=\"100\"></div>\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div class=\"col-auto\">\n              <i class=\"fas fa-clipboard-list fa-2x text-gray-300\"></i>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Pending Requests Card Example -->\n    <div class=\"col-xl-3 col-md-6 mb-4\">\n      <div class=\"card border-left-warning shadow h-100 py-2\">\n        <div class=\"card-body\">\n          <div class=\"row no-gutters align-items-center\">\n            <div class=\"col mr-2\">\n              <div class=\"text-xs font-weight-bold text-warning text-uppercase mb-1\">Pending Requests</div>\n              <div class=\"h5 mb-0 font-weight-bold text-gray-800\">18</div>\n            </div>\n            <div class=\"col-auto\">\n              <i class=\"fas fa-comments fa-2x text-gray-300\"></i>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"row\">\n\n    <div class=\"col-lg-6\">\n\n      <!-- Default Card Example -->\n      <div class=\"card mb-4\">\n        <div class=\"card-header\">\n          Default Card Example\n        </div>\n        <div class=\"card-body\">\n          This card uses Bootstrap's default styling with no utility classes added. Global styles are the only things modifying the look and feel of this default card example.\n        </div>\n      </div>\n\n      <!-- Basic Card Example -->\n      <div class=\"card shadow mb-4\">\n        <div class=\"card-header py-3\">\n          <h6 class=\"m-0 font-weight-bold text-primary\">Basic Card Example</h6>\n        </div>\n        <div class=\"card-body\">\n          The styling for this basic card example is created by using default Bootstrap utility classes. By using utility classes, the style of the card component can be easily modified with no need for any custom CSS!\n        </div>\n      </div>\n\n    </div>\n\n    <div class=\"col-lg-6\">\n\n      <!-- Dropdown Card Example -->\n      <div class=\"card shadow mb-4\">\n        <!-- Card Header - Dropdown -->\n        <div class=\"card-header py-3 d-flex flex-row align-items-center justify-content-between\">\n          <h6 class=\"m-0 font-weight-bold text-primary\">Dropdown Card Example</h6>\n          <div class=\"dropdown no-arrow\">\n            <a class=\"dropdown-toggle\" href=\"#\" role=\"button\" id=\"dropdownMenuLink\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n              <i class=\"fas fa-ellipsis-v fa-sm fa-fw text-gray-400\"></i>\n            </a>\n            <div class=\"dropdown-menu dropdown-menu-right shadow animated--fade-in\" aria-labelledby=\"dropdownMenuLink\">\n              <div class=\"dropdown-header\">Dropdown Header:</div>\n              <a class=\"dropdown-item\" href=\"#\">Action</a>\n              <a class=\"dropdown-item\" href=\"#\">Another action</a>\n              <div class=\"dropdown-divider\"></div>\n              <a class=\"dropdown-item\" href=\"#\">Something else here</a>\n            </div>\n          </div>\n        </div>\n        <!-- Card Body -->\n        <div class=\"card-body\">\n          Dropdown menus can be placed in the card header in order to extend the functionality of a basic card. In this dropdown card example, the Font Awesome vertical ellipsis icon in the card header can be clicked on in order to toggle a dropdown menu.\n        </div>\n      </div>\n\n      <!-- Collapsable Card Example -->\n      <div class=\"card shadow mb-4\">\n        <!-- Card Header - Accordion -->\n        <a href=\"#collapseCardExample\" class=\"d-block card-header py-3\" data-toggle=\"collapse\" role=\"button\" aria-expanded=\"true\" aria-controls=\"collapseCardExample\">\n          <h6 class=\"m-0 font-weight-bold text-primary\">Collapsable Card Example</h6>\n        </a>\n        <!-- Card Content - Collapse -->\n        <div class=\"collapse show\" id=\"collapseCardExample\">\n          <div class=\"card-body\">\n            This is a collapsable card example using Bootstrap's built in collapse functionality. <strong>Click on the card header</strong> to see the card body collapse and expand!\n          </div>\n        </div>\n      </div>\n\n    </div>\n\n  </div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/colors/colors.component.html":
  /*!*********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/colors/colors.component.html ***!
    \*********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsInterfaceColorsColorsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Heading -->\n<h1 class=\"h3 mb-1 text-gray-800\">Color Utilities</h1>\n<p class=\"mb-4\">Bootstrap's default utility classes can be found on the official <a href=\"https://getbootstrap.com/docs\">Bootstrap Documentation</a> page. The custom utilities below were created to extend this theme past the default utility classes built into Bootstrap's framework.</p>\n\n<!-- Content Row -->\n<div class=\"row\">\n\n  <!-- First Column -->\n  <div class=\"col-lg-4\">\n\n    <!-- Custom Text Color Utilities -->\n    <div class=\"card shadow mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Custom Text Color Utilities</h6>\n      </div>\n      <div class=\"card-body\">\n        <p class=\"text-gray-100 p-3 bg-dark m-0\">.text-gray-100</p>\n        <p class=\"text-gray-200 p-3 bg-dark m-0\">.text-gray-200</p>\n        <p class=\"text-gray-300 p-3 bg-dark m-0\">.text-gray-300</p>\n        <p class=\"text-gray-400 p-3 bg-dark m-0\">.text-gray-400</p>\n        <p class=\"text-gray-500 p-3 m-0\">.text-gray-500</p>\n        <p class=\"text-gray-600 p-3 m-0\">.text-gray-600</p>\n        <p class=\"text-gray-700 p-3 m-0\">.text-gray-700</p>\n        <p class=\"text-gray-800 p-3 m-0\">.text-gray-800</p>\n        <p class=\"text-gray-900 p-3 m-0\">.text-gray-900</p>\n      </div>\n    </div>\n\n    <!-- Custom Font Size Utilities -->\n    <div class=\"card shadow mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Custom Font Size Utilities</h6>\n      </div>\n      <div class=\"card-body\">\n        <p class=\"text-xs\">.text-xs</p>\n        <p class=\"text-lg mb-0\">.text-lg</p>\n      </div>\n    </div>\n\n  </div>\n\n  <!-- Second Column -->\n  <div class=\"col-lg-4\">\n\n    <!-- Background Gradient Utilities -->\n    <div class=\"card shadow mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Custom Background Gradient Utilities</h6>\n      </div>\n      <div class=\"card-body\">\n        <div class=\"px-3 py-5 bg-gradient-primary text-white\">.bg-gradient-primary</div>\n        <div class=\"px-3 py-5 bg-gradient-success text-white\">.bg-gradient-success</div>\n        <div class=\"px-3 py-5 bg-gradient-info text-white\">.bg-gradient-info</div>\n        <div class=\"px-3 py-5 bg-gradient-warning text-white\">.bg-gradient-warning</div>\n        <div class=\"px-3 py-5 bg-gradient-danger text-white\">.bg-gradient-danger</div>\n      </div>\n    </div>\n\n  </div>\n\n  <!-- Third Column -->\n  <div class=\"col-lg-4\">\n\n    <!-- Grayscale Utilities -->\n    <div class=\"card shadow mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Custom Grayscale Background Utilities</h6>\n      </div>\n      <div class=\"card-body\">\n        <div class=\"p-3 bg-gray-100\">.bg-gray-100</div>\n        <div class=\"p-3 bg-gray-200\">.bg-gray-200</div>\n        <div class=\"p-3 bg-gray-300\">.bg-gray-300</div>\n        <div class=\"p-3 bg-gray-400\">.bg-gray-400</div>\n        <div class=\"p-3 bg-gray-500 text-white\">.bg-gray-500</div>\n        <div class=\"p-3 bg-gray-600 text-white\">.bg-gray-600</div>\n        <div class=\"p-3 bg-gray-700 text-white\">.bg-gray-700</div>\n        <div class=\"p-3 bg-gray-800 text-white\">.bg-gray-800</div>\n        <div class=\"p-3 bg-gray-900 text-white\">.bg-gray-900</div>\n      </div>\n    </div>\n  </div>\n\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/other/other.component.html":
  /*!*******************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/other/other.component.html ***!
    \*******************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsInterfaceOtherOtherComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Heading -->\n<h1 class=\"h3 mb-1 text-gray-800\">Other Utilities</h1>\n<p class=\"mb-4\">Bootstrap's default utility classes can be found on the official <a href=\"https://getbootstrap.com/docs\">Bootstrap Documentation</a> page. The custom utilities below were created to extend this theme past the default utility classes built into Bootstrap's framework.</p>\n\n<!-- Content Row -->\n<div class=\"row\">\n\n  <div class=\"col-lg-6\">\n\n    <!-- Overflow Hidden -->\n    <div class=\"card mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Overflow Hidden Utilty</h6>\n      </div>\n      <div class=\"card-body\">\n        Use <code>.o-hidden</code> to set the overflow property of any element to hidden.\n      </div>\n    </div>\n\n    <!-- Progress Small -->\n    <div class=\"card mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Progress Small Utility</h6>\n      </div>\n      <div class=\"card-body\">\n        <div class=\"mb-1 small\">Normal Progress Bar</div>\n        <div class=\"progress mb-4\">\n          <div class=\"progress-bar\" role=\"progressbar\" style=\"width: 75%\" aria-valuenow=\"75\" aria-valuemin=\"0\" aria-valuemax=\"100\"></div>\n        </div>\n        <div class=\"mb-1 small\">Small Progress Bar</div>\n        <div class=\"progress progress-sm mb-2\">\n          <div class=\"progress-bar\" role=\"progressbar\" style=\"width: 75%\" aria-valuenow=\"75\" aria-valuemin=\"0\" aria-valuemax=\"100\"></div>\n        </div>\n        Use the <code>.progress-sm</code> class along with <code>.progress</code>\n      </div>\n    </div>\n\n    <!-- Dropdown No Arrow -->\n    <div class=\"card mb-4\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Dropdown - No Arrow</h6>\n      </div>\n      <div class=\"card-body\">\n        <div class=\"dropdown no-arrow mb-4\">\n          <button class=\"btn btn-secondary dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            Dropdown (no arrow)\n          </button>\n          <div class=\"dropdown-menu\" aria-labelledby=\"dropdownMenuButton\">\n            <a class=\"dropdown-item\" href=\"#\">Action</a>\n            <a class=\"dropdown-item\" href=\"#\">Another action</a>\n            <a class=\"dropdown-item\" href=\"#\">Something else here</a>\n          </div>\n        </div>\n        Add the <code>.no-arrow</code> class alongside the <code>.dropdown</code>\n      </div>\n    </div>\n\n  </div>\n\n  <div class=\"col-lg-6\">\n\n    <!-- Roitation Utilities -->\n    <div class=\"card\">\n      <div class=\"card-header py-3\">\n        <h6 class=\"m-0 font-weight-bold text-primary\">Rotation Utilities</h6>\n      </div>\n      <div class=\"card-body text-center\">\n        <div class=\"bg-primary text-white p-3 rotate-15 d-inline-block my-4\">.rotate-15</div>\n        <hr>\n        <div class=\"bg-primary text-white p-3 rotate-n-15 d-inline-block my-4\">.rotate-n-15</div>\n      </div>\n    </div>\n\n  </div>\n\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/unknown/unknown.component.html":
  /*!***********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/unknown/unknown.component.html ***!
    \***********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsInterfaceUnknownUnknownComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- 404 Error Text -->\n<div class=\"text-center\">\n    <div class=\"error mx-auto\" data-text=\"404\">404</div>\n    <p class=\"lead text-gray-800 mb-5\">Page Not Found</p>\n    <p class=\"text-gray-500 mb-0\">It looks like you found a glitch in the matrix...</p>\n    <a href=\"#\">&larr; Back to Dashboard</a>\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/layout/layout.component.html":
  /*!***********************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/layout/layout.component.html ***!
    \***********************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsLayoutLayoutComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Page Wrapper -->\r\n<div id=\"wrapper\">\r\n    <app-sidebar\r\n    #sidebar\r\n    ></app-sidebar>\r\n    <div id=\"content-wrapper\" class=\"d-flex flex-column\">\r\n        <div id=\"content\">\r\n            <app-topbar\r\n            (sideBar)=\"toggleSideBar()\"\r\n            ></app-topbar>\r\n            <!-- Begin Page Content -->\r\n        <div class=\"container-fluid\">\r\n\r\n            <router-outlet></router-outlet>\r\n  \r\n          </div>\r\n          <!-- /.container-fluid -->\r\n\r\n          <app-footer></app-footer>\r\n        </div>\r\n    </div>\r\n     <!-- End of Content Wrapper -->\r\n</div>\r\n<!-- End of Page Wrapper -->\r\n\r\n<!-- Scroll to Top Button-->\r\n<a class=\"scroll-to-top rounded\" href=\"#page-top\">\r\n    <i class=\"fas fa-angle-up\"></i>\r\n  </a>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/profile/profile.component.html":
  /*!*************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/profile/profile.component.html ***!
    \*************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsProfileProfileComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<p>profile works!</p>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/progress-bar/progress-bar.component.html":
  /*!***********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/progress-bar/progress-bar.component.html ***!
    \***********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsProgressBarProgressBarComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div *ngFor=\"let bar of bars\">\n    <h4 class=\"small font-weight-bold\">{{bar.nombre}} <span class=\"float-right\">{{bar.progreso}}%</span></h4>\n    <div class=\"progress mb-4\">\n        <div class=\"progress-bar\" [style]=\"{width:bar.progreso+'%',background:bar.color}\"></div>\n    </div>\n</div>";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/public/login/login.component.html":
  /*!****************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/public/login/login.component.html ***!
    \****************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsPublicLoginLoginComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div class=\"container\">\r\n\r\n    <!-- Outer Row -->\r\n    <div class=\"row justify-content-center\">\r\n\r\n      <div class=\"col-xl-10 col-lg-12 col-md-9\">\r\n\r\n        <div class=\"card o-hidden border-0 shadow-lg my-5\">\r\n          <div class=\"card-body p-0\">\r\n            <!-- Nested Row within Card Body -->\r\n            <div class=\"row\">\r\n              <div class=\"col-lg-6 d-none d-lg-block bg-login-image\"></div>\r\n              <div class=\"col-lg-6\">\r\n                <div class=\"p-5\">\r\n                  <div class=\"text-center\">\r\n                    <h1 class=\"h4 text-gray-900 mb-4\">¡Bienvenido!</h1>\r\n                  </div>\r\n                  <form class=\"user\" #loginForm>\r\n                    <div class=\"form-group\">\r\n                      <input type=\"email\" name=\"email\" class=\"form-control form-control-user\" id=\"exampleInputEmail\" aria-describedby=\"emailHelp\" placeholder=\"Ingresa Tu Correo...\" [(ngModel)]=\"usuario.email\">\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                      <input type=\"password\" name=\"password\" class=\"form-control form-control-user\" id=\"exampleInputPassword\" placeholder=\"Contraseña\" [(ngModel)]=\"usuario.password\">\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                      <div class=\"custom-control custom-checkbox small\">\r\n                        <input type=\"checkbox\" class=\"custom-control-input\" id=\"customCheck\">\r\n                        <label class=\"custom-control-label\" for=\"customCheck\">Recuerdame</label>\r\n                      </div>\r\n                    </div>\r\n                    <button class=\"btn btn-primary btn-user btn-block\" (click)=\"login()\">\r\n                      Acceder\r\n                    </button>\r\n                    <hr>\r\n                    <button class=\"btn btn-google btn-user btn-block\">\r\n                      <i class=\"fab fa-google fa-fw\"></i> Acceder con Google\r\n                    </button>\r\n                    <button class=\"btn btn-facebook btn-user btn-block\">\r\n                      <i class=\"fab fa-facebook-f fa-fw\"></i> Acceder con Facebook\r\n                    </button>\r\n                  </form>\r\n                  <hr>\r\n                  <div class=\"text-center\">\r\n                    <a class=\"small\" routerLink=\"/recover\">¿Olvidaste tu contraseña?</a>\r\n                  </div>\r\n                  <div class=\"text-center\">\r\n                    <a class=\"small\" routerLink=\"/register\">¡Crear una cuenta!</a>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n      </div>\r\n\r\n    </div>\r\n\r\n  </div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/public/recover/recover.component.html":
  /*!********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/public/recover/recover.component.html ***!
    \********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsPublicRecoverRecoverComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div class=\"container\">\r\n\r\n    <!-- Outer Row -->\r\n    <div class=\"row justify-content-center\">\r\n\r\n      <div class=\"col-xl-10 col-lg-12 col-md-9\">\r\n\r\n        <div class=\"card o-hidden border-0 shadow-lg my-5\">\r\n          <div class=\"card-body p-0\">\r\n            <!-- Nested Row within Card Body -->\r\n            <div class=\"row\">\r\n              <div class=\"col-lg-6 d-none d-lg-block bg-password-image\"></div>\r\n              <div class=\"col-lg-6\">\r\n                <div class=\"p-5\">\r\n                  <div class=\"text-center\">\r\n                    <h1 class=\"h4 text-gray-900 mb-2\">¿Olvidate Tu Contraseña?</h1>\r\n                    <p class=\"mb-4\">¡Suele Pasar! Escribe tu correo y te enviaremos un enlace para recuperarla</p>\r\n                  </div>\r\n                  <form class=\"user\">\r\n                    <div class=\"form-group\">\r\n                      <input type=\"email\" class=\"form-control form-control-user\" id=\"exampleInputEmail\" aria-describedby=\"emailHelp\" placeholder=\"Ingresa Tu Dirección de Correo...\">\r\n                    </div>\r\n                    <button class=\"btn btn-primary btn-user btn-block\">\r\n                      Reset Password\r\n                    </button>\r\n                  </form>\r\n                  <hr>\r\n                  <div class=\"text-center\">\r\n                    <a class=\"small\" routerLink=\"/register\">¡Crear una cuenta!</a>\r\n                  </div>\r\n                  <div class=\"text-center\">\r\n                    <a class=\"small\" routerLink=\"/login\">¿Ya tienes una cuenta? ¡Login!</a>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n      </div>\r\n\r\n    </div>\r\n\r\n  </div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/public/register/register.component.html":
  /*!**********************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/public/register/register.component.html ***!
    \**********************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsPublicRegisterRegisterComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div class=\"container\">\r\n\r\n    <div class=\"card o-hidden border-0 shadow-lg my-5\">\r\n      <div class=\"card-body p-0\">\r\n        <!-- Nested Row within Card Body -->\r\n        <div class=\"row\">\r\n          <div class=\"col-lg-5 d-none d-lg-block bg-register-image\"></div>\r\n          <div class=\"col-lg-7\">\r\n            <div class=\"p-5\">\r\n              <div class=\"text-center\">\r\n                <h1 class=\"h4 text-gray-900 mb-4\">Create an Account!</h1>\r\n              </div>\r\n              <form class=\"user\">\r\n                <div class=\"form-group row\">\r\n                  <div class=\"col-sm-6 mb-3 mb-sm-0\">\r\n                    <input type=\"text\" name=\"nombres\" class=\"form-control form-control-user\" id=\"exampleFirstName\" placeholder=\"Nommbre\" [(ngModel)]=\"usuario.nombre\">\r\n                  </div>\r\n                  <div class=\"col-sm-6\">\r\n                    <input type=\"text\" name=\"apellidos\" class=\"form-control form-control-user\" id=\"exampleLastName\" placeholder=\"Apellidos\" [(ngModel)]=\"usuario.apellido\">\r\n                  </div>\r\n                </div>\r\n                <div class=\"form-group\">\r\n                  <input type=\"email\" name=\"email\" class=\"form-control form-control-user\" id=\"exampleInputEmail\" placeholder=\"Correo\" [(ngModel)]=\"usuario.email\">\r\n                </div>\r\n                <div class=\"form-group row\">\r\n                  <div class=\"col-sm-6 mb-3 mb-sm-0\">\r\n                    <input type=\"password\" name=\"pass1\" class=\"form-control form-control-user\" id=\"exampleInputPassword\" placeholder=\"Contraseña\" [(ngModel)]=\"usuario.password\">\r\n                  </div>\r\n                  <div class=\"col-sm-6\">\r\n                    <input type=\"password\" name=\"pass2\" class=\"form-control form-control-user\" id=\"exampleRepeatPassword\" placeholder=\"Repite la Contraseña\">\r\n                  </div>\r\n                </div>\r\n                <button class=\"btn btn-primary btn-user btn-block\" (click)=\"register()\">\r\n                  Registrar Cuenta\r\n                </button>\r\n                <hr>\r\n                <button class=\"btn btn-google btn-user btn-block\">\r\n                  <i class=\"fab fa-google fa-fw\"></i> Registrar con Google\r\n                </button>\r\n                <button class=\"btn btn-facebook btn-user btn-block\">\r\n                  <i class=\"fab fa-facebook-f fa-fw\"></i> Registrar con Facebook\r\n                </button>\r\n              </form>\r\n              <hr>\r\n              <div class=\"text-center\">\r\n                <a class=\"small\" routerLink=\"/recover\">¿Olvidaste tu contraseña?</a>\r\n              </div>\r\n              <div class=\"text-center\">\r\n                <a class=\"small\" routerLink=\"/login\">¿Ya tienes una cuenta? ¡Login!</a>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n  </div>\r\n";
    /***/
  },

  /***/
  "./node_modules/tslib/tslib.es6.js":
  /*!*****************************************!*\
    !*** ./node_modules/tslib/tslib.es6.js ***!
    \*****************************************/

  /*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */

  /***/
  function node_modulesTslibTslibEs6Js(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__extends", function () {
      return __extends;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__assign", function () {
      return _assign;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__rest", function () {
      return __rest;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__decorate", function () {
      return __decorate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__param", function () {
      return __param;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__metadata", function () {
      return __metadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__awaiter", function () {
      return __awaiter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__generator", function () {
      return __generator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__exportStar", function () {
      return __exportStar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__values", function () {
      return __values;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__read", function () {
      return __read;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__spread", function () {
      return __spread;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__spreadArrays", function () {
      return __spreadArrays;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__await", function () {
      return __await;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function () {
      return __asyncGenerator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function () {
      return __asyncDelegator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__asyncValues", function () {
      return __asyncValues;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function () {
      return __makeTemplateObject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__importStar", function () {
      return __importStar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__importDefault", function () {
      return __importDefault;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function () {
      return __classPrivateFieldGet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function () {
      return __classPrivateFieldSet;
    });
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    /* global Reflect, Promise */


    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    function __extends(d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var _assign = function __assign() {
      _assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return _assign.apply(this, arguments);
    };

    function __rest(s, e) {
      var t = {};

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }

    function __decorate(decorators, target, key, desc) {
      var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      }
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    }

    function __metadata(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) {
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];

            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;

              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };

              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;

              case 7:
                op = _.ops.pop();

                _.trys.pop();

                continue;

              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }

                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }

                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }

                if (t && _.label < t[2]) {
                  _.label = t[2];

                  _.ops.push(op);

                  break;
                }

                if (t[2]) _.ops.pop();

                _.trys.pop();

                continue;
            }

            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }

    function __exportStar(m, exports) {
      for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
      }
    }

    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function next() {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
          r,
          ar = [],
          e;

      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
          ar.push(r.value);
        }
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }

      return ar;
    }

    function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
      }

      return ar;
    }

    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
      }

      for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
          r[k] = a[j];
        }
      }

      return r;
    }

    ;

    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i;

      function verb(n) {
        if (g[n]) i[n] = function (v) {
          return new Promise(function (a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }

      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }

      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }

      function fulfill(value) {
        resume("next", value);
      }

      function reject(value) {
        resume("throw", value);
      }

      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    }

    function __asyncDelegator(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function (e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function () {
        return this;
      }, i;

      function verb(n, f) {
        i[n] = o[n] ? function (v) {
          return (p = !p) ? {
            value: __await(o[n](v)),
            done: n === "return"
          } : f ? f(v) : v;
        } : f;
      }
    }

    function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator],
          i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i);

      function verb(n) {
        i[n] = o[n] && function (v) {
          return new Promise(function (resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }

      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
          resolve({
            value: v,
            done: d
          });
        }, reject);
      }
    }

    function __makeTemplateObject(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
          value: raw
        });
      } else {
        cooked.raw = raw;
      }

      return cooked;
    }

    ;

    function __importStar(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      }
      result.default = mod;
      return result;
    }

    function __importDefault(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }

      return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }

      privateMap.set(receiver, value);
      return value;
    }
    /***/

  },

  /***/
  "./src/app/app-routing.module.ts":
  /*!***************************************!*\
    !*** ./src/app/app-routing.module.ts ***!
    \***************************************/

  /*! exports provided: AppRoutingModule */

  /***/
  function srcAppAppRoutingModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AppRoutingModule", function () {
      return AppRoutingModule;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/router */
    "./node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js");
    /* harmony import */


    var _components_public_login_login_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./components/public/login/login.component */
    "./src/app/components/public/login/login.component.ts");
    /* harmony import */


    var _components_public_register_register_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./components/public/register/register.component */
    "./src/app/components/public/register/register.component.ts");
    /* harmony import */


    var _components_public_recover_recover_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./components/public/recover/recover.component */
    "./src/app/components/public/recover/recover.component.ts");
    /* harmony import */


    var _components_layout_layout_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ./components/layout/layout.component */
    "./src/app/components/layout/layout.component.ts");
    /* harmony import */


    var _components_profile_profile_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ./components/profile/profile.component */
    "./src/app/components/profile/profile.component.ts");
    /* harmony import */


    var _components_datatable_datatable_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ./components/datatable/datatable.component */
    "./src/app/components/datatable/datatable.component.ts");
    /* harmony import */


    var _components_forms_forms_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ./components/forms/forms.component */
    "./src/app/components/forms/forms.component.ts");
    /* harmony import */


    var _components_charts_charts_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! ./components/charts/charts.component */
    "./src/app/components/charts/charts.component.ts");
    /* harmony import */


    var _components_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! ./components/dashboard/dashboard.component */
    "./src/app/components/dashboard/dashboard.component.ts");
    /* harmony import */


    var _components_interface_buttons_buttons_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! ./components/interface/buttons/buttons.component */
    "./src/app/components/interface/buttons/buttons.component.ts");
    /* harmony import */


    var _components_interface_cards_cards_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
    /*! ./components/interface/cards/cards.component */
    "./src/app/components/interface/cards/cards.component.ts");
    /* harmony import */


    var _components_interface_colors_colors_component__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
    /*! ./components/interface/colors/colors.component */
    "./src/app/components/interface/colors/colors.component.ts");
    /* harmony import */


    var _components_interface_borders_borders_component__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
    /*! ./components/interface/borders/borders.component */
    "./src/app/components/interface/borders/borders.component.ts");
    /* harmony import */


    var _components_interface_animaitions_animaitions_component__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
    /*! ./components/interface/animaitions/animaitions.component */
    "./src/app/components/interface/animaitions/animaitions.component.ts");
    /* harmony import */


    var _components_interface_other_other_component__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
    /*! ./components/interface/other/other.component */
    "./src/app/components/interface/other/other.component.ts");
    /* harmony import */


    var _components_interface_unknown_unknown_component__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
    /*! ./components/interface/unknown/unknown.component */
    "./src/app/components/interface/unknown/unknown.component.ts");
    /* harmony import */


    var _components_interface_blank_blank_component__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
    /*! ./components/interface/blank/blank.component */
    "./src/app/components/interface/blank/blank.component.ts");

    var routes = [{
      path: '',
      redirectTo: 'dashboard',
      pathMatch: 'full'
    }, // RUTAS PÚBLICAS
    {
      path: 'login',
      component: _components_public_login_login_component__WEBPACK_IMPORTED_MODULE_3__["LoginComponent"]
    }, {
      path: 'register',
      component: _components_public_register_register_component__WEBPACK_IMPORTED_MODULE_4__["RegisterComponent"]
    }, {
      path: 'recover',
      component: _components_public_recover_recover_component__WEBPACK_IMPORTED_MODULE_5__["RecoverComponent"]
    }, // RUTAS PRIVADAS
    {
      path: 'dashboard',
      component: _components_layout_layout_component__WEBPACK_IMPORTED_MODULE_6__["LayoutComponent"],
      children: [{
        path: '',
        component: _components_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_11__["DashboardComponent"]
      }, {
        path: 'profile',
        component: _components_profile_profile_component__WEBPACK_IMPORTED_MODULE_7__["ProfileComponent"]
      }, {
        path: 'table',
        component: _components_datatable_datatable_component__WEBPACK_IMPORTED_MODULE_8__["DataTableComponent"]
      }, {
        path: 'forms',
        component: _components_forms_forms_component__WEBPACK_IMPORTED_MODULE_9__["FormsComponent"]
      }, {
        path: 'charts',
        component: _components_charts_charts_component__WEBPACK_IMPORTED_MODULE_10__["ChartsComponent"]
      }, {
        path: 'buttons',
        component: _components_interface_buttons_buttons_component__WEBPACK_IMPORTED_MODULE_12__["ButtonsComponent"]
      }, {
        path: 'cards',
        component: _components_interface_cards_cards_component__WEBPACK_IMPORTED_MODULE_13__["CardsComponent"]
      }, {
        path: 'colors',
        component: _components_interface_colors_colors_component__WEBPACK_IMPORTED_MODULE_14__["ColorsComponent"]
      }, {
        path: 'borders',
        component: _components_interface_borders_borders_component__WEBPACK_IMPORTED_MODULE_15__["BordersComponent"]
      }, {
        path: 'animations',
        component: _components_interface_animaitions_animaitions_component__WEBPACK_IMPORTED_MODULE_16__["AnimaitionsComponent"]
      }, {
        path: 'other',
        component: _components_interface_other_other_component__WEBPACK_IMPORTED_MODULE_17__["OtherComponent"]
      }, {
        path: 'blank',
        component: _components_interface_blank_blank_component__WEBPACK_IMPORTED_MODULE_19__["BlankComponent"]
      }, {
        path: 'unknown',
        component: _components_interface_unknown_unknown_component__WEBPACK_IMPORTED_MODULE_18__["UnknownComponent"]
      }]
    }];

    var AppRoutingModule = function AppRoutingModule() {
      _classCallCheck(this, AppRoutingModule);
    };

    AppRoutingModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
      imports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"].forRoot(routes)],
      exports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"]]
    })], AppRoutingModule);
    /***/
  },

  /***/
  "./src/app/app.component.css":
  /*!***********************************!*\
    !*** ./src/app/app.component.css ***!
    \***********************************/

  /*! exports provided: default */

  /***/
  function srcAppAppComponentCss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2FwcC5jb21wb25lbnQuY3NzIn0= */";
    /***/
  },

  /***/
  "./src/app/app.component.ts":
  /*!**********************************!*\
    !*** ./src/app/app.component.ts ***!
    \**********************************/

  /*! exports provided: AppComponent */

  /***/
  function srcAppAppComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AppComponent", function () {
      return AppComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var AppComponent = function AppComponent() {
      _classCallCheck(this, AppComponent);

      this.title = 'SBAdminAngularTheme';
    };

    AppComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-root',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./app.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/app.component.html")).default,
      styles: [Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! ./app.component.css */
      "./src/app/app.component.css")).default]
    })], AppComponent);
    /***/
  },

  /***/
  "./src/app/app.module.ts":
  /*!*******************************!*\
    !*** ./src/app/app.module.ts ***!
    \*******************************/

  /*! exports provided: AppModule */

  /***/
  function srcAppAppModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AppModule", function () {
      return AppModule;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/platform-browser */
    "./node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/platform-browser.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _app_routing_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./app-routing.module */
    "./src/app/app-routing.module.ts");
    /* harmony import */


    var _app_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./app.component */
    "./src/app/app.component.ts");
    /* harmony import */


    var _components_public_login_login_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./components/public/login/login.component */
    "./src/app/components/public/login/login.component.ts");
    /* harmony import */


    var _components_public_register_register_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ./components/public/register/register.component */
    "./src/app/components/public/register/register.component.ts");
    /* harmony import */


    var _components_public_recover_recover_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ./components/public/recover/recover.component */
    "./src/app/components/public/recover/recover.component.ts");
    /* harmony import */


    var _components_layout_layout_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ./components/layout/layout.component */
    "./src/app/components/layout/layout.component.ts");
    /* harmony import */


    var _components_common_topbar_topbar_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ./components/common/topbar/topbar.component */
    "./src/app/components/common/topbar/topbar.component.ts");
    /* harmony import */


    var _components_common_sidebar_sidebar_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! ./components/common/sidebar/sidebar.component */
    "./src/app/components/common/sidebar/sidebar.component.ts");
    /* harmony import */


    var _components_common_footer_footer_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! ./components/common/footer/footer.component */
    "./src/app/components/common/footer/footer.component.ts");
    /* harmony import */


    var _components_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! ./components/dashboard/dashboard.component */
    "./src/app/components/dashboard/dashboard.component.ts");
    /* harmony import */


    var _components_profile_profile_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
    /*! ./components/profile/profile.component */
    "./src/app/components/profile/profile.component.ts");
    /* harmony import */


    var _components_configuration_configuration_component__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
    /*! ./components/configuration/configuration.component */
    "./src/app/components/configuration/configuration.component.ts");
    /* harmony import */


    var _components_calendar_calendar_component__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
    /*! ./components/calendar/calendar.component */
    "./src/app/components/calendar/calendar.component.ts");
    /* harmony import */


    var _components_datatable_datatable_component__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
    /*! ./components/datatable/datatable.component */
    "./src/app/components/datatable/datatable.component.ts");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
    /*! @angular/forms */
    "./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js");
    /* harmony import */


    var _angular_common_http__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
    /*! @angular/common/http */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/http.js");
    /* harmony import */


    var _components_common_logout_logout_component__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
    /*! ./components/common/logout/logout.component */
    "./src/app/components/common/logout/logout.component.ts");
    /* harmony import */


    var _components_common_search_search_component__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(
    /*! ./components/common/search/search.component */
    "./src/app/components/common/search/search.component.ts");
    /* harmony import */


    var _components_common_alerts_alerts_component__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(
    /*! ./components/common/alerts/alerts.component */
    "./src/app/components/common/alerts/alerts.component.ts");
    /* harmony import */


    var _components_common_message_message_component__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(
    /*! ./components/common/message/message.component */
    "./src/app/components/common/message/message.component.ts");
    /* harmony import */


    var _components_common_user_info_user_info_component__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(
    /*! ./components/common/user-info/user-info.component */
    "./src/app/components/common/user-info/user-info.component.ts");
    /* harmony import */


    var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(
    /*! @angular/platform-browser/animations */
    "./node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/animations.js");
    /* harmony import */


    var _material_module__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(
    /*! ./material.module */
    "./src/app/material.module.ts");
    /* harmony import */


    var time_ago_pipe__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(
    /*! time-ago-pipe */
    "./node_modules/time-ago-pipe/__ivy_ngcc__/esm2015/time-ago-pipe.js");
    /* harmony import */


    var _components_forms_forms_component__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(
    /*! ./components/forms/forms.component */
    "./src/app/components/forms/forms.component.ts");
    /* harmony import */


    var _components_datatable_paginator_paginator_component__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(
    /*! ./components/datatable/paginator/paginator.component */
    "./src/app/components/datatable/paginator/paginator.component.ts");
    /* harmony import */


    var _components_datatable_filter_columns_filter_columns_component__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(
    /*! ./components/datatable/filter-columns/filter-columns.component */
    "./src/app/components/datatable/filter-columns/filter-columns.component.ts");
    /* harmony import */


    var _fortawesome_angular_fontawesome__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(
    /*! @fortawesome/angular-fontawesome */
    "./node_modules/@fortawesome/angular-fontawesome/__ivy_ngcc__/fesm2015/angular-fontawesome.js");
    /* harmony import */


    var _components_charts_charts_component__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(
    /*! ./components/charts/charts.component */
    "./src/app/components/charts/charts.component.ts");
    /* harmony import */


    var _components_datatable_reports_reports_component__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(
    /*! ./components/datatable/reports/reports.component */
    "./src/app/components/datatable/reports/reports.component.ts");
    /* harmony import */


    var angular2_csv__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(
    /*! angular2-csv */
    "./node_modules/angular2-csv/__ivy_ngcc__/fesm2015/angular2-csv.js");
    /* harmony import */


    var _components_charts_area_chart_area_chart_component__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(
    /*! ./components/charts/area-chart/area-chart.component */
    "./src/app/components/charts/area-chart/area-chart.component.ts");
    /* harmony import */


    var _components_charts_bar_chart_bar_chart_component__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(
    /*! ./components/charts/bar-chart/bar-chart.component */
    "./src/app/components/charts/bar-chart/bar-chart.component.ts");
    /* harmony import */


    var _components_charts_pie_chart_pie_chart_component__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(
    /*! ./components/charts/pie-chart/pie-chart.component */
    "./src/app/components/charts/pie-chart/pie-chart.component.ts");
    /* harmony import */


    var _components_progress_bar_progress_bar_component__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(
    /*! ./components/progress-bar/progress-bar.component */
    "./src/app/components/progress-bar/progress-bar.component.ts");
    /* harmony import */


    var _components_interface_interface_module__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(
    /*! ./components/interface/interface.module */
    "./src/app/components/interface/interface.module.ts");

    var AppModule = function AppModule() {
      _classCallCheck(this, AppModule);
    };

    AppModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"])({
      declarations: [_app_component__WEBPACK_IMPORTED_MODULE_4__["AppComponent"], _components_public_login_login_component__WEBPACK_IMPORTED_MODULE_5__["LoginComponent"], _components_public_register_register_component__WEBPACK_IMPORTED_MODULE_6__["RegisterComponent"], _components_public_recover_recover_component__WEBPACK_IMPORTED_MODULE_7__["RecoverComponent"], _components_layout_layout_component__WEBPACK_IMPORTED_MODULE_8__["LayoutComponent"], _components_common_topbar_topbar_component__WEBPACK_IMPORTED_MODULE_9__["TopbarComponent"], _components_common_sidebar_sidebar_component__WEBPACK_IMPORTED_MODULE_10__["SidebarComponent"], _components_common_footer_footer_component__WEBPACK_IMPORTED_MODULE_11__["FooterComponent"], _components_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_12__["DashboardComponent"], _components_profile_profile_component__WEBPACK_IMPORTED_MODULE_13__["ProfileComponent"], _components_configuration_configuration_component__WEBPACK_IMPORTED_MODULE_14__["ConfigurationComponent"], _components_calendar_calendar_component__WEBPACK_IMPORTED_MODULE_15__["CalendarComponent"], _components_common_logout_logout_component__WEBPACK_IMPORTED_MODULE_19__["LogoutComponent"], _components_common_search_search_component__WEBPACK_IMPORTED_MODULE_20__["SearchComponent"], _components_common_alerts_alerts_component__WEBPACK_IMPORTED_MODULE_21__["AlertsComponent"], _components_common_message_message_component__WEBPACK_IMPORTED_MODULE_22__["MessageComponent"], _components_common_user_info_user_info_component__WEBPACK_IMPORTED_MODULE_23__["UserInfoComponent"], _components_forms_forms_component__WEBPACK_IMPORTED_MODULE_27__["FormsComponent"], _components_datatable_datatable_component__WEBPACK_IMPORTED_MODULE_16__["DataTableComponent"], _components_datatable_paginator_paginator_component__WEBPACK_IMPORTED_MODULE_28__["PaginatorComponent"], _components_datatable_filter_columns_filter_columns_component__WEBPACK_IMPORTED_MODULE_29__["FilterColumnsComponent"], _components_datatable_reports_reports_component__WEBPACK_IMPORTED_MODULE_32__["ReportsComponent"], _components_charts_charts_component__WEBPACK_IMPORTED_MODULE_31__["ChartsComponent"], _components_charts_area_chart_area_chart_component__WEBPACK_IMPORTED_MODULE_34__["AreaChartComponent"], _components_charts_bar_chart_bar_chart_component__WEBPACK_IMPORTED_MODULE_35__["BarChartComponent"], _components_charts_pie_chart_pie_chart_component__WEBPACK_IMPORTED_MODULE_36__["PieChartComponent"], time_ago_pipe__WEBPACK_IMPORTED_MODULE_26__["TimeAgoPipe"], _components_progress_bar_progress_bar_component__WEBPACK_IMPORTED_MODULE_37__["ProgressBarComponent"]],
      imports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"], _app_routing_module__WEBPACK_IMPORTED_MODULE_3__["AppRoutingModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_17__["FormsModule"], _angular_common_http__WEBPACK_IMPORTED_MODULE_18__["HttpClientModule"], _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_24__["BrowserAnimationsModule"], _material_module__WEBPACK_IMPORTED_MODULE_25__["MaterialModule"], _fortawesome_angular_fontawesome__WEBPACK_IMPORTED_MODULE_30__["FontAwesomeModule"], angular2_csv__WEBPACK_IMPORTED_MODULE_33__["Angular2CsvModule"], _components_interface_interface_module__WEBPACK_IMPORTED_MODULE_38__["InterfaceModule"]],
      providers: [],
      bootstrap: [_app_component__WEBPACK_IMPORTED_MODULE_4__["AppComponent"]]
    })], AppModule);
    /***/
  },

  /***/
  "./src/app/components/calendar/calendar.component.ts":
  /*!***********************************************************!*\
    !*** ./src/app/components/calendar/calendar.component.ts ***!
    \***********************************************************/

  /*! exports provided: CalendarComponent */

  /***/
  function srcAppComponentsCalendarCalendarComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CalendarComponent", function () {
      return CalendarComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var CalendarComponent =
    /*#__PURE__*/
    function () {
      function CalendarComponent() {
        _classCallCheck(this, CalendarComponent);
      }

      _createClass(CalendarComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return CalendarComponent;
    }();

    CalendarComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-calendar',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./calendar.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/calendar/calendar.component.html")).default
    })], CalendarComponent);
    /***/
  },

  /***/
  "./src/app/components/charts/area-chart/area-chart.component.ts":
  /*!**********************************************************************!*\
    !*** ./src/app/components/charts/area-chart/area-chart.component.ts ***!
    \**********************************************************************/

  /*! exports provided: AreaChartComponent */

  /***/
  function srcAppComponentsChartsAreaChartAreaChartComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AreaChartComponent", function () {
      return AreaChartComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! chart.js */
    "./node_modules/chart.js/dist/Chart.js");
    /* harmony import */


    var chart_js__WEBPACK_IMPORTED_MODULE_2___default =
    /*#__PURE__*/
    __webpack_require__.n(chart_js__WEBPACK_IMPORTED_MODULE_2__);

    var AreaChartComponent =
    /*#__PURE__*/
    function () {
      function AreaChartComponent() {
        _classCallCheck(this, AreaChartComponent);

        this.labels = [];
        this.data = [];
        this.myAreaChart = [];
        this.bgColors = [];
      }

      _createClass(AreaChartComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.myAreaChart = new chart_js__WEBPACK_IMPORTED_MODULE_2__["Chart"]('myAreaChart', {
            type: 'line',
            data: {
              labels: this.labels,
              datasets: [{
                label: "Earnings",
                lineTension: 0.3,
                backgroundColor: "rgba(78, 115, 223, 0.05)",
                borderColor: "rgba(78, 115, 223, 1)",
                pointRadius: 3,
                pointBackgroundColor: "rgba(78, 115, 223, 1)",
                pointBorderColor: "rgba(78, 115, 223, 1)",
                pointHoverRadius: 3,
                pointHoverBackgroundColor: "rgba(78, 115, 223, 1)",
                pointHoverBorderColor: "rgba(78, 115, 223, 1)",
                pointHitRadius: 10,
                pointBorderWidth: 2,
                data: this.data
              }]
            },
            options: {
              maintainAspectRatio: false,
              layout: {
                padding: {
                  left: 10,
                  right: 25,
                  top: 25,
                  bottom: 0
                }
              },
              scales: {
                xAxes: [{
                  time: {
                    unit: 'date'
                  },
                  gridLines: {
                    display: false,
                    drawBorder: false
                  },
                  ticks: {
                    maxTicksLimit: 7
                  }
                }],
                yAxes: [{
                  ticks: {
                    maxTicksLimit: 5,
                    padding: 10,
                    // Include a dollar sign in the ticks
                    callback: function callback(value, index, values) {
                      return '$' + value;
                    }
                  },
                  gridLines: {
                    color: "rgb(234, 236, 244)",
                    zeroLineColor: "rgb(234, 236, 244)",
                    drawBorder: false,
                    borderDash: [2],
                    zeroLineBorderDash: [2]
                  }
                }]
              },
              legend: {
                display: false
              },
              tooltips: {
                backgroundColor: "rgb(255,255,255)",
                bodyFontColor: "#858796",
                titleMarginBottom: 10,
                titleFontColor: '#6e707e',
                titleFontSize: 14,
                borderColor: '#dddfeb',
                borderWidth: 1,
                xPadding: 15,
                yPadding: 15,
                displayColors: false,
                intersect: false,
                mode: 'index',
                caretPadding: 10,
                callbacks: {
                  label: function label(tooltipItem, chart) {
                    var datasetLabel = chart.datasets[tooltipItem.datasetIndex].label || '';
                    return datasetLabel + ': $' + tooltipItem.yLabel;
                  }
                }
              }
            }
          });
        }
      }, {
        key: "fillColors",
        value: function fillColors() {
          var _this304 = this;

          var color;
          this.data.forEach(function () {
            color = '#' + Math.random().toString(16).slice(2, 8).toUpperCase();

            _this304.bgColors.push(color);
          });
        }
      }]);

      return AreaChartComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], AreaChartComponent.prototype, "labels", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], AreaChartComponent.prototype, "data", void 0);
    AreaChartComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-area-chart',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./area-chart.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/area-chart/area-chart.component.html")).default
    })], AreaChartComponent);
    /***/
  },

  /***/
  "./src/app/components/charts/bar-chart/bar-chart.component.ts":
  /*!********************************************************************!*\
    !*** ./src/app/components/charts/bar-chart/bar-chart.component.ts ***!
    \********************************************************************/

  /*! exports provided: BarChartComponent */

  /***/
  function srcAppComponentsChartsBarChartBarChartComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BarChartComponent", function () {
      return BarChartComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! chart.js */
    "./node_modules/chart.js/dist/Chart.js");
    /* harmony import */


    var chart_js__WEBPACK_IMPORTED_MODULE_2___default =
    /*#__PURE__*/
    __webpack_require__.n(chart_js__WEBPACK_IMPORTED_MODULE_2__);

    var BarChartComponent =
    /*#__PURE__*/
    function () {
      function BarChartComponent() {
        _classCallCheck(this, BarChartComponent);

        this.labels = [];
        this.data = [];
        this.myBarChart = [];
        this.bgColors = [];
      }

      _createClass(BarChartComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.myBarChart = new chart_js__WEBPACK_IMPORTED_MODULE_2__["Chart"]('myBarChart', {
            type: 'bar',
            data: {
              labels: this.labels,
              datasets: [{
                label: "Revenue",
                backgroundColor: "#4e73df",
                hoverBackgroundColor: "#aa59d9",
                borderColor: "#4e73df",
                data: this.data,
                BarThickness: 25
              }]
            },
            options: {
              maintainAspectRatio: false,
              layout: {
                padding: {
                  left: 10,
                  right: 25,
                  top: 25,
                  bottom: 0
                }
              },
              scales: {
                xAxes: [{
                  time: {
                    unit: 'month'
                  },
                  gridLines: {
                    display: false,
                    drawBorder: false
                  },
                  ticks: {
                    maxTicksLimit: 6
                  }
                }],
                yAxes: [{
                  ticks: {
                    min: 0,
                    max: 50000,
                    maxTicksLimit: 5,
                    padding: 10,
                    // Include a dollar sign in the ticks
                    callback: function callback(value, index, values) {
                      return '$' + value;
                    }
                  },
                  gridLines: {
                    color: "rgb(234, 236, 244)",
                    zeroLineColor: "rgb(234, 236, 244)",
                    drawBorder: false,
                    borderDash: [2],
                    zeroLineBorderDash: [2]
                  }
                }]
              },
              legend: {
                display: false
              },
              tooltips: {
                titleMarginBottom: 10,
                titleFontColor: '#6e707e',
                titleFontSize: 14,
                backgroundColor: "rgb(255,255,255)",
                bodyFontColor: "#858796",
                borderColor: '#dddfeb',
                borderWidth: 1,
                xPadding: 15,
                yPadding: 15,
                displayColors: false,
                caretPadding: 10,
                callbacks: {
                  label: function label(tooltipItem, chart) {
                    var datasetLabel = chart.datasets[tooltipItem.datasetIndex].label || '';
                    return datasetLabel + ': $' + tooltipItem.yLabel;
                  }
                }
              }
            }
          });
        }
      }, {
        key: "fillColors",
        value: function fillColors() {
          var _this305 = this;

          var color;
          this.data.forEach(function () {
            color = '#' + Math.random().toString(16).slice(2, 8).toUpperCase();

            _this305.bgColors.push(color);
          });
        }
      }]);

      return BarChartComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], BarChartComponent.prototype, "labels", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], BarChartComponent.prototype, "data", void 0);
    BarChartComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-bar-chart',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./bar-chart.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/bar-chart/bar-chart.component.html")).default
    })], BarChartComponent);
    /***/
  },

  /***/
  "./src/app/components/charts/charts.component.ts":
  /*!*******************************************************!*\
    !*** ./src/app/components/charts/charts.component.ts ***!
    \*******************************************************/

  /*! exports provided: ChartsComponent */

  /***/
  function srcAppComponentsChartsChartsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ChartsComponent", function () {
      return ChartsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ChartsComponent =
    /*#__PURE__*/
    function () {
      function ChartsComponent() {
        _classCallCheck(this, ChartsComponent);

        this.labels = [];
        this.data = [];
      }

      _createClass(ChartsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          this.labels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          this.data = [0, 10000, 5000, 15000, 10000, 20000, 15000, 25000, 20000, 30000, 25000, 40000];
        }
      }]);

      return ChartsComponent;
    }();

    ChartsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-charts',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./charts.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/charts.component.html")).default
    })], ChartsComponent);
    /***/
  },

  /***/
  "./src/app/components/charts/pie-chart/pie-chart.component.ts":
  /*!********************************************************************!*\
    !*** ./src/app/components/charts/pie-chart/pie-chart.component.ts ***!
    \********************************************************************/

  /*! exports provided: PieChartComponent */

  /***/
  function srcAppComponentsChartsPieChartPieChartComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PieChartComponent", function () {
      return PieChartComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! chart.js */
    "./node_modules/chart.js/dist/Chart.js");
    /* harmony import */


    var chart_js__WEBPACK_IMPORTED_MODULE_2___default =
    /*#__PURE__*/
    __webpack_require__.n(chart_js__WEBPACK_IMPORTED_MODULE_2__);

    var PieChartComponent =
    /*#__PURE__*/
    function () {
      function PieChartComponent() {
        _classCallCheck(this, PieChartComponent);

        this.labels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        this.data = [0, 10000, 5000, 15000, 10000, 20000, 15000, 25000, 20000, 30000, 25000, 40000];
        this.myPieChart = [];
        this.bgColors = [];
      }

      _createClass(PieChartComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.fillColors();
          this.myPieChart = new chart_js__WEBPACK_IMPORTED_MODULE_2__["Chart"]('myPieChart', {
            type: 'doughnut',
            data: {
              labels: this.labels,
              datasets: [{
                data: this.data,
                backgroundColor: this.bgColors,
                hoverBackgroundColor: ['#2e59d9', '#17a673', '#2c9faf'],
                hoverBorderColor: "rgba(234, 236, 244, 1)"
              }]
            },
            options: {
              maintainAspectRatio: false,
              tooltips: {
                backgroundColor: "rgb(255,255,255)",
                bodyFontColor: "#858796",
                borderColor: '#dddfeb',
                borderWidth: 1,
                xPadding: 15,
                yPadding: 15,
                displayColors: false,
                caretPadding: 10
              },
              legend: {
                display: false
              },
              cutoutPercentage: 80
            }
          });
        }
      }, {
        key: "fillColors",
        value: function fillColors() {
          var _this306 = this;

          var color;
          this.data.forEach(function () {
            color = '#' + Math.random().toString(16).slice(2, 8).toUpperCase();

            _this306.bgColors.push(color);
          });
        }
      }]);

      return PieChartComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PieChartComponent.prototype, "labels", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PieChartComponent.prototype, "data", void 0);
    PieChartComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-pie-chart',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./pie-chart.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/charts/pie-chart/pie-chart.component.html")).default
    })], PieChartComponent);
    /***/
  },

  /***/
  "./src/app/components/common/alerts/alerts.component.ts":
  /*!**************************************************************!*\
    !*** ./src/app/components/common/alerts/alerts.component.ts ***!
    \**************************************************************/

  /*! exports provided: AlertsComponent */

  /***/
  function srcAppComponentsCommonAlertsAlertsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AlertsComponent", function () {
      return AlertsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var AlertsComponent =
    /*#__PURE__*/
    function () {
      function AlertsComponent() {
        _classCallCheck(this, AlertsComponent);
      }

      _createClass(AlertsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return AlertsComponent;
    }();

    AlertsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-alerts',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./alerts.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/alerts/alerts.component.html")).default
    })], AlertsComponent);
    /***/
  },

  /***/
  "./src/app/components/common/footer/footer.component.ts":
  /*!**************************************************************!*\
    !*** ./src/app/components/common/footer/footer.component.ts ***!
    \**************************************************************/

  /*! exports provided: FooterComponent */

  /***/
  function srcAppComponentsCommonFooterFooterComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FooterComponent", function () {
      return FooterComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var FooterComponent =
    /*#__PURE__*/
    function () {
      function FooterComponent() {
        _classCallCheck(this, FooterComponent);
      }

      _createClass(FooterComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return FooterComponent;
    }();

    FooterComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-footer',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./footer.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/footer/footer.component.html")).default
    })], FooterComponent);
    /***/
  },

  /***/
  "./src/app/components/common/logout/logout.component.ts":
  /*!**************************************************************!*\
    !*** ./src/app/components/common/logout/logout.component.ts ***!
    \**************************************************************/

  /*! exports provided: LogoutComponent */

  /***/
  function srcAppComponentsCommonLogoutLogoutComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LogoutComponent", function () {
      return LogoutComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var LogoutComponent =
    /*#__PURE__*/
    function () {
      function LogoutComponent() {
        _classCallCheck(this, LogoutComponent);
      }

      _createClass(LogoutComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "logout",
        value: function logout() {}
      }]);

      return LogoutComponent;
    }();

    LogoutComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-logout',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./logout.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/logout/logout.component.html")).default
    })], LogoutComponent);
    /***/
  },

  /***/
  "./src/app/components/common/message/message.component.ts":
  /*!****************************************************************!*\
    !*** ./src/app/components/common/message/message.component.ts ***!
    \****************************************************************/

  /*! exports provided: MessageComponent */

  /***/
  function srcAppComponentsCommonMessageMessageComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MessageComponent", function () {
      return MessageComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var MessageComponent =
    /*#__PURE__*/
    function () {
      function MessageComponent() {
        _classCallCheck(this, MessageComponent);
      }

      _createClass(MessageComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return MessageComponent;
    }();

    MessageComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-message',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./message.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/message/message.component.html")).default
    })], MessageComponent);
    /***/
  },

  /***/
  "./src/app/components/common/search/search.component.ts":
  /*!**************************************************************!*\
    !*** ./src/app/components/common/search/search.component.ts ***!
    \**************************************************************/

  /*! exports provided: SearchComponent */

  /***/
  function srcAppComponentsCommonSearchSearchComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SearchComponent", function () {
      return SearchComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var SearchComponent =
    /*#__PURE__*/
    function () {
      function SearchComponent() {
        _classCallCheck(this, SearchComponent);
      }

      _createClass(SearchComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return SearchComponent;
    }();

    SearchComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-search',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./search.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/search/search.component.html")).default
    })], SearchComponent);
    /***/
  },

  /***/
  "./src/app/components/common/sidebar/sidebar.component.ts":
  /*!****************************************************************!*\
    !*** ./src/app/components/common/sidebar/sidebar.component.ts ***!
    \****************************************************************/

  /*! exports provided: SidebarComponent */

  /***/
  function srcAppComponentsCommonSidebarSidebarComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SidebarComponent", function () {
      return SidebarComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var SidebarComponent =
    /*#__PURE__*/
    function () {
      function SidebarComponent() {
        _classCallCheck(this, SidebarComponent);

        this.webTitle = 'NG Admin';
        this.webTitleSup = "1"; // MENU EXAMPLE STRUCTURE DATA

        this.menuGroups = [{
          id: 1,
          title: '',
          permission: '',
          menu: [{
            id: 1,
            title: 'Dashboard',
            icon: 'fas fa-fw fa-tachometer-alt',
            link: '/dashboard',
            permission: '',
            subtitle: '',
            submenu: []
          }]
        }, {
          id: 2,
          title: 'Interface',
          permission: '',
          menu: [{
            id: 1,
            title: 'Components',
            icon: 'fas fa-fw fa-cog',
            link: '',
            permission: '',
            subtitle: 'Custom Components',
            submenu: [{
              id: 2,
              title: 'Buttons',
              link: 'buttons',
              permission: ''
            }, {
              id: 3,
              title: 'Cards',
              link: 'cards',
              permission: ''
            }]
          }, {
            id: 3,
            title: 'Utilitis',
            icon: 'fas fa-fw fa-wrench',
            link: '',
            permission: '',
            subtitle: 'Custom Utilities',
            submenu: [{
              id: 5,
              title: 'Colors',
              link: 'colors',
              permission: ''
            }, {
              id: 6,
              title: 'Borders',
              link: 'borders',
              permission: ''
            }, {
              id: 7,
              title: 'Animations',
              link: 'animations',
              permission: ''
            }, {
              id: 8,
              title: 'Other',
              link: 'other',
              permission: ''
            }]
          }]
        }, {
          id: 3,
          title: 'Addons',
          permission: '',
          menu: [{
            id: 9,
            title: 'Pages',
            icon: 'fas fa-fw fa-folder',
            link: '',
            permission: '',
            subtitle: 'Custom Components',
            submenu: [{
              id: 10,
              title: 'Login',
              link: '/login',
              permission: ''
            }, {
              id: 11,
              title: 'Register',
              link: '/register',
              permission: ''
            }, {
              id: 12,
              title: 'Forgot Password',
              link: '/recover',
              permission: ''
            }, {
              id: 12,
              title: 'Profile',
              link: 'profile',
              permission: ''
            }, {
              id: 13,
              title: '404 Page',
              link: 'unknown',
              permission: ''
            }, {
              id: 14,
              title: 'Blank Page',
              link: 'blank',
              permission: ''
            }]
          }, {
            id: 15,
            title: 'Charts',
            icon: 'fas fa-fw fa-chart-area',
            link: 'charts',
            permission: '',
            subtitle: '',
            submenu: []
          }, {
            id: 16,
            title: 'Tables',
            icon: 'fas fa-fw fa-table',
            link: 'table',
            permission: '',
            subtitle: '',
            submenu: []
          }, {
            id: 17,
            title: 'Forms',
            icon: 'fas fa-fw fa-table',
            link: 'forms',
            permission: '',
            subtitle: '',
            submenu: []
          }]
        }];
      }

      _createClass(SidebarComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "toggle",
        value: function toggle() {
          this.accordionSidebar.nativeElement.classList.toggle('toggled');
        }
      }, {
        key: "toggleSubmenu",
        value: function toggleSubmenu(g1, m1) {
          var g0 = this.group;
          var m0 = this.menu;
          this.accordionSidebar.nativeElement.children['group_' + g1].children['item_' + m1].children['menu_' + m1].children['submenu_' + m1].classList.toggle('show');

          if (m0 && m0 != m1) {
            this.accordionSidebar.nativeElement.children['group_' + g0].children['item_' + m0].children['menu_' + m0].children['submenu_' + m0].classList.remove('show');
          }

          this.group = g1;
          this.menu = m1;
        }
      }]);

      return SidebarComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('accordionSidebar', {
      static: true
    })], SidebarComponent.prototype, "accordionSidebar", void 0);
    SidebarComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-sidebar',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./sidebar.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/sidebar/sidebar.component.html")).default
    })], SidebarComponent);
    /***/
  },

  /***/
  "./src/app/components/common/topbar/topbar.component.ts":
  /*!**************************************************************!*\
    !*** ./src/app/components/common/topbar/topbar.component.ts ***!
    \**************************************************************/

  /*! exports provided: TopbarComponent */

  /***/
  function srcAppComponentsCommonTopbarTopbarComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TopbarComponent", function () {
      return TopbarComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var TopbarComponent =
    /*#__PURE__*/
    function () {
      function TopbarComponent() {
        _classCallCheck(this, TopbarComponent);

        this.sideBar = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }

      _createClass(TopbarComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "toggleSideBar",
        value: function toggleSideBar() {
          this.sideBar.emit();
        }
      }]);

      return TopbarComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], TopbarComponent.prototype, "sideBar", void 0);
    TopbarComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-topbar',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./topbar.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/topbar/topbar.component.html")).default
    })], TopbarComponent);
    /***/
  },

  /***/
  "./src/app/components/common/user-info/user-info.component.ts":
  /*!********************************************************************!*\
    !*** ./src/app/components/common/user-info/user-info.component.ts ***!
    \********************************************************************/

  /*! exports provided: UserInfoComponent */

  /***/
  function srcAppComponentsCommonUserInfoUserInfoComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UserInfoComponent", function () {
      return UserInfoComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var UserInfoComponent =
    /*#__PURE__*/
    function () {
      function UserInfoComponent() {
        _classCallCheck(this, UserInfoComponent);
      }

      _createClass(UserInfoComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return UserInfoComponent;
    }();

    UserInfoComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-user-info',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./user-info.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/common/user-info/user-info.component.html")).default
    })], UserInfoComponent);
    /***/
  },

  /***/
  "./src/app/components/configuration/configuration.component.ts":
  /*!*********************************************************************!*\
    !*** ./src/app/components/configuration/configuration.component.ts ***!
    \*********************************************************************/

  /*! exports provided: ConfigurationComponent */

  /***/
  function srcAppComponentsConfigurationConfigurationComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ConfigurationComponent", function () {
      return ConfigurationComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ConfigurationComponent =
    /*#__PURE__*/
    function () {
      function ConfigurationComponent() {
        _classCallCheck(this, ConfigurationComponent);
      }

      _createClass(ConfigurationComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return ConfigurationComponent;
    }();

    ConfigurationComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-configuration',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./configuration.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/configuration/configuration.component.html")).default
    })], ConfigurationComponent);
    /***/
  },

  /***/
  "./src/app/components/dashboard/dashboard.component.ts":
  /*!*************************************************************!*\
    !*** ./src/app/components/dashboard/dashboard.component.ts ***!
    \*************************************************************/

  /*! exports provided: DashboardComponent */

  /***/
  function srcAppComponentsDashboardDashboardComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DashboardComponent", function () {
      return DashboardComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var DashboardComponent =
    /*#__PURE__*/
    function () {
      function DashboardComponent() {
        _classCallCheck(this, DashboardComponent);
      }

      _createClass(DashboardComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return DashboardComponent;
    }();

    DashboardComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-dashboard',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./dashboard.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/dashboard/dashboard.component.html")).default
    })], DashboardComponent);
    /***/
  },

  /***/
  "./src/app/components/datatable/datatable.component.ts":
  /*!*************************************************************!*\
    !*** ./src/app/components/datatable/datatable.component.ts ***!
    \*************************************************************/

  /*! exports provided: DataTableComponent */

  /***/
  function srcAppComponentsDatatableDatatableComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DataTableComponent", function () {
      return DataTableComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var subsink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! subsink */
    "./node_modules/subsink/dist/index.js");
    /* harmony import */


    var subsink__WEBPACK_IMPORTED_MODULE_2___default =
    /*#__PURE__*/
    __webpack_require__.n(subsink__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */


    var _angular_material_table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/material/table */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/table.js");
    /* harmony import */


    var src_app_services_user_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! src/app/services/user.service */
    "./src/app/services/user.service.ts");
    /* harmony import */


    var moment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! moment */
    "./node_modules/moment/moment.js");
    /* harmony import */


    var moment__WEBPACK_IMPORTED_MODULE_5___default =
    /*#__PURE__*/
    __webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_5__);
    /* harmony import */


    var moment_locale_es_us__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! moment/locale/es-us */
    "./node_modules/moment/locale/es-us.js");
    /* harmony import */


    var moment_locale_es_us__WEBPACK_IMPORTED_MODULE_6___default =
    /*#__PURE__*/
    __webpack_require__.n(moment_locale_es_us__WEBPACK_IMPORTED_MODULE_6__);

    var DataTableComponent =
    /*#__PURE__*/
    function () {
      function DataTableComponent(userService) {
        _classCallCheck(this, DataTableComponent);

        this.userService = userService;
        this.subs = new subsink__WEBPACK_IMPORTED_MODULE_2__["SubSink"]();
        this.cardTitle = "Users";
        this.pageTitle = "Tables";
        this.pageDescription = "Para visualizar la data en esta tabla debes conectarte a un backend o a través de un servicio que traiga los datos. Revisa las instrucciones en los comentarios del código para mayor información"; // ARMADO DINÁMICO DE LA TABLA
        // title: corresponde al título que tendrá cada columna
        // key: es el identificador de la tabla que contiene el valor (propiedad)

        this.tableColumns = [{
          id: '1',
          key: 'id',
          title: 'ID',
          visible: true
        }, {
          id: '2',
          key: 'nombre',
          title: 'NOMBRE',
          visible: true
        }, {
          id: '3',
          key: 'apellido',
          title: 'APELLIDO',
          visible: true
        }, {
          id: '4',
          key: 'correo',
          title: 'CORREO',
          visible: true
        }, {
          id: '5',
          key: 'imagen',
          title: 'IMAGEN',
          visible: false
        }, {
          id: '6',
          key: 'password',
          title: 'PASSWORD',
          visible: false
        }, {
          id: '7',
          key: 'rol',
          title: 'ROL',
          visible: false
        }, {
          id: '8',
          key: 'createdAt',
          title: 'CREADO',
          visible: true
        }, {
          id: '9',
          key: 'updatedAt',
          title: 'ACTUALIZADO',
          visible: false
        }, {
          id: '10',
          key: 'deletedAt',
          title: 'BORRADO',
          visible: false
        }, {
          id: '0',
          key: 'options',
          title: 'OPTIONS',
          visible: true
        }];
        this.displayedColumns = this.tableColumns.map(function (c) {
          return c.id;
        });
        this.attributes = this.tableColumns.filter(function (c) {
          return c.visible && c.id != '0';
        }).map(function (m) {
          return m.key;
        });
        this.pageSize = 10;
        this.field = 'id';
        this.order = 'asc';
      }

      _createClass(DataTableComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          // OBTENEMOS LA DATA DE ALGÚN SERVICIO Y LA ASIGANAMOS AL DATASOURCE
          this.loadData();
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.subs.unsubscribe();
        }
      }, {
        key: "loadData",
        value: function loadData() {
          var _this307 = this;

          var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var attributes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var body = {
            page: page ? +page : 0,
            size: +this.pageSize,
            field: field ? field : this.field,
            order: order ? order : this.order,
            value: value ? value : this.filterValue,
            attributes: attributes ? attributes : this.attributes
          };
          this.subs.sink = this.userService.getUsers(body).subscribe(function (res) {
            _this307.csvData = res['data'];
            console.log(_this307.csvData);
            _this307.totalRows = res['total'];
            _this307.dataSource = new _angular_material_table__WEBPACK_IMPORTED_MODULE_3__["MatTableDataSource"](res['data']);

            _this307.dataSource.data.forEach(function (d) {
              d.createdAt = moment__WEBPACK_IMPORTED_MODULE_5__(d.createdAt).fromNow();
              d.updatedAt = moment__WEBPACK_IMPORTED_MODULE_5__(d.updatedAt).fromNow();
              d.deletedAt = moment__WEBPACK_IMPORTED_MODULE_5__(d.deletedAt).fromNow();
            });
          });
        }
      }, {
        key: "loadSize",
        value: function loadSize(e) {
          this.pageSize = e;
          this.loadData();
        }
      }, {
        key: "loadColumns",
        value: function loadColumns(e) {
          this.attributes = e;
          this.loadData();
        }
      }, {
        key: "delete",
        value: function _delete(id) {
          var _this308 = this;

          var del = confirm("¿Do you really want to delete this entry?");

          if (del) {
            this.subs.sink = this.userService.deleteUser(id).subscribe(function (res) {
              alert(res['message']);

              _this308.loadData();
            });
          }
        }
      }, {
        key: "edit",
        value: function edit(id) {}
      }, {
        key: "sortData",
        value: function sortData(e) {
          if (e.active != 6) {
            this.field = this.tableColumns.filter(function (c) {
              return c.id == e.active;
            })[0].key;
            this.order = e.direction;
            this.loadData(0, null, this.field, this.order);
          }
        }
      }]);

      return DataTableComponent;
    }();

    DataTableComponent.ctorParameters = function () {
      return [{
        type: src_app_services_user_service__WEBPACK_IMPORTED_MODULE_4__["UserService"]
      }];
    };

    DataTableComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-data-table',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./datatable.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/datatable.component.html")).default
    })], DataTableComponent);
    /***/
  },

  /***/
  "./src/app/components/datatable/filter-columns/filter-columns.component.ts":
  /*!*********************************************************************************!*\
    !*** ./src/app/components/datatable/filter-columns/filter-columns.component.ts ***!
    \*********************************************************************************/

  /*! exports provided: FilterColumnsComponent */

  /***/
  function srcAppComponentsDatatableFilterColumnsFilterColumnsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FilterColumnsComponent", function () {
      return FilterColumnsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @ng-bootstrap/ng-bootstrap */
    "./node_modules/@ng-bootstrap/ng-bootstrap/__ivy_ngcc__/fesm2015/ng-bootstrap.js");

    var FilterColumnsComponent =
    /*#__PURE__*/
    function () {
      function FilterColumnsComponent(modal) {
        _classCallCheck(this, FilterColumnsComponent);

        this.modal = modal;
        this.loadColumns = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }

      _createClass(FilterColumnsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "open",
        value: function open(content) {
          this.modal.open(content, {
            size: 'sm',
            centered: false
          });
        }
      }, {
        key: "close",
        value: function close() {
          this.modal.dismissAll();
        }
      }, {
        key: "filtrar",
        value: function filtrar() {
          var attributes = this.columns.filter(function (c) {
            return c.visible && c.id != '0';
          }).map(function (m) {
            return m.key;
          });
          this.loadColumns.emit(attributes);
          this.modal.dismissAll();
        }
      }]);

      return FilterColumnsComponent;
    }();

    FilterColumnsComponent.ctorParameters = function () {
      return [{
        type: _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_2__["NgbModal"]
      }];
    };

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], FilterColumnsComponent.prototype, "columns", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], FilterColumnsComponent.prototype, "loadColumns", void 0);
    FilterColumnsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-filter-columns',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./filter-columns.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/filter-columns/filter-columns.component.html")).default
    })], FilterColumnsComponent);
    /***/
  },

  /***/
  "./src/app/components/datatable/paginator/paginator.component.ts":
  /*!***********************************************************************!*\
    !*** ./src/app/components/datatable/paginator/paginator.component.ts ***!
    \***********************************************************************/

  /*! exports provided: PaginatorComponent */

  /***/
  function srcAppComponentsDatatablePaginatorPaginatorComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PaginatorComponent", function () {
      return PaginatorComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var PaginatorComponent =
    /*#__PURE__*/
    function () {
      function PaginatorComponent() {
        _classCallCheck(this, PaginatorComponent);

        this.pageSizeOptions = [];
        this.loadData = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.loadSize = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.currentPage = 1;
      }

      _createClass(PaginatorComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.fillPages();
        }
      }, {
        key: "changeSize",
        value: function changeSize() {
          this.fillPages();
          this.loadSize.emit(this.pageSize);
        } //paginacion

      }, {
        key: "pagination",
        value: function pagination(p) {
          this.currentPage = p;
          var i = this.currentPage * this.pageSize - this.pageSize;
          this.loadData.emit(i);
        }
      }, {
        key: "paginationPrev",
        value: function paginationPrev() {
          this.currentPage = this.currentPage > 1 ? this.currentPage - 1 : this.currentPage;
          var i = this.currentPage * this.pageSize - this.pageSize;
          this.loadData.emit(i);
        }
      }, {
        key: "paginationNext",
        value: function paginationNext() {
          this.currentPage = this.currentPage < this.lastPage ? this.currentPage + 1 : this.lastPage;
          var i = this.currentPage * this.pageSize - this.pageSize;
          this.loadData.emit(i);
        }
      }, {
        key: "paginationFirst",
        value: function paginationFirst() {
          this.currentPage = 1, this.loadData.emit(0);
        }
      }, {
        key: "paginationLast",
        value: function paginationLast() {
          this.currentPage = this.lastPage;
          var i = this.lastPage * this.pageSize - this.pageSize;
          this.loadData.emit(i);
        }
      }, {
        key: "fillPages",
        value: function fillPages() {
          this.pages = [];
          var b = Math.ceil(this.totalRows / this.pageSize);

          for (var i = 1; i <= b; i++) {
            this.pages.push(i);
            this.lastPage = i;
          }
        }
      }]);

      return PaginatorComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PaginatorComponent.prototype, "pageSize", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PaginatorComponent.prototype, "totalRows", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PaginatorComponent.prototype, "pageSizeOptions", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], PaginatorComponent.prototype, "loadData", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], PaginatorComponent.prototype, "loadSize", void 0);
    PaginatorComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-paginator',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./paginator.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/paginator/paginator.component.html")).default
    })], PaginatorComponent);
    /***/
  },

  /***/
  "./src/app/components/datatable/reports/reports.component.ts":
  /*!*******************************************************************!*\
    !*** ./src/app/components/datatable/reports/reports.component.ts ***!
    \*******************************************************************/

  /*! exports provided: ReportsComponent */

  /***/
  function srcAppComponentsDatatableReportsReportsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReportsComponent", function () {
      return ReportsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ReportsComponent =
    /*#__PURE__*/
    function () {
      function ReportsComponent() {
        _classCallCheck(this, ReportsComponent);

        this.columns = [];
        this.data = [];
        this.newData = [];
        this.now = new Date();
        /*name of the excel-file which will be downloaded. */

        this.xlsxFileName = 'TableReport ' + this.now;
        this.csvFileName = 'TableReport ' + this.now + '.csv';
      }

      _createClass(ReportsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          var _this309 = this;

          this.headers = this.columns.filter(function (c) {
            return c.visible && c.id != '0';
          }).map(function (c) {
            return c.title;
          });
          this.keys = this.columns.filter(function (c) {
            return c.visible && c.id != '0';
          }).map(function (m) {
            return m.key;
          });
          this.newData = [];
          this.data.forEach(function (d, i) {
            var campos = [];

            _this309.keys.forEach(function (k, j) {
              campos.push(d[k]);
            });

            _this309.newData.push(campos);
          }); // console.log(this.keys);

          this.options = {
            title: '',
            fieldSeparator: ',',
            quoteStrings: '"',
            decimalseparator: '.',
            showLabels: true,
            showTitle: false,
            useBom: true,
            headers: this.headers
          };
        }
      }, {
        key: "downloadCsv",
        value: function downloadCsv() {
          this.angular2Csv.generateCsv();
        }
      }, {
        key: "downloadExcel",
        value: function downloadExcel() {}
      }]);

      return ReportsComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], ReportsComponent.prototype, "columns", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], ReportsComponent.prototype, "data", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('angular2Csv', {
      static: false
    })], ReportsComponent.prototype, "angular2Csv", void 0);
    ReportsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-reports',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./reports.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/datatable/reports/reports.component.html")).default
    })], ReportsComponent);
    /***/
  },

  /***/
  "./src/app/components/forms/forms.component.ts":
  /*!*****************************************************!*\
    !*** ./src/app/components/forms/forms.component.ts ***!
    \*****************************************************/

  /*! exports provided: FormsComponent */

  /***/
  function srcAppComponentsFormsFormsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FormsComponent", function () {
      return FormsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var FormsComponent =
    /*#__PURE__*/
    function () {
      // fin de propiedades del formulario
      function FormsComponent() {
        _classCallCheck(this, FormsComponent);

        this.pageTitle = "Forms";
        this.pageDescription = "DataTables is a third party plugin that is used to generate the demo table below. For more information about DataTables, please visit the DataTables documentation";
        this.cardTitle = "Forms Example"; // INICIO DEL FORMULARIO
        // DECLARE EACH ONE OF THE INPUT FIELDS YOU WILL BE RECEIVING FROM THE FORM

        /*
        La propiedad "myForm" es tanto la declaración de todos los campos como de los valores que se recibirán del formulario.
        Esta es la variable que se pasará a ser validada y que guardará todos los valores recibidos.
        También se pueden declarar los valores iniciales o por defecto en esta variable cambiando el valor null por el deseado
        */

        this.myForm = {
          nombre: null,
          apellido: null,
          correo: null,
          telefono: null,
          edad: null,
          country: null,
          tipoDocumento: null,
          colores: {
            rojo: null,
            azul: null,
            verde: null
          },
          descripcion: null,
          nacimiento: null,
          archivo: null
        }; //

        /*
        EXPLICACIÓN DE LA VARIABLE myFormFields
        
          id          => es un identificador único para cada campo en el formulario
          tag         => corresponde a la etiqueta HTML del campo, puede ser cualquier etiqueta de formulario válida en HTML5
          name        => nombre del campo que también servirá como identificacdor en el formulario
          type        => tipo de input según sea el caso
          placeholder => es el mensaje que se muestra tanto en el campo como en la etiqueta LABEL
          required    => true si el campo es obligatorio y false si es opcional
          disabled    => indicador del campo si está habilitado o no,
          options     => si el campo es un tipo select o cualquier otro de opciones, estas se especifican dentro de este array
          options.id    => identificador único del campo
          options.value => valor por defecto del campo
          options.text => etiqueta del campo o texto a mostrar en la opción
        */

        this.myFormFields = [{
          id: 1,
          tag: 'input',
          name: 'nombre',
          type: 'text',
          placeholder: 'Nombre',
          required: true,
          disabled: false,
          options: []
        }, {
          id: 2,
          tag: 'input',
          name: 'apellido',
          type: 'text',
          placeholder: 'Apellidos',
          required: true,
          disabled: false,
          options: []
        }, {
          id: 4,
          tag: 'input',
          name: 'telefono',
          type: 'text',
          placeholder: 'Teléfono',
          required: true,
          disabled: false,
          options: []
        }, {
          id: 3,
          tag: 'input',
          name: 'correo',
          type: 'email',
          placeholder: 'Correo',
          required: true,
          disabled: false,
          options: []
        }, {
          id: 22,
          tag: 'input',
          name: 'password',
          type: 'password',
          placeholder: 'Password',
          required: true,
          disabled: false,
          options: []
        }, {
          id: 5,
          tag: 'input',
          name: 'edad',
          type: 'number',
          placeholder: 'Edad',
          required: true,
          disabled: false,
          options: []
        }, {
          id: 6,
          tag: 'select',
          name: 'country',
          type: 'text',
          placeholder: 'Country',
          required: true,
          disabled: false,
          options: [{
            id: 7,
            value: 'peru',
            text: 'Perú'
          }, {
            id: 8,
            value: 'chile',
            text: 'Chile'
          }, {
            id: 9,
            value: 'argentina',
            text: 'Argentina'
          }]
        }, {
          id: 10,
          tag: 'input',
          type: 'radio',
          name: 'tipoDocumento',
          placeholder: 'Tipo de Documento',
          required: true,
          disabled: false,
          options: [{
            id: 11,
            value: 'DNI',
            text: 'DNI'
          }, {
            id: 12,
            value: 'PASAPORTE',
            text: 'PASAPORTE'
          }, {
            id: 13,
            value: 'OTRO',
            text: 'OTRO'
          }]
        }, {
          id: 14,
          tag: 'input',
          type: 'checkbox',
          name: 'colores',
          placeholder: 'Colores Favoritos',
          required: true,
          disabled: false,
          options: [{
            id: 15,
            value: 'rojo',
            text: 'Rojo'
          }, {
            id: 16,
            value: 'azul',
            text: 'Azul'
          }, {
            id: 17,
            value: 'verde',
            text: 'Verde'
          }]
        }, {
          id: 19,
          tag: 'input',
          name: 'nacimiento',
          type: 'date',
          placeholder: 'Fecha de Nacimiento',
          required: true,
          disabled: false,
          options: []
        }, {
          id: 20,
          tag: 'input',
          name: 'archivo',
          type: 'file',
          placeholder: 'Subir Archivo',
          required: true,
          disabled: false,
          options: []
        }, {
          id: 21,
          tag: 'input',
          name: 'tiempo',
          type: 'time',
          placeholder: 'Tiempo',
          required: true,
          disabled: false,
          options: []
        }, {
          id: 18,
          tag: 'textarea',
          name: 'descripcion',
          type: 'text',
          placeholder: 'Descripción',
          required: true,
          disabled: false,
          options: []
        }];
        this.error = [];
      }

      _createClass(FormsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
        /* INICIO DE FUNCIONES DEL FORMULARIO */

      }, {
        key: "submitAction",
        value: function submitAction() {
          this.myForm; // VALIDACIÓN

          if (this.validateFormFields(this.myForm, this.myFormFields)) {
            /* AQUÍ DEBE IR EL LLAMADO AL SERVICIO QUE GUARDA LA INFORMACIÓN DEL FORMULARIO
            ...
             */
            //RESETEAR EL FORMULARIO PARA NUEVOS DATOS
            this.Formulario.nativeElement.reset();
          }
        } // ESTA FUNCION SE ENCARGA DE VALIDAR QUE TODOS LOS VALORES RECIBIDO ESTÉN CONFORME LO DECLARADO

      }, {
        key: "validateFormFields",
        value: function validateFormFields(myForm, myFormFields) {
          var _this310 = this;

          console.log(myForm.correo);
          var valid = true;
          this.error = [];
          myFormFields.forEach(function (e) {
            if (myForm[e.name] == null && e.required) {
              _this310.error[e.id] = "El campo " + e.placeholder + " no puede estar vacío";
              valid = false;
            }

            if (e.type == 'email') {
              valid = _this310.validateEmail(myForm[e.name]);
              if (!valid) _this310.error[e.id] = "Este no es un correo válido";
            }
          });
          return valid;
        } // Función para validar el formato del email

      }, {
        key: "validateEmail",
        value: function validateEmail(mail) {
          if (/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(mail)) {
            return true;
          }

          return false;
        }
      }]);

      return FormsComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('Formulario', {
      static: false
    })], FormsComponent.prototype, "Formulario", void 0);
    FormsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-forms',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./forms.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/forms/forms.component.html")).default
    })], FormsComponent);
    /***/
  },

  /***/
  "./src/app/components/interface/animaitions/animaitions.component.ts":
  /*!***************************************************************************!*\
    !*** ./src/app/components/interface/animaitions/animaitions.component.ts ***!
    \***************************************************************************/

  /*! exports provided: AnimaitionsComponent */

  /***/
  function srcAppComponentsInterfaceAnimaitionsAnimaitionsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AnimaitionsComponent", function () {
      return AnimaitionsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var AnimaitionsComponent =
    /*#__PURE__*/
    function () {
      function AnimaitionsComponent() {
        _classCallCheck(this, AnimaitionsComponent);
      }

      _createClass(AnimaitionsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return AnimaitionsComponent;
    }();

    AnimaitionsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-animaitions',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./animaitions.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/animaitions/animaitions.component.html")).default
    })], AnimaitionsComponent);
    /***/
  },

  /***/
  "./src/app/components/interface/blank/blank.component.ts":
  /*!***************************************************************!*\
    !*** ./src/app/components/interface/blank/blank.component.ts ***!
    \***************************************************************/

  /*! exports provided: BlankComponent */

  /***/
  function srcAppComponentsInterfaceBlankBlankComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BlankComponent", function () {
      return BlankComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var BlankComponent =
    /*#__PURE__*/
    function () {
      function BlankComponent() {
        _classCallCheck(this, BlankComponent);
      }

      _createClass(BlankComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return BlankComponent;
    }();

    BlankComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-blank',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./blank.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/blank/blank.component.html")).default
    })], BlankComponent);
    /***/
  },

  /***/
  "./src/app/components/interface/borders/borders.component.ts":
  /*!*******************************************************************!*\
    !*** ./src/app/components/interface/borders/borders.component.ts ***!
    \*******************************************************************/

  /*! exports provided: BordersComponent */

  /***/
  function srcAppComponentsInterfaceBordersBordersComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BordersComponent", function () {
      return BordersComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var BordersComponent =
    /*#__PURE__*/
    function () {
      function BordersComponent() {
        _classCallCheck(this, BordersComponent);
      }

      _createClass(BordersComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return BordersComponent;
    }();

    BordersComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-borders',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./borders.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/borders/borders.component.html")).default
    })], BordersComponent);
    /***/
  },

  /***/
  "./src/app/components/interface/buttons/buttons.component.ts":
  /*!*******************************************************************!*\
    !*** ./src/app/components/interface/buttons/buttons.component.ts ***!
    \*******************************************************************/

  /*! exports provided: ButtonsComponent */

  /***/
  function srcAppComponentsInterfaceButtonsButtonsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ButtonsComponent", function () {
      return ButtonsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ButtonsComponent =
    /*#__PURE__*/
    function () {
      function ButtonsComponent() {
        _classCallCheck(this, ButtonsComponent);
      }

      _createClass(ButtonsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return ButtonsComponent;
    }();

    ButtonsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-buttons',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./buttons.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/buttons/buttons.component.html")).default
    })], ButtonsComponent);
    /***/
  },

  /***/
  "./src/app/components/interface/cards/cards.component.ts":
  /*!***************************************************************!*\
    !*** ./src/app/components/interface/cards/cards.component.ts ***!
    \***************************************************************/

  /*! exports provided: CardsComponent */

  /***/
  function srcAppComponentsInterfaceCardsCardsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CardsComponent", function () {
      return CardsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var CardsComponent =
    /*#__PURE__*/
    function () {
      function CardsComponent() {
        _classCallCheck(this, CardsComponent);
      }

      _createClass(CardsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return CardsComponent;
    }();

    CardsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-cards',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./cards.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/cards/cards.component.html")).default
    })], CardsComponent);
    /***/
  },

  /***/
  "./src/app/components/interface/colors/colors.component.ts":
  /*!*****************************************************************!*\
    !*** ./src/app/components/interface/colors/colors.component.ts ***!
    \*****************************************************************/

  /*! exports provided: ColorsComponent */

  /***/
  function srcAppComponentsInterfaceColorsColorsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ColorsComponent", function () {
      return ColorsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ColorsComponent =
    /*#__PURE__*/
    function () {
      function ColorsComponent() {
        _classCallCheck(this, ColorsComponent);
      }

      _createClass(ColorsComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return ColorsComponent;
    }();

    ColorsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-colors',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./colors.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/colors/colors.component.html")).default
    })], ColorsComponent);
    /***/
  },

  /***/
  "./src/app/components/interface/interface.module.ts":
  /*!**********************************************************!*\
    !*** ./src/app/components/interface/interface.module.ts ***!
    \**********************************************************/

  /*! exports provided: InterfaceModule */

  /***/
  function srcAppComponentsInterfaceInterfaceModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InterfaceModule", function () {
      return InterfaceModule;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _animaitions_animaitions_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./animaitions/animaitions.component */
    "./src/app/components/interface/animaitions/animaitions.component.ts");
    /* harmony import */


    var _borders_borders_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./borders/borders.component */
    "./src/app/components/interface/borders/borders.component.ts");
    /* harmony import */


    var _buttons_buttons_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./buttons/buttons.component */
    "./src/app/components/interface/buttons/buttons.component.ts");
    /* harmony import */


    var _cards_cards_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./cards/cards.component */
    "./src/app/components/interface/cards/cards.component.ts");
    /* harmony import */


    var _colors_colors_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ./colors/colors.component */
    "./src/app/components/interface/colors/colors.component.ts");
    /* harmony import */


    var _other_other_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ./other/other.component */
    "./src/app/components/interface/other/other.component.ts");
    /* harmony import */


    var _blank_blank_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ./blank/blank.component */
    "./src/app/components/interface/blank/blank.component.ts");
    /* harmony import */


    var _unknown_unknown_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ./unknown/unknown.component */
    "./src/app/components/interface/unknown/unknown.component.ts");

    var InterfaceModule = function InterfaceModule() {
      _classCallCheck(this, InterfaceModule);
    };

    InterfaceModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
      declarations: [_animaitions_animaitions_component__WEBPACK_IMPORTED_MODULE_2__["AnimaitionsComponent"], _borders_borders_component__WEBPACK_IMPORTED_MODULE_3__["BordersComponent"], _buttons_buttons_component__WEBPACK_IMPORTED_MODULE_4__["ButtonsComponent"], _cards_cards_component__WEBPACK_IMPORTED_MODULE_5__["CardsComponent"], _colors_colors_component__WEBPACK_IMPORTED_MODULE_6__["ColorsComponent"], _other_other_component__WEBPACK_IMPORTED_MODULE_7__["OtherComponent"], _blank_blank_component__WEBPACK_IMPORTED_MODULE_8__["BlankComponent"], _unknown_unknown_component__WEBPACK_IMPORTED_MODULE_9__["UnknownComponent"]]
    })], InterfaceModule);
    /***/
  },

  /***/
  "./src/app/components/interface/other/other.component.ts":
  /*!***************************************************************!*\
    !*** ./src/app/components/interface/other/other.component.ts ***!
    \***************************************************************/

  /*! exports provided: OtherComponent */

  /***/
  function srcAppComponentsInterfaceOtherOtherComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OtherComponent", function () {
      return OtherComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var OtherComponent =
    /*#__PURE__*/
    function () {
      function OtherComponent() {
        _classCallCheck(this, OtherComponent);
      }

      _createClass(OtherComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return OtherComponent;
    }();

    OtherComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-other',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./other.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/other/other.component.html")).default
    })], OtherComponent);
    /***/
  },

  /***/
  "./src/app/components/interface/unknown/unknown.component.ts":
  /*!*******************************************************************!*\
    !*** ./src/app/components/interface/unknown/unknown.component.ts ***!
    \*******************************************************************/

  /*! exports provided: UnknownComponent */

  /***/
  function srcAppComponentsInterfaceUnknownUnknownComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UnknownComponent", function () {
      return UnknownComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var UnknownComponent =
    /*#__PURE__*/
    function () {
      function UnknownComponent() {
        _classCallCheck(this, UnknownComponent);
      }

      _createClass(UnknownComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return UnknownComponent;
    }();

    UnknownComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-unknown',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./unknown.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/interface/unknown/unknown.component.html")).default
    })], UnknownComponent);
    /***/
  },

  /***/
  "./src/app/components/layout/layout.component.ts":
  /*!*******************************************************!*\
    !*** ./src/app/components/layout/layout.component.ts ***!
    \*******************************************************/

  /*! exports provided: LayoutComponent */

  /***/
  function srcAppComponentsLayoutLayoutComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LayoutComponent", function () {
      return LayoutComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var LayoutComponent =
    /*#__PURE__*/
    function () {
      function LayoutComponent() {
        _classCallCheck(this, LayoutComponent);
      }

      _createClass(LayoutComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "toggleSideBar",
        value: function toggleSideBar() {
          this.sidebar.toggle();
        }
      }]);

      return LayoutComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('sidebar')], LayoutComponent.prototype, "sidebar", void 0);
    LayoutComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-layout',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./layout.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/layout/layout.component.html")).default
    })], LayoutComponent);
    /***/
  },

  /***/
  "./src/app/components/profile/profile.component.ts":
  /*!*********************************************************!*\
    !*** ./src/app/components/profile/profile.component.ts ***!
    \*********************************************************/

  /*! exports provided: ProfileComponent */

  /***/
  function srcAppComponentsProfileProfileComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ProfileComponent", function () {
      return ProfileComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ProfileComponent =
    /*#__PURE__*/
    function () {
      function ProfileComponent() {
        _classCallCheck(this, ProfileComponent);
      }

      _createClass(ProfileComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return ProfileComponent;
    }();

    ProfileComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-profile',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./profile.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/profile/profile.component.html")).default
    })], ProfileComponent);
    /***/
  },

  /***/
  "./src/app/components/progress-bar/progress-bar.component.ts":
  /*!*******************************************************************!*\
    !*** ./src/app/components/progress-bar/progress-bar.component.ts ***!
    \*******************************************************************/

  /*! exports provided: ProgressBarComponent */

  /***/
  function srcAppComponentsProgressBarProgressBarComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ProgressBarComponent", function () {
      return ProgressBarComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ProgressBarComponent =
    /*#__PURE__*/
    function () {
      function ProgressBarComponent() {
        _classCallCheck(this, ProgressBarComponent);

        this.bars = [{
          nombre: 'Server Migration',
          progreso: 20,
          color: '#e74a3b' //bg-danger

        }, {
          nombre: 'Sales tracking',
          progreso: 40,
          color: '#f6c23e' //bg-warning   

        }, {
          nombre: 'Customer Database',
          progreso: 60,
          color: '#4e73df' //bg-primary   

        }, {
          nombre: 'Payout Details',
          progreso: 80,
          color: '#36b9cc' //bg-primary   

        }, {
          nombre: 'Account Setup',
          progreso: 100,
          color: '#1cc88a' //bg-primary   

        }];
      }

      _createClass(ProgressBarComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return ProgressBarComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], ProgressBarComponent.prototype, "bars", void 0);
    ProgressBarComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-progress-bar',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./progress-bar.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/progress-bar/progress-bar.component.html")).default
    })], ProgressBarComponent);
    /***/
  },

  /***/
  "./src/app/components/public/login/login.component.ts":
  /*!************************************************************!*\
    !*** ./src/app/components/public/login/login.component.ts ***!
    \************************************************************/

  /*! exports provided: LoginComponent */

  /***/
  function srcAppComponentsPublicLoginLoginComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LoginComponent", function () {
      return LoginComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var subsink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! subsink */
    "./node_modules/subsink/dist/index.js");
    /* harmony import */


    var subsink__WEBPACK_IMPORTED_MODULE_2___default =
    /*#__PURE__*/
    __webpack_require__.n(subsink__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */


    var src_app_services_user_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! src/app/services/user.service */
    "./src/app/services/user.service.ts");
    /* harmony import */


    var _angular_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/router */
    "./node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js");

    var LoginComponent =
    /*#__PURE__*/
    function () {
      function LoginComponent(userService, router) {
        _classCallCheck(this, LoginComponent);

        this.userService = userService;
        this.router = router;
        this.subs = new subsink__WEBPACK_IMPORTED_MODULE_2__["SubSink"]();
        this.usuario = {
          email: null,
          password: null
        };
      }

      _createClass(LoginComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.subs.unsubscribe();
        }
      }, {
        key: "login",
        value: function login() {
          var _this311 = this;

          console.log('validando');
          this.subs.sink = this.userService.login(this.usuario).subscribe(function (res) {
            alert(res['message']);

            _this311.router.navigateByUrl('/dashboard');
          });
          this.loginForm.nativeElement.reset();
        }
      }]);

      return LoginComponent;
    }();

    LoginComponent.ctorParameters = function () {
      return [{
        type: src_app_services_user_service__WEBPACK_IMPORTED_MODULE_3__["UserService"]
      }, {
        type: _angular_router__WEBPACK_IMPORTED_MODULE_4__["Router"]
      }];
    };

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('loginForm', {
      static: false
    })], LoginComponent.prototype, "loginForm", void 0);
    LoginComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-login',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./login.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/public/login/login.component.html")).default
    })], LoginComponent);
    /***/
  },

  /***/
  "./src/app/components/public/recover/recover.component.ts":
  /*!****************************************************************!*\
    !*** ./src/app/components/public/recover/recover.component.ts ***!
    \****************************************************************/

  /*! exports provided: RecoverComponent */

  /***/
  function srcAppComponentsPublicRecoverRecoverComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RecoverComponent", function () {
      return RecoverComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var RecoverComponent =
    /*#__PURE__*/
    function () {
      function RecoverComponent() {
        _classCallCheck(this, RecoverComponent);
      }

      _createClass(RecoverComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return RecoverComponent;
    }();

    RecoverComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-recover',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./recover.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/public/recover/recover.component.html")).default
    })], RecoverComponent);
    /***/
  },

  /***/
  "./src/app/components/public/register/register.component.ts":
  /*!******************************************************************!*\
    !*** ./src/app/components/public/register/register.component.ts ***!
    \******************************************************************/

  /*! exports provided: RegisterComponent */

  /***/
  function srcAppComponentsPublicRegisterRegisterComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RegisterComponent", function () {
      return RegisterComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var subsink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! subsink */
    "./node_modules/subsink/dist/index.js");
    /* harmony import */


    var subsink__WEBPACK_IMPORTED_MODULE_2___default =
    /*#__PURE__*/
    __webpack_require__.n(subsink__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */


    var src_app_services_user_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! src/app/services/user.service */
    "./src/app/services/user.service.ts");
    /* harmony import */


    var _angular_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/router */
    "./node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js");

    var RegisterComponent =
    /*#__PURE__*/
    function () {
      function RegisterComponent(userService, router) {
        _classCallCheck(this, RegisterComponent);

        this.userService = userService;
        this.router = router;
        this.subs = new subsink__WEBPACK_IMPORTED_MODULE_2__["SubSink"]();
        this.usuario = {
          nombre: null,
          apellido: null,
          email: null,
          password: null
        };
      }

      _createClass(RegisterComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.subs.unsubscribe();
        }
      }, {
        key: "register",
        value: function register() {
          var _this312 = this;

          console.log('registrando', this.usuario);
          this.subs.sink = this.userService.registraUsuario(this.usuario).subscribe(function (res) {
            alert(res['message']);

            _this312.router.navigateByUrl('/login');
          });
        }
      }]);

      return RegisterComponent;
    }();

    RegisterComponent.ctorParameters = function () {
      return [{
        type: src_app_services_user_service__WEBPACK_IMPORTED_MODULE_3__["UserService"]
      }, {
        type: _angular_router__WEBPACK_IMPORTED_MODULE_4__["Router"]
      }];
    };

    RegisterComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-register',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./register.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/public/register/register.component.html")).default
    })], RegisterComponent);
    /***/
  },

  /***/
  "./src/app/material.module.ts":
  /*!************************************!*\
    !*** ./src/app/material.module.ts ***!
    \************************************/

  /*! exports provided: MaterialModule */

  /***/
  function srcAppMaterialModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MaterialModule", function () {
      return MaterialModule;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/cdk/a11y */
    "./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/a11y.js");
    /* harmony import */


    var _angular_cdk_clipboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/clipboard */
    "./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/clipboard.js");
    /* harmony import */


    var _angular_cdk_drag_drop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/cdk/drag-drop */
    "./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/drag-drop.js");
    /* harmony import */


    var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/cdk/portal */
    "./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/portal.js");
    /* harmony import */


    var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/cdk/scrolling */
    "./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js");
    /* harmony import */


    var _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @angular/cdk/stepper */
    "./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/stepper.js");
    /* harmony import */


    var _angular_cdk_table__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! @angular/cdk/table */
    "./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/table.js");
    /* harmony import */


    var _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! @angular/cdk/tree */
    "./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/tree.js");
    /* harmony import */


    var _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! @angular/material/autocomplete */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/autocomplete.js");
    /* harmony import */


    var _angular_material_badge__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! @angular/material/badge */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/badge.js");
    /* harmony import */


    var _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! @angular/material/bottom-sheet */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/bottom-sheet.js");
    /* harmony import */


    var _angular_material_button__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
    /*! @angular/material/button */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/button.js");
    /* harmony import */


    var _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
    /*! @angular/material/button-toggle */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/button-toggle.js");
    /* harmony import */


    var _angular_material_card__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
    /*! @angular/material/card */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/card.js");
    /* harmony import */


    var _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
    /*! @angular/material/checkbox */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/checkbox.js");
    /* harmony import */


    var _angular_material_chips__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
    /*! @angular/material/chips */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/chips.js");
    /* harmony import */


    var _angular_material_stepper__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
    /*! @angular/material/stepper */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/stepper.js");
    /* harmony import */


    var _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
    /*! @angular/material/datepicker */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/datepicker.js");
    /* harmony import */


    var _angular_material_dialog__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(
    /*! @angular/material/dialog */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/dialog.js");
    /* harmony import */


    var _angular_material_divider__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(
    /*! @angular/material/divider */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/divider.js");
    /* harmony import */


    var _angular_material_expansion__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(
    /*! @angular/material/expansion */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/expansion.js");
    /* harmony import */


    var _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(
    /*! @angular/material/grid-list */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/grid-list.js");
    /* harmony import */


    var _angular_material_icon__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(
    /*! @angular/material/icon */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/icon.js");
    /* harmony import */


    var _angular_material_input__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(
    /*! @angular/material/input */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/input.js");
    /* harmony import */


    var _angular_material_list__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(
    /*! @angular/material/list */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/list.js");
    /* harmony import */


    var _angular_material_menu__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(
    /*! @angular/material/menu */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/menu.js");
    /* harmony import */


    var _angular_material_core__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(
    /*! @angular/material/core */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_material_paginator__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(
    /*! @angular/material/paginator */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/paginator.js");
    /* harmony import */


    var _angular_material_progress_bar__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(
    /*! @angular/material/progress-bar */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/progress-bar.js");
    /* harmony import */


    var _angular_material_progress_spinner__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(
    /*! @angular/material/progress-spinner */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/progress-spinner.js");
    /* harmony import */


    var _angular_material_radio__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(
    /*! @angular/material/radio */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/radio.js");
    /* harmony import */


    var _angular_material_select__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(
    /*! @angular/material/select */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/select.js");
    /* harmony import */


    var _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(
    /*! @angular/material/sidenav */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/sidenav.js");
    /* harmony import */


    var _angular_material_slider__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(
    /*! @angular/material/slider */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/slider.js");
    /* harmony import */


    var _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(
    /*! @angular/material/slide-toggle */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/slide-toggle.js");
    /* harmony import */


    var _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(
    /*! @angular/material/snack-bar */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/snack-bar.js");
    /* harmony import */


    var _angular_material_sort__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(
    /*! @angular/material/sort */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/sort.js");
    /* harmony import */


    var _angular_material_table__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(
    /*! @angular/material/table */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/table.js");
    /* harmony import */


    var _angular_material_tabs__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(
    /*! @angular/material/tabs */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/tabs.js");
    /* harmony import */


    var _angular_material_toolbar__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(
    /*! @angular/material/toolbar */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/toolbar.js");
    /* harmony import */


    var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(
    /*! @angular/material/tooltip */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/tooltip.js");
    /* harmony import */


    var _angular_material_tree__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(
    /*! @angular/material/tree */
    "./node_modules/@angular/material/__ivy_ngcc__/fesm2015/tree.js");

    var MaterialModule = function MaterialModule() {
      _classCallCheck(this, MaterialModule);
    };

    MaterialModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
      exports: [_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_2__["A11yModule"], _angular_cdk_clipboard__WEBPACK_IMPORTED_MODULE_3__["ClipboardModule"], _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_7__["CdkStepperModule"], _angular_cdk_table__WEBPACK_IMPORTED_MODULE_8__["CdkTableModule"], _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_9__["CdkTreeModule"], _angular_cdk_drag_drop__WEBPACK_IMPORTED_MODULE_4__["DragDropModule"], _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_10__["MatAutocompleteModule"], _angular_material_badge__WEBPACK_IMPORTED_MODULE_11__["MatBadgeModule"], _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_12__["MatBottomSheetModule"], _angular_material_button__WEBPACK_IMPORTED_MODULE_13__["MatButtonModule"], _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_14__["MatButtonToggleModule"], _angular_material_card__WEBPACK_IMPORTED_MODULE_15__["MatCardModule"], _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_16__["MatCheckboxModule"], _angular_material_chips__WEBPACK_IMPORTED_MODULE_17__["MatChipsModule"], _angular_material_stepper__WEBPACK_IMPORTED_MODULE_18__["MatStepperModule"], _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_19__["MatDatepickerModule"], _angular_material_dialog__WEBPACK_IMPORTED_MODULE_20__["MatDialogModule"], _angular_material_divider__WEBPACK_IMPORTED_MODULE_21__["MatDividerModule"], _angular_material_expansion__WEBPACK_IMPORTED_MODULE_22__["MatExpansionModule"], _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_23__["MatGridListModule"], _angular_material_icon__WEBPACK_IMPORTED_MODULE_24__["MatIconModule"], _angular_material_input__WEBPACK_IMPORTED_MODULE_25__["MatInputModule"], _angular_material_list__WEBPACK_IMPORTED_MODULE_26__["MatListModule"], _angular_material_menu__WEBPACK_IMPORTED_MODULE_27__["MatMenuModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_28__["MatNativeDateModule"], _angular_material_paginator__WEBPACK_IMPORTED_MODULE_29__["MatPaginatorModule"], _angular_material_progress_bar__WEBPACK_IMPORTED_MODULE_30__["MatProgressBarModule"], _angular_material_progress_spinner__WEBPACK_IMPORTED_MODULE_31__["MatProgressSpinnerModule"], _angular_material_radio__WEBPACK_IMPORTED_MODULE_32__["MatRadioModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_28__["MatRippleModule"], _angular_material_select__WEBPACK_IMPORTED_MODULE_33__["MatSelectModule"], _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_34__["MatSidenavModule"], _angular_material_slider__WEBPACK_IMPORTED_MODULE_35__["MatSliderModule"], _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_36__["MatSlideToggleModule"], _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_37__["MatSnackBarModule"], _angular_material_sort__WEBPACK_IMPORTED_MODULE_38__["MatSortModule"], _angular_material_table__WEBPACK_IMPORTED_MODULE_39__["MatTableModule"], _angular_material_tabs__WEBPACK_IMPORTED_MODULE_40__["MatTabsModule"], _angular_material_toolbar__WEBPACK_IMPORTED_MODULE_41__["MatToolbarModule"], _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_42__["MatTooltipModule"], _angular_material_tree__WEBPACK_IMPORTED_MODULE_43__["MatTreeModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["PortalModule"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__["ScrollingModule"]]
    })], MaterialModule);
    /**  Copyright 2019 Google LLC. All Rights Reserved.
        Use of this source code is governed by an MIT-style license that
        can be found in the LICENSE file at http://angular.io/license */

    /***/
  },

  /***/
  "./src/app/services/server.service.ts":
  /*!********************************************!*\
    !*** ./src/app/services/server.service.ts ***!
    \********************************************/

  /*! exports provided: ServerService */

  /***/
  function srcAppServicesServerServiceTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ServerService", function () {
      return ServerService;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ServerService = function ServerService() {
      _classCallCheck(this, ServerService);

      this.API_URI = "http://localhost:3000/api/";
    };

    ServerService = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
      providedIn: 'root'
    })], ServerService);
    /***/
  },

  /***/
  "./src/app/services/user.service.ts":
  /*!******************************************!*\
    !*** ./src/app/services/user.service.ts ***!
    \******************************************/

  /*! exports provided: UserService */

  /***/
  function srcAppServicesUserServiceTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UserService", function () {
      return UserService;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/common/http */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/http.js");
    /* harmony import */


    var _server_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./server.service */
    "./src/app/services/server.service.ts");

    var UserService =
    /*#__PURE__*/
    function () {
      function UserService(api, http) {
        _classCallCheck(this, UserService);

        this.api = api;
        this.http = http;
        this.api_url = api.API_URI + 'users';
      }

      _createClass(UserService, [{
        key: "registraUsuario",
        value: function registraUsuario(usuario) {
          return this.http.post(this.api_url, usuario);
        }
      }, {
        key: "login",
        value: function login(usuario) {
          return this.http.post(this.api_url + "/authenticate", usuario);
        }
      }, {
        key: "getUsers",
        value: function getUsers(body) {
          return this.http.post(this.api_url + '/get', body);
        }
      }, {
        key: "getFiltered",
        value: function getFiltered(body) {
          return this.http.post(this.api_url + '/filtered', body);
        }
      }, {
        key: "deleteUser",
        value: function deleteUser(id) {
          return this.http.delete(this.api_url + '/' + id);
        }
      }]);

      return UserService;
    }();

    UserService.ctorParameters = function () {
      return [{
        type: _server_service__WEBPACK_IMPORTED_MODULE_3__["ServerService"]
      }, {
        type: _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"]
      }];
    };

    UserService = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
      providedIn: 'root'
    })], UserService);
    /***/
  },

  /***/
  "./src/environments/environment.ts":
  /*!*****************************************!*\
    !*** ./src/environments/environment.ts ***!
    \*****************************************/

  /*! exports provided: environment */

  /***/
  function srcEnvironmentsEnvironmentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "environment", function () {
      return environment;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js"); // This file can be replaced during build by using the `fileReplacements` array.
    // `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.
    // The list of file replacements can be found in `angular.json`.


    var environment = {
      production: false
    };
    /*
     * For easier debugging in development mode, you can import the following file
     * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.
     *
     * This import should be commented out in production mode because it will have a negative impact
     * on performance if an error is thrown.
     */
    // import 'zone.js/dist/zone-error';  // Included with Angular CLI.

    /***/
  },

  /***/
  "./src/main.ts":
  /*!*********************!*\
    !*** ./src/main.ts ***!
    \*********************/

  /*! no exports provided */

  /***/
  function srcMainTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/platform-browser-dynamic */
    "./node_modules/@angular/platform-browser-dynamic/__ivy_ngcc__/fesm2015/platform-browser-dynamic.js");
    /* harmony import */


    var _app_app_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./app/app.module */
    "./src/app/app.module.ts");
    /* harmony import */


    var _environments_environment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./environments/environment */
    "./src/environments/environment.ts");

    if (_environments_environment__WEBPACK_IMPORTED_MODULE_4__["environment"].production) {
      Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["enableProdMode"])();
    }

    Object(_angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_2__["platformBrowserDynamic"])().bootstrapModule(_app_app_module__WEBPACK_IMPORTED_MODULE_3__["AppModule"]).catch(function (err) {
      return console.error(err);
    });
    /***/
  },

  /***/
  0:
  /*!***************************!*\
    !*** multi ./src/main.ts ***!
    \***************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(
    /*! C:\Users\Panacea04\Documents\GitHub\StartBootstrap-Admin2\src\main.ts */
    "./src/main.ts");
    /***/
  }
}, [[0, "runtime", "vendor"]]]);
//# sourceMappingURL=main-es5.js.map